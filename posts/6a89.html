<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Redis | 奕七</title><meta name="keywords" content="Java,Redis"><meta name="author" content="奕七,2392889869@qq.com"><meta name="copyright" content="奕七"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Redis"><meta name="application-name" content="Redis"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="Redis入门简介Redis是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串、哈希表、列表、集合、有序集合、位图、超级日志和地理空间索引等。与其他key-value存储不同的是，Redis提供了更为复杂的数据结构并且提供对他们的原子性操作 关系型SQL和NoSQL对比关系型SQL数据库和NoSQL数据库是两种不同的数据库类型，它们在很多方面都有所不同。以">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://y-yiqi.github.io/posts/6a89.html">
<meta property="og:site_name" content="奕七">
<meta property="og:description" content="Redis入门简介Redis是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串、哈希表、列表、集合、有序集合、位图、超级日志和地理空间索引等。与其他key-value存储不同的是，Redis提供了更为复杂的数据结构并且提供对他们的原子性操作 关系型SQL和NoSQL对比关系型SQL数据库和NoSQL数据库是两种不同的数据库类型，它们在很多方面都有所不同。以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://y-yiqi.github.io/img/default_cover.jpg">
<meta property="article:published_time" content="2020-02-23T09:09:13.000Z">
<meta property="article:modified_time" content="2023-05-21T11:45:42.334Z">
<meta property="article:author" content="奕七">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://y-yiqi.github.io/img/default_cover.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://y-yiqi.github.io/posts/6a89"><link rel="preconnect" href="//npm.elemecdn.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-21 19:45:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/"><div class="title">奕七</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=7451835303&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" style="display: flex"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" href="javascript:void(0);" title="浅色和深色模式转换" onclick="rm.switchDarkMode()"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke" style="font-size: 1.3rem"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java/"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a><a class="article-meta__tags" href="/tags/Redis/"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Redis</span></a></span></div></div><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-23T09:09:13.000Z" title="发表于 2020-02-23 17:09:13">2020-02-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-21T11:45:42.334Z" title="更新于 2023-05-21 19:45:42">2023-05-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">29.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>109分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/default_cover.jpg"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串、哈希表、列表、集合、有序集合、位图、超级日志和地理空间索引等。与其他key-value存储不同的是，Redis提供了更为复杂的数据结构并且提供对他们的原子性操作</p>
<h3 id="关系型SQL和NoSQL对比"><a href="#关系型SQL和NoSQL对比" class="headerlink" title="关系型SQL和NoSQL对比"></a>关系型SQL和NoSQL对比</h3><p>关系型SQL数据库和NoSQL数据库是两种不同的数据库类型，它们在很多方面都有所不同。以下是它们的主要对比：</p>
<ol>
<li>数据模型<br>关系型SQL数据库使用表格来存储和组织数据，数据之间的关系通过外键来建立。而NoSQL数据库则使用不同的数据模型，如文档型、键值型、列族型、图形数据库等。 </li>
<li>数据库设计<br>关系型SQL数据库需要在设计时预先定义表格的结构和关系，而NoSQL数据库则更加灵活，可以在开发过程中根据需要动态添加数据。 </li>
<li>数据一致性<br>关系型SQL数据库强调数据一致性，支持ACID事务，保证数据的完整性和一致性。而NoSQL数据库则更加注重数据的可扩展性和分布式存储，在数据一致性上可能有所牺牲。 </li>
<li>读写性能<br>NoSQL数据库在读写性能上通常比关系型SQL数据库更好，因为NoSQL数据库可以水平扩展，支持分布式存储和处理，而关系型SQL数据库则更适合处理复杂的查询和事务操作。 </li>
<li>数据处理方式<br>关系型SQL数据库通常使用结构化查询语言（SQL）来处理数据，而NoSQL数据库则更加灵活，可以使用各种不同的数据处理方式和编程语言。 </li>
<li>数据存储方式<br>关系型SQL数据库通常使用磁盘存储，而NoSQL数据库则通常使用内存存储或者混合存储。 </li>
<li>数据复制和备份<br>NoSQL数据库通常具有更好的数据复制和备份功能，因为它们支持分布式存储和处理，而关系型SQL数据库则需要更多的复杂性和资源来实现数据复制和备份。</li>
</ol>
<p>总的来说，关系型SQL数据库适合处理结构化数据和需要保证数据一致性的场景，而NoSQL数据库则适合处理大量非结构化或半结构化数据，需要高可扩展性和高读写性能的场景。</p>
<h3 id="Redis特征"><a href="#Redis特征" class="headerlink" title="Redis特征"></a>Redis特征</h3><p>Redis是一种开源的内存数据存储系统，它具有以下几个特征：</p>
<ol>
<li>内存存储<br>Redis将所有数据都存储在内存中，这使得它具有极快的读写速度。同时，Redis也支持将数据持久化到磁盘中，以保证数据的可靠性。 </li>
<li>键值存储<br>Redis是一种键值存储系统，它支持多种数据类型，如字符串、列表、哈希表、集合等。用户可以根据需要选择合适的数据类型存储数据。 </li>
<li>高性能<br>Redis具有非常高的读写性能，它可以处理数以百万计的操作，每秒钟可以处理数百万个键值对的读写操作。 </li>
<li>支持多种数据结构<br>Redis支持多种数据结构，如字符串、列表、哈希表、集合、有序集合等。这些数据结构可以满足不同的数据处理需求，同时也可以提高数据处理效率。 </li>
<li>支持高级数据操作<br>Redis提供了许多高级数据操作，如事务、发布&#x2F;订阅、Lua脚本、自动过期等。这些功能可以帮助用户更方便地进行数据处理和管理。 </li>
<li>可扩展性<br>Redis具有良好的可扩展性，它支持分布式存储和集群模式，用户可以根据需要将数据分布到多个节点上，以实现更高的性能和可靠性。 </li>
<li>简单易用<br>Redis的命令和API非常简单易用，用户可以轻松地学习和使用Redis。同时，Redis还提供了丰富的客户端库和工具，可以方便地集成到各种应用中。</li>
</ol>
<p>总的来说，Redis具有高性能、灵活性、可扩展性和简单易用等特点，适用于多种场景，如缓存、消息队列、计数器、排行榜等。</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Redis 是一种基于内存的数据存储系统，它支持多种数据类型的存储和操作。以下是 Redis 的基本数据类型：</p>
<ol>
<li>String 类型：字符串类型是 Redis 中最基本的数据类型，可以存储任意类型的字符串，包括数字、浮点数、二进制数据等。 </li>
<li>Hash 类型：哈希类型用于存储键值对，其中键和值都是字符串类型。哈希类型适用于存储对象类型的数据，如存储用户信息等。 </li>
<li>List 类型：列表类型用于存储一个有序的字符串列表，其中每个元素都可以是字符串类型。列表类型适用于存储有序的数据集合，如存储日志数据等。 </li>
<li>Set 类型：集合类型用于存储一个<strong>无序</strong>的字符串集合，其中每个元素都是唯一的字符串类型。集合类型适用于存储无序的数据集合，如存储用户标签等。 </li>
<li>Sorted Set 类型：有序集合类型用于存储一个<strong>有序</strong>的字符串集合，其中每个元素都有一个分数值，根据分数值进行排序。有序集合类型适用于存储按照分数排序的数据集合，如存储排行榜等。</li>
</ol>
<p>除了上述基本数据类型，Redis 还提供了一些高级数据结构，如 Bitmap、HyperLogLog、GeoHash 等，用于支持更复杂的数据存储和操作需求。</p>
<p>需要注意的是，Redis 是一种基于内存的数据存储系统，因此在存储大量数据时需要注意内存使用情况，避免因为内存不足而导致系统崩溃。同时，为了保证数据的可靠性，需要定期对数据进行备份和恢复操作。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>以下是一些常用的 String 类型的命令：</p>
<ol>
<li>SET key value：设置 key 的值为 value。</li>
<li>GET key：获取 key 的值。</li>
<li>INCR key：将 key 的值增加 1。</li>
<li>DECR key：将 key 的值减少 1。</li>
<li>APPEND key value：将 value 追加到 key 的值末尾。</li>
<li>STRLEN key：获取 key 的值的长度。</li>
<li>MSET key1 value1 key2 value2 …：同时设置多个 key 的值。</li>
<li>MGET key1 key2 …：同时获取多个 key 的值。</li>
<li>SETEX key seconds value：设置 key 的值为 value，并且设置 key 的过期时间为 seconds 秒。</li>
<li>GETSET key value：将 key 的值设置为 value，并返回 key 原来的值。</li>
</ol>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash 是 Redis 的一种基本数据类型，用于存储键值对，其中键和值都是字符串类型。以下是一些常用的 Hash 命令：</p>
<ol>
<li>HSET key field value：设置 key 中指定 field 的值为 value。 </li>
<li>HGET key field：获取 key 中指定 field 的值。 </li>
<li>HMSET key field1 value1 field2 value2 …：同时设置 key 中多个 field 的值。 </li>
<li>HMGET key field1 field2 …：同时获取 key 中多个 field 的值。 </li>
<li>HLEN key：获取 key 中 field 的数量。 </li>
<li>HDEL key field1 field2 …：删除 key 中指定的 field。 </li>
<li>HEXISTS key field：判断 key 中是否存在指定的 field。 </li>
<li>HKEYS key：获取 key 中所有的 field。 </li>
<li>HVALS key：获取 key 中所有的 value。 </li>
<li>HINCRBY key field increment：将 key 中指定的 field 的值增加 increment。</li>
</ol>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 是 Redis 的一种基本数据类型，用于存储一个有序的字符串列表，其中每个元素都可以是字符串类型。以下是一些常用的 List 命令：</p>
<ol>
<li>LPUSH key value1 value2 …：将一个或多个值插入到 key 的头部。 </li>
<li>RPUSH key value1 value2 …：将一个或多个值插入到 key 的尾部。 </li>
<li>LPOP key：移除并返回 key 的头部元素。 </li>
<li>RPOP key：移除并返回 key 的尾部元素。 </li>
<li>LINDEX key index：获取 key 中指定索引位置的元素。 </li>
<li>LLEN key：获取 key 中元素的数量。 </li>
<li>LRANGE key start stop：获取 key 中指定范围内的元素。 </li>
<li>LREM key count value：从 key 中移除指定数量的元素。 </li>
<li>LSET key index value：将 key 中指定索引位置的元素设置为 value。 </li>
<li>LTRIM key start stop：截取 key 中指定范围内的元素。</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是 Redis 的一种基本数据类型，用于存储一个<strong>无序</strong>的、<strong>不重复</strong>的字符串集合。以下是一些常用的 Set 命令：</p>
<ol>
<li>SADD key member1 member2 …：向 key 中添加一个或多个 member 元素，如果 member 已经存在于集合中，则不进行任何操作。 </li>
<li>SREM key member1 member2 …：从 key 中移除一个或多个 member 元素。 </li>
<li>SMEMBERS key：返回 key 中所有的元素。 </li>
<li>SISMEMBER key member：判断 member 是否存在于 key 中。 </li>
<li>SCARD key：返回 key 中元素的数量。 </li>
<li>SPOP key：随机移除并返回 key 中的一个元素。 </li>
<li>SRANDMEMBER key [count]：随机返回 key 中的一个或多个元素，如果 count 参数为正数，则返回的元素不重复，如果为负数，则返回的元素可能重复。 </li>
<li>SINTER key1 key2 …：返回多个集合的<strong>交集</strong>。 </li>
<li>SUNION key1 key2 …：返回多个集合的<strong>并集</strong>。 </li>
<li>SDIFF key1 key2 …：返回多个集合的<strong>差集</strong>。</li>
</ol>
<p>这些命令可以用于对 Redis 中的 Set 类型数据进行基本的存储和操作。除了这些基本命令，Redis 还提供了一些高级的 Set 命令，如 SINTERSTORE、SUNIONSTORE、SDIFFSTORE 等，可以根据具体的需求选择合适的命令进行操作。</p>
<p>需要注意的是，Set 类型是一个无序的数据结构，可以支持快速的插入、删除和判断元素是否存在的操作，但是在获取所有元素时需要进行扫描，效率较低。此外，当 Set 类型的键中存储的元素数量较多时，会影响 Redis 的性能和内存使用情况。因此，在使用 Set 类型时，应该根据具体的需求选择合适的命令进行操作，以及避免在 Set 类型的键中存储过多的元素。</p>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>Sorted Set 是 Redis 的一种基本数据类型，用于存储一个有序的、不重复的字符串集合，其中每个元素都有一个对应的分数，可以根据分数的大小进行排序。以下是一些常用的 Sorted Set 命令：</p>
<ol>
<li>ZADD key score1 member1 score2 member2 …：向 key 中添加一个或多个 member 元素，每个元素都有一个对应的分数 <strong>score</strong>。 </li>
<li>ZREM key member1 member2 …：从 key 中移除一个或多个 member 元素。 </li>
<li>ZRANGE key start stop [WITHSCORES]：返回 key 中指定范围内的元素，按照分数从小到大排序，如果指定了 WITHSCORES 参数，则同时返回元素的分数。 </li>
<li>ZREVRANGE key start stop [WITHSCORES]：返回 key 中指定范围内的元素，按照分数从大到小排序，如果指定了 WITHSCORES 参数，则同时返回元素的分数。 </li>
<li>ZSCORE key member：返回 member 在 key 中的分数。 </li>
<li>ZCARD key：返回 key 中元素的数量。 </li>
<li>ZCOUNT key min max：返回 key 中分数在指定范围内的元素数量。 </li>
<li>ZRANK key member：返回 member 在 key 中按照分数排序后的排名，排名从 0 开始。 </li>
<li>ZREVRANK key member：返回 member 在 key 中按照分数排序后的倒序排名，排名从 0 开始。 </li>
<li>ZINCRBY key increment member：将 member 在 key 中的分数增加 increment。</li>
</ol>
<p>这些命令可以用于对 Redis 中的 Sorted Set 类型数据进行基本的存储和操作。除了这些基本命令，Redis 还提供了一些高级的 Sorted Set 命令，如 ZINTERSTORE、ZUNIONSTORE、ZREMRANGEBYRANK、ZREMRANGEBYSCORE 等，可以根据具体的需求选择合适的命令进行操作。<br>需要注意的是，Sorted Set 类型是一个有序的数据结构，可以支持根据分数进行范围查找、排序和计算排名等操作，但是在获取所有元素时需要进行扫描，效率较低。此外，当 Sorted Set 类型的键中存储的元素数量较多时，会影响 Redis 的性能和内存使用情况。因此，在使用 Sorted Set 类型时，应该根据具体的需求选择合适的命令进行操作，以及避免在 Sorted Set 类型的键中存储过多的元素。</p>
<h1 id="共享Session（单点登录）"><a href="#共享Session（单点登录）" class="headerlink" title="共享Session（单点登录）"></a>共享Session（单点登录）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>共享session是指在多台服务器之间共享session数据。这样做的目的是为了支持<code>负载均衡</code>，即当多台服务器使用同一套网站代码时，用户请求被分发到不同的服务器上。这种情况下，用户第一次请求时，在一台服务器上生成了sessionid，但在其他服务器上也需要访问该session数据。<br>例如，如果一个用户在网站上登录了，他的登录信息会被存储在session中。如果该用户的下一个请求被分发到另一台服务器上，那么这台服务器也需要访问该用户的登录信息。因此，需要在多台服务器之间共享session数据。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679480448867-eddb1974-7a41-4a0b-8887-ca8c9ef8587a.png#averageHue=%23f6f4f4&clientId=ua6475701-a0dd-4&from=paste&height=503&id=u6872694b&name=image.png&originHeight=754&originWidth=1723&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=346019&status=done&style=none&taskId=u695756d8-dc4d-40ac-aabd-ba629eb843a&title=&width=1148.6666666666667#averageHue=%23f6f4f4&id=jXvcH&originHeight=754&originWidth=1723&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="设计key"><a href="#设计key" class="headerlink" title="设计key"></a>设计key</h3><p>随机生成token</p>
<h3 id="选取数据结构"><a href="#选取数据结构" class="headerlink" title="选取数据结构"></a>选取数据结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679480882862-adcc8755-03ce-46cd-a9bf-8f126905780f.png#averageHue=%23f2e9e5&clientId=ua6475701-a0dd-4&from=paste&height=443&id=u9db5000e&name=image.png&originHeight=664&originWidth=1019&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=192073&status=done&style=none&taskId=u6f68a962-b81c-4d36-b4d6-bb75f184333&title=&width=679.3333333333334#averageHue=%23f2e9e5&id=mJ8qb&originHeight=664&originWidth=1019&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>两种方案：</p>
<ol>
<li>先在程序中将对象进行JSON序列化，在以string类型写入</li>
<li>直接以hash数据结构写入🔥</li>
</ol>
<h3 id="具体流程（采用string）"><a href="#具体流程（采用string）" class="headerlink" title="具体流程（采用string）"></a>具体流程（采用string）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679481109556-9e7134c4-75be-4564-ba6b-e39c40b1864e.png#averageHue=%23f0ecec&clientId=ua6475701-a0dd-4&from=paste&height=603&id=u40a8c449&name=image.png&originHeight=904&originWidth=1726&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=451855&status=done&style=none&taskId=u003b9837-6127-4427-8491-f8a810e15d1&title=&width=1150.6666666666667#averageHue=%23f0ecec&id=K6VMK&originHeight=904&originWidth=1726&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<ul>
<li>存储session<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 将User对象转为HashMap存储</span></span><br><span class="line"><span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7存储</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 设置token有效期</span></span><br><span class="line">stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回token</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(token);</span><br></pre></td></tr></table></figure>
注意StringRedisTemplate要求类型是String，但是我们的UserDto里面有一个Long类型的id，所以需要先进行转换<br><strong>注意事项</strong>：</li>
</ul>
<ol>
<li>存入Redis的数据一定要设置过期时间</li>
<li>存入Redis的数据尽量精简和安全，比如用户信息脱敏</li>
<li><strong>已登录用户访问系统后，要刷新token过期时间（续期）。访问任何路径都要刷新token，不然时间到了会被强制退出</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679482336011-04410982-ea2b-46c8-a76e-991ecec2e229.png#averageHue=%23e9d5d2&clientId=ua6475701-a0dd-4&from=paste&height=357&id=uf30981b2&name=image.png&originHeight=535&originWidth=1046&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=121501&status=done&style=none&taskId=u72935797-95ba-4740-9cb2-1ab8b2bd387&title=&width=697.3333333333334#averageHue=%23e9d5d2&id=Ouo4R&originHeight=535&originWidth=1046&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><blockquote>
<p>get:拦截器是手动创建的，不是SpringBoot构建的，不会帮我们注入依赖</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679482546551-3a6efe2c-5c8b-4a3e-8aea-0d5340c9bb6d.png#averageHue=%23faf9f6&clientId=ua6475701-a0dd-4&from=paste&height=288&id=ueaf4171a&name=image.png&originHeight=432&originWidth=1617&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=116557&status=done&style=none&taskId=u32dc2a1a-a96b-44b2-bccc-11993ba52f1&title=&width=1078#averageHue=%23faf9f6&id=VAYYz&originHeight=432&originWidth=1617&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。<br><strong>UserHolder是一个ThreadLocal对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//这里并不是自动装配，因为RefreshTokenInterceptor是我们手动在WebConfig里new出来的</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 如果token是空，直接放行，交给LoginInterceptor处理</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        <span class="comment">//3. 基于token获取Redis中的用户数据</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">//4. 判断用户是否存在，不存在，也放行，交给LoginInterceptor</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 将查询到的Hash数据转化为UserDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//6. 将用户信息保存到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">//7. 刷新tokenTTL，这里的存活时间根据需要自己设置，这里的常量值我改为了30分钟</span></span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不存在则拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//到了这里才能自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RefreshTokenInterceptor是我们手动new出来的</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意toke拦截器要在登录拦截器前执行，一直方法是吧token拦截器写在前面，一种是order，数字越小，顺序越早</p>
</blockquote>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>缓存(Cache)就是数据交换的缓冲区，俗称的缓存就是缓冲区内的数据，一般从数据库中获取，存储于本地<br>缓存是一种用于提高系统性能的技术。它可以通过将数据存储在内存中，从而减少对磁盘或网络的访问，来提高数据访问速度。这样，当需要访问相同的数据时，可以直接从缓存中获取，而不需要再次访问磁盘或网络¹。</p>
<p>缓存的主要优点是可以实现高性能和高并发。它可以减少对数据库或其他外部资源的访问，从而减少系统的响应时间。此外，缓存还可以减少服务器的负载，提高系统的可扩展性¹。</p>
<p>但是，使用缓存也有一些潜在的风险。如果缓存中的数据过期或不一致，可能会导致系统出现错误。因此，在使用缓存时，需要注意数据的有效性和一致性。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol>
<li>暂无缓存，从数据库中读，然后设置（更新）缓存</li>
<li>一有缓存，直接读缓存</li>
</ol>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<ul>
<li><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</li>
<li><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</li>
<li><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679487448289-73fae28e-fb31-4c4e-81b2-46614b2e5949.png#averageHue=%23e1d0d0&clientId=ua6475701-a0dd-4&from=paste&height=489&id=u0f93aca8&name=image.png&originHeight=734&originWidth=1613&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=307125&status=done&style=none&taskId=ue2d34ff4-0671-45a6-adc9-b05d113cd46&title=&width=1075.3333333333333#averageHue=%23e1d0d0&id=dKzOA&originHeight=734&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>主动更新缓存是指在数据发生变化时，主动更新缓存中的数据，以保证缓存中的数据与数据库中的数据一致。常见的主动更新缓存的方式有以下几种:</p>
<ol>
<li><strong>读写操作同时进行</strong>: 在执行写操作时，同时更新缓存中的数据。这种方式可以保证缓存中的数据与数据库中的数据一致，但可能会增加写操作的延迟。</li>
<li><strong>定时更新</strong>: 定时从数据库中读取数据，更新缓存中的数据。这种方式可以减少写操作的延迟，但可能会导致缓存中的数据与数据库中的数据不一致。</li>
<li><strong>异步更新</strong>: 在执行写操作后，异步更新缓存中的数据。这种方式可以减少写操作的延迟，并且可以保证缓存中的数据与数据库中的数据一致，但需要额外的线程来执行异步更新。</li>
</ol>
<p>选择删除缓存还是更新缓存？<br>建议删除缓存，等待下次查询自动设置缓存，做到随用随取，可以避免每次更新数据库后都更新缓存的无效操作</p>
<p>先删除缓存还是先操作数据库？</p>
<ol>
<li>更新缓存：每次更新数据库都要更新缓存–写多读少时会导致多次无效写操作</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1682081700363-f5e5f90b-91d6-4ad6-a300-e615bd26d03b.png#averageHue=%23c8f8f8&clientId=uf8948dec-d357-4&from=paste&height=747&id=ud617427c&originHeight=1120&originWidth=1213&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=460605&status=done&style=none&taskId=u88ad9f45-166f-4836-9af4-22c4a98581b&title=&width=808.6666666666666" alt="image.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1682081680894-7a9a574b-4be8-4da0-8297-096f5834522a.png#averageHue=%23c9f8f8&clientId=uf8948dec-d357-4&from=paste&height=733&id=u6c1124f0&originHeight=1099&originWidth=1263&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=481203&status=done&style=none&taskId=ue8eeb0a8-7a6c-477b-9269-2ebb0cb197e&title=&width=842" alt="image.png"><br>在更新数据时，通常建议先操作数据库，然后再删除缓存。这样做的原因是为了保证数据的一致性。<br>如果先删除缓存，那么在删除缓存和更新数据库之间，可能会有一段时间缓存中没有数据。这种情况下，如果有请求访问该数据，那么需要从数据库中读取数据。但是，如果此时数据库中的数据还没有更新，那么请求会读取到旧的数据。<br>如果先操作数据库，然后再删除缓存，那么可以避免上述问题。即使在更新数据库和删除缓存之间有请求访问该数据，也会从缓存中读取到旧的数据。当缓存被删除后，下一个请求会从数据库中读取到新的数据。<br>因此，在更新数据时，通常建议先操作数据库，然后再删除缓存。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>缓存穿透、缓存击穿和缓存雪崩都是缓存中的常见问题，它们之间的区别如下：</p>
<ol>
<li>缓存穿透</li>
</ol>
<p>当请求的数据在缓存中<code>不存在</code>，且数据库中也<code>不存在</code>该数据时，就会发生缓存穿透。这种情况下，每次请求都需要从数据库中查询数据，导致数据库压力过大，可能会引起雪崩效应。<br>解决方法：可以在缓存中设置一个<code>空值</code>或者布尔值，表示该数据不存在，这样下次请求时就会直接返回空值，避免了对数据库的查询。</p>
<ol start="2">
<li>缓存击穿</li>
</ol>
<p>当一个热点数据过期或者被删除，而此时有大量的请求访问这个数据时，就会发生缓存击穿。这种情况下，大量的请求都会访问数据库，导致数据库压力过大，可能会引起雪崩效应。<br>解决方法：可以在缓存中设置一个短暂的过期时间，当缓存过期时，先返回<code>旧值</code>，并异步更新缓存，避免了对数据库的大量查询。</p>
<ol start="3">
<li>缓存雪崩</li>
</ol>
<p>当缓存中的大量数据同时过期失效，导致大量请求都落到数据库上时，就会发生缓存雪崩。这种情况下，数据库的压力会剧增，可能会导致数据库宕机或崩溃。<br>解决方法：可以在缓存中设置不同的过期时间，避免所有数据同时失效。另外，可以采用多级缓存、热点数据预加载等方式来避免缓存雪崩。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。<br>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象 <ul>
<li>优点：实现简单，维护方便</li>
<li>缺点： <ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤 <ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点： <ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了<br><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，<br>假设布隆过滤器判断这个数据不存在，则直接返回<br>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679538039906-ff893fe0-89fb-42af-95fa-ee8280ce19fd.png#averageHue=%23f8f6f5&clientId=u13b1c3e4-cb39-4&from=paste&height=549&id=ue33c9b2a&name=image.png&originHeight=823&originWidth=1470&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=263421&status=done&style=none&taskId=ued9c7128-e471-4561-b53c-1a47059694c&title=&width=980#averageHue=%23f8f6f5&id=FudEK&originHeight=823&originWidth=1470&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>预防做法：</p>
<ol>
<li>增强对请求数据的校验</li>
<li>增强对数据格式的控制</li>
<li>增强id复杂度，避免被猜测id规律（可以采用雪花算法）</li>
<li>增强用户权限校验</li>
<li>限流</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679538112846-963b5504-7434-4c90-87f2-3c9e7baba3b1.png#averageHue=%23eeebeb&clientId=u13b1c3e4-cb39-4&from=paste&height=472&id=u68222c95&name=image.png&originHeight=708&originWidth=1676&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=365890&status=done&style=none&taskId=ucf0c4b03-9058-4b40-9275-c076e9660cc&title=&width=1117.3333333333333#averageHue=%23eeebeb&id=L1vgz&originHeight=708&originWidth=1676&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果查询到的是空字符串，则说明是我们缓存的空数据</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则去数据库中查</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//查不到，则将空字符串写入Redis</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的常量值是2分钟</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul>
<li>缓存雪崩是指在同一时间段，<code>大量缓存的key同时失效</code>，或者<code>Redis服务宕机</code>，导致大量请求到达数据库，带来巨大压力</li>
<li>解决方案 <ul>
<li>给不同的Key的TTL添加随机值，让其在不同时间段分批失效</li>
<li>利用Redis集群提高服务的可用性（使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。 ）</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存（浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库）</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul>
<li>缓存击穿也叫<code>热点Key</code>问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击</li>
<li>举个不太恰当的例子：一件秒杀中的商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿</li>
<li>逻辑分析：假设线程1在查询缓存之后未命中，本来应该去查询数据库，重建缓存数据，完成这些之后，其他线程也就能从缓存中加载这些数据了。但是在线程1还未执行完毕时，又进来了线程2、3、4同时来访问当前方法，那么这些线程都不能从缓存中查询到数据，那么他们就会在同一时刻访问数据库，执行SQL语句查询，对数据库访问压力过大</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681644333844-a9e5cafb-f3a3-484b-897d-dd824dd1ae56.png#averageHue=%23f3f2eb&clientId=u58a9a4fb-4925-4&from=paste&height=242&id=uffb2972d&originHeight=363&originWidth=616&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=100557&status=done&style=none&taskId=uec3e7ddc-1c40-47b0-919c-eb6ef61e228&title=&width=410.6666666666667" alt="image.png"></p>
<ul>
<li>常见的解决方案有两种 <ol>
<li><strong>互斥锁</strong>：只有一个线程复制缓存重建，其余线程拿不到锁，就等着</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679543412026-b1e927ec-b533-4d63-aac7-aca4447a09e7.png#averageHue=%23ebe9e8&clientId=u1ca47393-cf9e-4&from=paste&id=u1246c27a&name=image.png&originHeight=850&originWidth=655&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=270192&status=done&style=none&taskId=ucf3a57ca-cd09-4be5-84d5-8b200a3d2ca&title=#averageHue=%23ebe9e8&id=ltdNe&originHeight=850&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<ol start="2">
<li><strong>逻辑过期：</strong>key设置为永不过期，在value中添加其它字段记录过期时间，业务中根据过期时间判断缓存是否有效；如果缓存已经过去，只有一个线程能抢到锁，开启独立线程去更显缓存，然后立即返回过期数据；其它抢不到锁的线程也立即返回过期数据，不用等锁释放</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679543465399-9545689e-2892-457a-9b33-d7565a9c85fa.png#averageHue=%23e8e4e3&clientId=u1ca47393-cf9e-4&from=paste&id=u9732ff99&name=image.png&originHeight=757&originWidth=871&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=301880&status=done&style=none&taskId=ua37f95c8-2395-4d6d-994f-b7d6c43d6be&title=#averageHue=%23e8e4e3&id=I5wEH&originHeight=757&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>方案优缺点对比<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681644716598-c59d6dc7-e717-4c8a-9e74-74029127550c.png#averageHue=%23f6f5f3&clientId=u58a9a4fb-4925-4&from=paste&height=264&id=u61bbc144&originHeight=396&originWidth=988&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=101831&status=done&style=none&taskId=uec023c45-9c34-411e-b2b1-cd4a443b723&title=&width=658.6666666666666" alt="image.png"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679543534010-f84388df-7ad3-4258-933e-8bebdbf75aed.png#averageHue=%23faf5f5&clientId=u1ca47393-cf9e-4&from=paste&id=u2536802d&name=image.png&originHeight=749&originWidth=1076&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=279114&status=done&style=none&taskId=u37a34493-9b09-4c3a-837a-cbd030430b8&title=#averageHue=%23faf5f5&from=url&id=wSBCU&originHeight=749&originWidth=1076&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<ul>
<li>核心：利用redis的setnx方法来表示获取锁，如果redis没有这个key，则插入成功，返回1，如果已经存在这个key，则插入失败，返回0。在StringRedisTemplate中返回true&#x2F;false，我们可以根据返回值来判断是否有线程成功获取到了锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//避免返回值为null，我们这里使用了BooleanUtil工具类</span></span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//否则去数据库中查</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">        <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(LOCK_SHOP_KEY + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><ul>
<li>需求：根据id查询商铺的业务，基于<code>逻辑过期</code>方式来解决缓存击穿问题</li>
<li>思路分析：当用户开始查询redis时，判断是否命中<ul>
<li>如果没有命中则直接返回空数据，不查询数据库</li>
<li>如果命中，则将value取出，判断value中的过期时间是否满足<ul>
<li>如果没有过期，则直接返回redis中的数据</li>
<li>如果过期，则在开启独立线程后，直接返回之前的数据，独立线程去重构数据，重构完成后再释放互斥锁<a target="_blank" rel="noopener" href="https://pic1.imgdb.cn/item/6355073c16f2c2beb1375808.jpg"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679641139130-cbba7b89-062d-408c-8f2f-b0fed1a31915.png#averageHue=%23f8f3f3&clientId=u93ccb212-de26-4&from=paste&id=u59b44c08&name=image.png&originHeight=629&originWidth=1229&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=272539&status=done&style=none&taskId=u0cf0d253-426c-4518-8050-f765cc93ede&title=#averageHue=%23f8f3f3&from=url&id=SOtG0&originHeight=629&originWidth=1229&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></a></li>
</ul>
</li>
</ul>
</li>
<li>封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么新建一个类包含原有的数据和过期时间</li>
</ul>
<p>这里我们选择新建一个实体类，包含原有数据(用万能的Object)和过期时间，这样对原有的代码没有侵入性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expirSeconds)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expirSeconds));</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h2><ul>
<li>基于StringRedisTemplate封装一个缓存工具类</li>
<li>方法一：将任意Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicExpire</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//由于需要设置逻辑过期时间，所以我们需要用到RedisData</span></span><br><span class="line">    RedisData&lt;Object&gt; redisData = <span class="keyword">new</span> <span class="title class_">RedisData</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//redisData的data就是传进来的value对象</span></span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    <span class="comment">//逻辑过期时间就是当前时间加上传进来的参数时间，用TimeUnit可以将时间转为秒，随后与当前时间相加</span></span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">    <span class="comment">//由于是逻辑过期，所以这里不需要设置过期时间，只存一下key和value就好了，同时注意value是ridisData类型</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题<br>原来的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithPassThrough</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shopjson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则去数据库中查</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>改为通用方法，那么返回值就需要进行修改，不能返回Shop了，那我们直接设置一个泛型，同时ID的类型，也不一定都是Long类型，所以我们也采用泛型。</li>
<li>Key的前缀也会随着业务需求的不同而修改，所以参数列表里还需要加入Key的前缀</li>
<li>通过id去数据库查询的具体业务需求我们也不清楚，所以我们也要在参数列表中加入一个查询数据库逻辑的函数</li>
<li>最后再加上设置TTL需要的两个参数</li>
<li>那么综上所述，我们的参数列表需要 <ol>
<li>key前缀</li>
<li>id（类型泛型）</li>
<li>返回值类型（泛型）</li>
<li>查询的函数</li>
<li>TTL需要的两个参数</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为R类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则去数据库中查，查询逻辑用我们参数中注入的函数</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">    <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(r);</span><br><span class="line">    <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">    <span class="built_in">this</span>.set(key, jsonStr, time, timeUnit);</span><br><span class="line">    <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.</span><br><span class="line">            queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 从redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2. 如果未命中，则返回空</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 命中，将json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//4. 判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">//5. 未过期，直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 过期，尝试获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">//7. 获取到了锁</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">//8. 开启独立线程</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">R</span> <span class="variable">tmp</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                <span class="built_in">this</span>.setWithLogicExpire(key, tmp, time, timeUnit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//9. 直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//10. 未获取到锁，直接返回商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法5：根据指定的Key查询缓存，并反序列化为指定类型，需要利用互斥锁解决缓存击穿问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//否则去数据库中查</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, timeUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        r = dbFallback.apply(id);</span><br><span class="line">        <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, timeUnit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.RedisData;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicExpire</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        RedisData&lt;Object&gt; redisData = <span class="keyword">new</span> <span class="title class_">RedisData</span>&lt;&gt;();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//如果不为空（查询到了），则转为R类型直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则去数据库中查，查询逻辑用我们参数中注入的函数</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(r);</span><br><span class="line">        <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, jsonStr, time, timeUnit);</span><br><span class="line">        <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 从redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2. 如果未命中，则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 命中，将json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//4. 判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//5. 未过期，直接返回商铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 过期，尝试获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">//7. 获取到了锁</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//8. 开启独立线程</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">R</span> <span class="variable">tmp</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicExpire(key, tmp, time, timeUnit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//9. 直接返回商铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//10. 未获取到锁，直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//否则去数据库中查</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, timeUnit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分布式全局id生成"><a href="#分布式全局id生成" class="headerlink" title="分布式全局id生成"></a>分布式全局id生成</h1><ul>
<li>如果使用数据库自增ID就会存在一些问题 <ol>
<li>id规律性太明显</li>
<li>受单表数据量的限制</li>
</ol>
</li>
<li>全局ID生成器是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足一下特性 <ul>
<li>唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性</li>
<li>安全性</li>
</ul>
</li>
</ul>
<h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681645376670-917c4244-2986-4587-8bb8-8b3b8ce9f1ad.png#averageHue=%23f7f6f6&clientId=u58a9a4fb-4925-4&from=paste&height=300&id=ue088a6be&originHeight=450&originWidth=970&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=142203&status=done&style=none&taskId=u93e5b036-dfe7-4b8a-ae16-0521deae911&title=&width=646.6666666666666" alt="image.png"></p>
<ul>
<li>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息</li>
<li>ID组成部分 <ul>
<li>符号位：1bit，永远为0</li>
<li>时间戳：31bit，以秒为单位，可以使用69年（2^31秒约等于69年）</li>
<li>序列号：32bit，秒内的计数器，支持每秒传输2^32个不同ID<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//设置起始时间，我这里设定的是2022.01.01 00:00:00</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">//序列号长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> currentSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2. 生成序列号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;inc:&quot;</span>+keyPrefix+<span class="string">&quot;:&quot;</span>+date);</span><br><span class="line">        <span class="comment">//3. 拼接并返回，简单位运算</span></span><br><span class="line">        <span class="keyword">return</span> timeStamp &lt;&lt; COUNT_BIT | count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>stringRedisTemplate.opsForValue().increment(“inc:”+keyPrefix+”:”+date)是Redis中的一个原子操作，用于获取指定key的值并将其自增1。具体解释如下：</p>
<ul>
<li>stringRedisTemplate是一个StringRedisTemplate类型的对象，用于操作Redis中的字符串类型数据。</li>
<li>opsForValue()方法返回一个ValueOperations类型的对象，用于操作Redis中的字符串类型数据。</li>
<li>increment(key)方法用于获取指定key的值并将其自增1。如果key不存在，则会先将其初始化为0，然后再执行自增操作。</li>
</ul>
</blockquote>
在这段代码中，”inc:”+keyPrefix+”:”+date是一个Redis的key，用于存储每天的序列号。其中，keyPrefix是一个前缀，用于区分不同种类的ID，date是当前日期（格式为”yyyy:MM:dd”），用于按天存储序列号。每次调用increment()方法时，会自动获取当天的序列号并将其加1，然后返回加1后的值。这样可以保证每天的序列号是唯一的，且是连续的。</li>
</ul>
</li>
</ul>
<h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><p>核心流程：判断日期（是否开启结束活动）和库存、扣减库存、创建订单<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679646991653-5c59b606-c702-4ca0-a977-996eca0aa82f.png#averageHue=%23faf8f8&clientId=u93ccb212-de26-4&from=paste&height=499&id=u37552472&name=image.png&originHeight=749&originWidth=1410&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=189490&status=done&style=none&taskId=ubbe33f63-c3d6-431d-afc6-2cc1eee5cba&title=&width=940#averageHue=%23faf8f8&id=OoSSt&originHeight=749&originWidth=1410&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647202344-e58f37f3-5d6f-42fb-9087-162a7f3599a3.png#averageHue=%23fcfcfb&clientId=u93ccb212-de26-4&from=paste&height=260&id=fPoGf&name=image.png&originHeight=390&originWidth=676&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56981&status=done&style=none&taskId=ud9fea0a2-6b19-428e-a9e6-26e3dc7f29d&title=&width=450.6666666666667#averageHue=%23fcfcfb&id=JWaHy&originHeight=390&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647229131-0b8f954f-cd8b-4132-8ec9-13514f6591fe.png#averageHue=%23f2f2f1&clientId=u93ccb212-de26-4&from=paste&height=559&id=ub3f80388&name=image.png&originHeight=839&originWidth=1667&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=169407&status=done&style=none&taskId=u8c78f38d-5980-4261-bf58-ea319ddc187&title=&width=1111.3333333333333#averageHue=%23f2f2f1&id=LRYY6&originHeight=839&originWidth=1667&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647250229-4ea29080-91de-4ed1-abbf-38a7a2883996.png#averageHue=%23f5f0ef&clientId=u93ccb212-de26-4&from=paste&height=394&id=ua7a74957&name=image.png&originHeight=591&originWidth=1423&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=289141&status=done&style=none&taskId=u5dc24863-8d82-4511-8895-e2f085ac62f&title=&width=948.6666666666666#averageHue=%23f5f0ef&id=vsB9v&originHeight=591&originWidth=1423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br><strong>悲观锁：</strong><br>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等<br><strong>乐观锁：</strong>假定并发不一定会冲突，所以不加锁，而是通过判断数据是否在查出来之后被其它线程修改过，来决定是否运行操作</p>
<p>乐观锁主要有版本号法和CAS两种实现方式</p>
<ul>
<li>版本号法：给数据增加一个版本号字段，每次修改操作版本号+1，就可以通过版本号来片段是否有被修改</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681728499601-3cd30a77-3d47-4dbc-9655-6bb84cab5cad.png#averageHue=%23f9f8f8&clientId=uc6d03285-7526-4&from=paste&height=296&id=uda9d781a&originHeight=444&originWidth=988&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=142224&status=done&style=none&taskId=u082a9274-8b55-401b-a477-ceaa86a7715&title=&width=658.6666666666666" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">    .eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure>

<ul>
<li>CAS是对乐观锁的简化，即直接用一个每次都会查询和更新的字段来代替版本号，比如库存stock字段</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681728571837-846cf1f8-e33f-4d01-b9ee-d80fda839660.png#averageHue=%23fafafa&clientId=uc6d03285-7526-4&from=paste&height=291&id=ud413dcfe&originHeight=436&originWidth=980&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=118694&status=done&style=none&taskId=u3651f5f1-84c5-4127-9cac-89e7b7db72b&title=&width=653.3333333333334" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update(); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>优点：性能好</li>
<li>缺点：存在成功率低的问题（很多人查到的版本号是一样的，结果只能有一个人操作成功），使用分段锁来改进。比如将100个库存分为10分，大家分别抢这10分</li>
</ul>
</blockquote>
<p>对于以上场景，其实不用判断stock是否变化，直接判断stock&gt;0.从而保证成功率</p>
<h1 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h1><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单<br><strong>现在的问题在于：</strong><br>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647698772-0be59b9c-7fa9-4124-a3bc-30114e7bde16.png#averageHue=%23faf8f8&clientId=u93ccb212-de26-4&from=paste&height=322&id=u87a39ba7&name=image.png&originHeight=483&originWidth=1012&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=113348&status=done&style=none&taskId=ub57286b9-90f2-4545-bdc8-06f0316af7d&title=&width=674.6666666666666#averageHue=%23faf8f8&id=gQYKJ&originHeight=483&originWidth=1012&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>因为订单是创建数据，无法使用乐观锁，使用悲观锁实现</p>
<h2 id="单机实现"><a href="#单机实现" class="headerlink" title="单机实现"></a>单机实现</h2><p>单机部署后端服务器时，可以使用java自带的<code>Synchronized</code>关键字作为悲观锁<br>注意事项：</p>
<ol>
<li><p>Synchronized锁的范围不能太大，不能锁住整个对象，会严重影响性能。因为是一人一单，所以可以每个用户一把独立的锁</p>
</li>
<li><p>注意，锁住对象时要用<code>toString.intern</code>，保证同id的用户始终是同一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;voucherId&quot;</span>, voucherId).eq(<span class="string">&quot;userId&quot;</span>, userId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;你已经抢过优惠券了哦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//6.1 设置订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">//6.2 设置用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//6.3 设置代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line">        <span class="comment">//7. 将订单数据保存到表中</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="comment">//8. 返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到这里，锁已经被释放了，但是可能当前事务还未提交，如果此时有线程进来，不能确保事务不出问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>userId.toString().intern()是Java中的字符串常量池（String Pool）机制，用于将字符串对象放入常量池中，并返回常量池中的引用。具体解释如下：</p>
<ul>
<li>userId是一个Long类型的对象，调用toString()方法可以将其转换为字符串类型。</li>
<li>intern()方法是String类中的一个方法，用于将字符串对象放入常量池中，并返回常量池中的引用。</li>
<li>当调用intern()方法时，JVM首先检查常量池中是否已经存在相同值的字符串对象，如果存在，则返回常量池中的引用；如果不存在，则将该字符串对象放入常量池中，然后返回常量池中的引用。</li>
<li>要注意即使是toString（）每次创建都都是一个新对象，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</li>
</ul>
</blockquote>
</li>
<li><p>Synchronized必须在使用<code>@Transactional</code>注解的方法外层使用，因为<code>@Transactional</code>是使用动态代理，在方法执行结束后才提交事务。如果把Synchronized写在事务方法内，提交事务前锁已经释放，但此时数据还未更新，其它线程依然能获取锁并顺利执行</p>
</li>
<li><p>调用事务方法时不能用this对象，因为@Transactional注解实际上是调用Spring生成的代理对象的方法，如果调用this对象的方法会无法使用事务功能，所以要获取代理对象并调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;voucherId&quot;</span>, voucherId).eq(<span class="string">&quot;userId&quot;</span>, userId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;你已经抢过优惠券了哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1 设置订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">//6.2 设置用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//6.3 设置代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(id);</span><br><span class="line">    <span class="comment">//7. 将订单数据保存到表中</span></span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="comment">//8. 返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h2><p>Synchronized关键字只对单个JVM有效，多机部署时还是可能会同时有多个不同JVM的线程访问已加锁的方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679654809416-a086161e-8482-4942-97ce-e6fb2f4ea697.png#averageHue=%23eeebea&clientId=u93ccb212-de26-4&from=paste&height=502&id=u64fa1957&name=image.png&originHeight=753&originWidth=1708&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=355271&status=done&style=none&taskId=u79aa1e21-6d1a-4647-a2dd-1057e9a8aeb&title=&width=1138.6666666666667#averageHue=%23eeebea&id=gymaM&originHeight=753&originWidth=1708&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>因此，我们不能把锁存储到单个服务器上，而是应该使用一个集中的存储来管理锁，所有的进程都能读到他，这就需要分布式锁</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul>
<li>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</li>
<li>分布式锁的两个基本特征：<ul>
<li>多进程（线程）可见（读写）</li>
<li>互斥</li>
</ul>
</li>
<li>还应具备的特征<ul>
<li>高可用：不能挂机</li>
<li>高性能：读写要快</li>
<li>安全性：不能出现死锁</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679654873984-7edb8dfc-bd42-4e89-bade-1b22d4111a25.png#averageHue=%23f2f1f1&clientId=u93ccb212-de26-4&from=paste&height=541&id=ude651043&name=image.png&originHeight=812&originWidth=1591&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=358347&status=done&style=none&taskId=u2ee91661-0d92-4c29-8dc0-56ef3d5b2af&title=&width=1060.6666666666667#averageHue=%23f2f1f1&id=WAxUQ&originHeight=812&originWidth=1591&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679654888124-ca0a7120-a8fe-41f4-8ccb-6efc145a2134.png#averageHue=%23d6c0bf&clientId=u93ccb212-de26-4&from=paste&height=403&id=u652eccc7&name=image.png&originHeight=604&originWidth=1685&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=203873&status=done&style=none&taskId=ue89bcda7-7fda-4cfc-ac1b-b4f3201ddd9&title=&width=1123.3333333333333#averageHue=%23d6c0bf&id=FhCMD&originHeight=604&originWidth=1685&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li>获取锁（setnx）： <ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
</ul>
<p>注意事项：</p>
<ol>
<li>为了防止setnx后就宕机了导致lock永久存在，必须私用set [key] ex nx的原子命令，保证每个lock都有过期时间</li>
</ol>
<ul>
<li>释放锁： <ul>
<li>主动释放：业务执行完后删除key，注意需要把锁释放的逻辑放到finally里保证一定执行</li>
<li>超时释放：获取锁时添加一个超时时间<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="comment">//锁的前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//这里不需要@Autowired，因为该对象是我们使用构造函数手动new出来的</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//自动拆箱可能会出现null，这样写更稳妥</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//通过DEL来删除锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">// 创建锁对象</span></span><br><span class="line"><span class="type">SimpleRedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line"><span class="comment">// 获取锁对象</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock(<span class="number">120</span>);</span><br><span class="line"><span class="comment">// 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span></span><br><span class="line"><span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许抢多张优惠券&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    redisLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol>
<li><p>注意这边使用代理要添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类上加注解 @EnableAspectJAutoProxy(exposeProxy &#x3D; true)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="分布式锁误删情况"><a href="#分布式锁误删情况" class="headerlink" title="分布式锁误删情况"></a>分布式锁误删情况</h3><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p>逻辑说明</p>
<ul>
<li>持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放</li>
<li>此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到</li>
<li>但是现在线程1阻塞完了，继续往下执行，要开始释放锁了</li>
<li>那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681730800881-831ff771-8996-4614-a0a4-94bb2061c416.png#averageHue=%23f9f9f8&clientId=uc6d03285-7526-4&from=paste&height=279&id=u4a0557b9&originHeight=418&originWidth=985&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=120152&status=done&style=none&taskId=u0451b92c-d775-40c2-8334-950811ed9db&title=&width=656.6666666666666" alt="image.png"><br>解决方案</p>
<ul>
<li>解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的（获取锁的时候在value中存入[本机标识+线程id]），如果不属于自己，则不进行删除操作。</li>
<li>假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁</li>
</ul>
<p>注意：不能只在value中存入线程id，因为多个机器的线程id可能是一样的，任然肯会出现误删</p>
<h4 id="情况2-原子性问题"><a href="#情况2-原子性问题" class="headerlink" title="情况2-原子性问题"></a>情况2-原子性问题</h4><p>假设线程A释放锁时已经判断了是自己的锁，但在这时候，线程A卡住了，锁超时释放了，线程B拿到了锁并执行业务，这时，线程A醒了，释放了B的锁<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679656285059-d901e586-9c7c-4a4e-88d9-56c886288015.png#averageHue=%23fbfafa&clientId=u93ccb212-de26-4&from=paste&height=547&id=ubb79267f&name=image.png&originHeight=820&originWidth=1723&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=215685&status=done&style=none&taskId=u14d6f930-1bf0-4266-8f07-1a28a995c70&title=&width=1148.6666666666667#averageHue=%23fbfafa&id=CwWHM&originHeight=820&originWidth=1723&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<p>解决方案<br>问题的本质是判断锁和删除锁是两个动作，不具备原子性，可以使用Redis Lua脚本，将多个Redis命令放到一个脚本中，整个脚本<br><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679656633823-cb5ca03d-176f-4621-9c1a-d330f01cef0c.png#averageHue=%23c2c7b9&clientId=u93ccb212-de26-4&from=paste&height=536&id=ue7fef514&name=image.png&originHeight=804&originWidth=1753&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=561968&status=done&style=none&taskId=ue4d1ca6c-7844-4512-a9cd-eea1205383c&title=&width=1168.6666666666667#averageHue=%23c2c7b9&id=dJopT&originHeight=804&originWidth=1753&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>放在Resources目录下</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里的KEYS[1]就是传入锁的key</span></span><br><span class="line"><span class="comment">-- 这里的ARGV[1]就是线程标识</span></span><br><span class="line"><span class="comment">-- 比较锁中 的线程标识与线程标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致则释放锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在RedisTemplate中，可以利用execute方法去执行lua脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T <span class="built_in">execute</span>(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.scriptExecutor.<span class="built_in">execute</span>(script, keys, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                                Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">                                ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>利用SET NX EX获取锁，并设置过期时间，保存线程标识</li>
<li>释放锁时先判断线程标识是否与自己一致，一致则删除所 <ul>
<li>特性 <ul>
<li>利用SET NX满足互斥性</li>
<li>利用SET EX保证故障时依然能释放锁，避免死锁，提高安全性</li>
<li>利用Redis集群保证高可用和高并发特性</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="分布式锁-Redisson"></a>分布式锁-Redisson</h1><h2 id="分布式锁-redission功能介绍"><a href="#分布式锁-redission功能介绍" class="headerlink" title="分布式锁-redission功能介绍"></a>分布式锁-redission功能介绍</h2><p>基于setnx实现的分布式锁存在下面的问题：</p>
<ul>
<li><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁。</li>
<li><strong>不可重试</strong>：是指目前的分布式只能尝试一次，合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</li>
<li><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</li>
<li><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕了，就会出现死锁问题。</li>
</ul>
<p>那么什么是Redission呢<br>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。<br>官网：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a><br>中文文档：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95</a></p>
<ul>
<li>Redis提供了分布式锁的多种多样功能 <ol>
<li>可重入锁(Reentrant Lock)</li>
<li>公平锁(Fair Lock)</li>
<li>联锁(MultiLock)</li>
<li>红锁(RedLock)</li>
<li>读写锁(ReadWriteLock)</li>
<li>信号量(Semaphore)</li>
<li>可过期性信号量(PermitExpirableSemaphore)</li>
<li>闭锁(CountDownLatch)</li>
</ol>
</li>
</ul>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol>
<li><p>导入依赖</p>
</li>
<li><p>配置Redisson客户端，在config包下新建<code>RedissonConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">            .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改之前的代码</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//1. 查询优惠券</span></span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    <span class="comment">//2. 判断秒杀时间是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀还未开始，请耐心等待&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 判断秒杀时间是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许抢多张优惠券&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><blockquote>
<p>可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。<br>与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。可重入锁的工作原理很简单，就是用一个计数器来记录锁被获取的次数，获取锁一次计数器+1，释放锁一次计数器-1，当计数器为0时，表示锁可用。<br>不可重入锁也叫自旋锁。</p>
</blockquote>
<p>可重入锁的实现原理是基于计数器的，每次获取锁时，计数器自增，每次释放锁时，计数器自减，从而实现了线程间的同步和互斥。具体地，当线程持有锁时，计数器加1；当线程释放锁时，计数器减1。当计数器减至0时，锁被释放，此时线程可以继续执行。这种同步机制可以有效地避免死锁等问题，提高程序的并发性和可靠性。</p>
<ul>
<li>在Lock锁中，他是借助于等曾的一个voaltile的一个state变量来记录重入的状态的 <ul>
<li>如果当前没有人持有这把锁，那么state &#x3D; 0</li>
<li>如果有人持有这把锁，那么state &#x3D; 1 <ul>
<li>如果持有者把锁的人再次持有这把锁，那么state会+1</li>
</ul>
</li>
<li>如果对于synchronize而言，他在c语言代码中会有一个count</li>
<li>原理与state类似，也是重入一次就+1，释放一次就-1，直至减到0，表示这把锁没有被人持有</li>
</ul>
</li>
<li>在redisson中，我们也支持可重入锁 <ul>
<li>在分布式锁中，它采用hash结构来存储锁，其中外层key表示这把锁是否存在，内层key则记录当前这把锁被哪个线程持有</li>
</ul>
</li>
<li>由于我们需要额外存储一个state，所以用字符串型SET NX EX是不行的，需要用到Hash结构，但是Hash结构又没有NX这种方法，所以我们需要将原有的逻辑拆开，进行手动判断</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679738915658-07739206-a06d-43bb-9af9-ea871a4de358.png#averageHue=%23e8dfde&clientId=u51856e4d-12b3-4&from=paste&id=u337f15c8&name=image.png&originHeight=688&originWidth=636&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=238378&status=done&style=none&taskId=u2d7678f9-73ff-49ce-a12b-f1e89277a20&title=#averageHue=%23e8dfde&id=E1zcv&originHeight=688&originWidth=636&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>为了保证原子性，所以流程图中的业务逻辑也是需要用Lua来实现</p>
<ul>
<li><p>获取锁的逻辑</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"><span class="comment">-- 锁不存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 获取锁并添加线程标识，state设为1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">-- 设置锁有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁存在，判断threadId是否为自己</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, thread, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">-- 设置锁的有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里，说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放锁的逻辑</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">-- 如果锁不是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 判断重入次数为多少</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 大于0，重置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 否则直接释放锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如何重试获取锁"><a href="#如何重试获取锁" class="headerlink" title="如何重试获取锁"></a>如何重试获取锁</h3><p>基于Redis Pub&#x2F;Sub发布订阅机制。如果获取锁失败，则阻塞订阅释放锁的消息；当锁被释放时，会触发推送（告诉其它线程我被释放了），然后其它线程再重试获取；如此往复知道超时</p>
<h3 id="如何防止锁提前超时释放"><a href="#如何防止锁提前超时释放" class="headerlink" title="如何防止锁提前超时释放"></a>如何防止锁提前超时释放</h3><p>基于<strong>看门狗机制</strong>。如果不手动设置锁释放时间 (leaseTime) ，默认设置 30 秒过期，并目给当前锁注册一个定时任务，该定时任务每隔 1&#x2F;3 的锁释放时间 (一般是 10 秒)会重置锁的过期时间(递归调用，一次续期完了再)<br>需要思考两个问题:</p>
<ol>
<li>如何保证同一个锁只注册一个定时任务?</li>
<li>如何防止无限续期?</li>
</ol>
<p>要解决这些问题，使用全局 ConcurrentHashMap 来管理锁 &#x3D;&gt; 任务信息，key 为锁的id，从而保证唯一。当某个锁释放时，从全局 ConcurrentHashMap 中取出定时任务并取消掉，然后把锁的信息从 Map 中删掉即可。<br>最终，完整的分布式锁流程如下<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679714572280-1fbba4ec-3b96-45ce-bc60-a8ee46289386.png#averageHue=%23faf6f6&clientId=u909f52ab-0fa4-4&from=paste&height=528&id=u13ed5ec8&name=image.png&originHeight=792&originWidth=1740&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=334255&status=done&style=none&taskId=u3219ee15-2a06-42f7-87c7-76a9162405c&title=&width=1160#averageHue=%23faf6f6&id=yu9hV&originHeight=792&originWidth=1740&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h2 id="如何解决主从一致性问题"><a href="#如何解决主从一致性问题" class="headerlink" title="如何解决主从一致性问题"></a>如何解决主从一致性问题</h2><p>如果使用主从复制的 Redis 集群，可能出现主从节点设置的锁状态不一致的问题可以使用 Redisson 的 MultiLock (联锁) 来解决，核心思想是开启多个独立的 Redis 主节点，设置锁时必须在所有主节点都写入成功，才算设置成功。这样做之后，哪怕有部分节点挂掉，其他线程也无法 setnx 全部成功，就不会出现重复执行业务的情况。<br>如下图:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681732694779-5bf00dd9-c14e-41c8-8d37-47ff81e797bf.png#averageHue=%23f5f4f0&clientId=uc6d03285-7526-4&from=paste&height=249&id=ua490693f&originHeight=373&originWidth=990&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=171249&status=done&style=none&taskId=ub7813047-c49d-49f1-a65b-f9551efe0ca&title=&width=660" alt="image.png"><br>实现 MultiLock 的几个关键:</p>
<ol>
<li>遍历所有节点，依次设置锁，并使用列表来记录所有主节点的锁是否设置成功。</li>
<li>只要有一个节点设置不成功，就要释放所有的锁，从头来过。</li>
<li>因为不同节点设置锁成功的时间不同，所以在所有锁设置成功后，要统一设置过期时间(但如果 leaseTime &#x3D; -1 就不用了，因为开启了看门狗机制会自动续期)</li>
<li>锁释放时间 (leaseTime) 必须要大于抢锁最大等待时间 (waitTime) ，否则可能出现第一个节点抢到锁，最后一个节点还没抢到锁，之前的锁就已经超时释放了。所以如果指定了 waitTime 和 leaseTime，默认 leaseTime &#x3D; waitTime * 2</li>
</ol>
<p>MultiLock 最安全，但同样会带来很大的运维成本</p>
<h2 id="秒杀业务优化"><a href="#秒杀业务优化" class="headerlink" title="秒杀业务优化"></a>秒杀业务优化</h2><p>我们先来回顾一下下单流程<br>当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤</p>
<ol>
<li>查询优惠券</li>
<li>判断秒杀库存是否足够</li>
<li>查询订单</li>
<li>校验是否一人一单</li>
<li>扣减库存</li>
<li>创建订单</li>
</ol>
<ul>
<li>在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？</li>
<li>优化方案：我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679795940035-050f0b62-6ac6-4f8d-9d35-e02215f0004f.png#averageHue=%23faf6f6&clientId=uaf30bc39-5a32-4&from=paste&id=u29e65c67&name=image.png&originHeight=732&originWidth=1540&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=423648&status=done&style=none&taskId=u070515ef-409f-4cba-ab7c-d58280195f5&title=#averageHue=%23faf6f6&id=Pdrmz&originHeight=732&originWidth=1540&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<ul>
<li>但是这里还存在两个难点 <ol>
<li>我们怎么在Redis中快速校验是否一人一单，还有库存判断</li>
<li>我们校验一人一单和将下单数据写入数据库，这是两个线程，我们怎么知道下单是否完成。 <ul>
<li>我们需要将一些信息返回给前端，同时也将这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询下单逻辑是否完成</li>
</ul>
</li>
</ol>
</li>
<li>我们现在来看整体思路：当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将userId和优惠券存入到Redis中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作，同时由于我们需要在Redis中查询优惠券信息，所以在我们新增秒杀优惠券的同时，需要将优惠券信息保存到Redis中</li>
<li>完成以上逻辑判断时，我们只需要判断当前Redis中的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单，其阿奴单可以通过返回订单的id来判断是否下单成功</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679795974724-d93dabe5-c9ad-40eb-a1d4-d978736cd505.png#averageHue=%23f2eded&clientId=uaf30bc39-5a32-4&from=paste&id=u4e25731c&name=image.png&originHeight=760&originWidth=1606&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=413127&status=done&style=none&taskId=ua7f3dfb8-229d-40a6-a4f4-d68e5ed3118&title=#averageHue=%23f2eded&id=v0nPj&originHeight=760&originWidth=1606&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中(修改之前添加的逻辑）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀优惠券信息到Reids，这里并不需要设置有效期，等秒杀活动过了，我们再手动将其删除</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写Lua脚本：lua的字符串拼接使用..，字符串转数字是tonumber()</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 订单id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 优惠券key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 判断用户是否下单</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 将userId存入当前优惠券的set集合</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">	SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">	SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="comment">//1. 执行lua脚本</span></span><br><span class="line">	<span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">											  Collections.emptyList(), voucherId.toString(),</span><br><span class="line">											  UserHolder.getUser().getId().toString());</span><br><span class="line"><span class="comment">//2. 判断返回值，并返回错误信息</span></span><br><span class="line"><span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"><span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 返回订单id</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这边由于没有key，所以使用Collections.emptyList()</p>
</blockquote>
<h3 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h3><ul>
<li>修改下单的操作，我们在下单时，是通过Lua表达式去原子执行判断逻辑，如果判断结果不为0，返回错误信息，如果判断结果为0，则将下单的逻辑保存到队列中去，然后异步执行</li>
<li>需求 <ol>
<li>如果秒杀成功，则将优惠券id和用户id封装后存入阻塞队列</li>
<li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li>
</ol>
</li>
<li>步骤一：创建阻塞队列<br>阻塞队列有一个特点：当一个线程尝试从阻塞队列里获取元素的时候，如果没有元素，那么该线程就会被阻塞，直到队列中有元素，才会被唤醒，并去获取元素<br>阻塞队列的创建需要指定一个大小<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
那么把优惠券id和用户id封装后存入阻塞队列<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString());</span><br><span class="line">    <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//加入到阻塞队列</span></span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实现异步下单功能</li>
</ul>
<ol>
<li><p>创建一个线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建线程任务：秒杀业务需要在类初始化之后，就立即执行，这里用到@PostConstruct注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1. 获取队列中的订单信息</span></span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                <span class="comment">//2. 创建订单</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订单逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="comment">//2. 创建锁对象，作为兜底方案</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//3. 获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">    <span class="comment">//4. 判断是否获取锁成功(理论上必成功，redis已经帮我们判断了)</span></span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;不允许重复下单!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//5. 使用代理对象，由于这里是另外一个线程，</span></span><br><span class="line">        proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看AopContext源码，它的获取代理对象也是通过ThreadLocal进行获取的，由于我们这里是异步下单，和主线程不是一个线程，所以不能获取成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Object&gt; currentProxy = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>(<span class="string">&quot;Current AOP proxy&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是我们可以将proxy放在成员变量的位置，然后在主线程中获取代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString());</span><br><span class="line">    <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//加入到阻塞队列</span></span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line">    <span class="comment">//主线程获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.mapper.VoucherOrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.service.ISeckillVoucherService;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.service.IVoucherOrderService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.RedisIdWorker;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.AopContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">//2. 创建锁对象，作为兜底方案</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//3. 获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        <span class="comment">//4. 判断是否获取锁成功(理论上必成功，redis已经帮我们判断了)</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//5. 使用代理对象，由于这里是另外一个线程，</span></span><br><span class="line">            proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//1. 获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">//2. 创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(), voucherId.toString(),</span><br><span class="line">                UserHolder.getUser().getId().toString());</span><br><span class="line">        <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//加入到阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//主线程获取代理对象</span></span><br><span class="line">        proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 一人一单逻辑</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;user_id&quot;</span>, userId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;你已经抢过优惠券了哦&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5. 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                    .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                    .update();</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//7. 将订单数据保存到表中</span></span><br><span class="line">            save(voucherOrder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>JDK 中的阻塞队列（BlockingQueue）是一种线程安全的队列，它可以在多线程环境下使用。但是，使用阻塞队列也可能存在一些问题，以下是其中的一些：</p>
<ol>
<li>死锁：如果多个线程同时尝试获取队列的元素，但队列已满或已空，则可能会导致死锁。这是因为队列的操作是阻塞的，一旦有线程获取了队列的元素，其他线程就必须等待，直到队列中有空间可用。</li>
<li>竞争条件：如果多个线程同时尝试获取队列的元素，但队列中已经有一个线程正在等待，则其他线程可能会被阻塞，直到队列中有空间可用。这会导致系统资源的浪费。</li>
<li>不确定性：由于阻塞队列是线程安全的，因此在某些情况下，线程可能会在等待队列操作完成时发生阻塞，而无法立即执行其他操作。这会导致程序的性能下降。</li>
<li>不可恢复性：如果队列被意外地破坏，例如由于系统故障或异常，则可能会导致数据丢失或不一致。这使得阻塞队列在某些情况下不可恢复。</li>
</ol>
<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>最简单的消息队列模型包括3个角色</p>
<ol>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ol>
<p>使用队列的好处在于解耦：举个例子，快递员(生产者)吧快递放到驿站&#x2F;快递柜里去(Message Queue)去，我们(消费者)从快递柜&#x2F;驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的<br>那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度<br>这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案(学完Redis我就去学微服务)</p>
<h2 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><p>Redis的list数据结构是一个<strong>双向链表</strong>，很容易模拟出队列的效果<br>队列的入口和出口不在同一边，所以我们可以利用：LPUSH模拟生产者发送消息入队，使用<br>BRPOP或者BLPOP来实现阻塞效果<br><code>BRPOP</code> 命令用于阻塞地等待队列中有空闲空间(队列长度&gt;0)，并在有空闲空间时立即返回消息。如果队列为空，则 BRPOP 命令会阻塞等待，直到有空闲空间可用。<br><code>BLPOP</code> 命令用于立即获取队列中的消息，并在有消息可用时返回。如果队列为空，则 BLPOP 命令会阻塞等待，直到有消息可用。<br>基于List的消息队列有哪些优缺点？<br>优点</p>
<ol>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保障</li>
<li>可以满足消息有序性</li>
</ol>
<p>缺点</p>
<ol>
<li>无法避免消息丢失(经典服务器宕机)</li>
<li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li>
</ol>
<h2 id="Pub-x2F-Sub"><a href="#Pub-x2F-Sub" class="headerlink" title="Pub&#x2F;Sub"></a>Pub&#x2F;Sub</h2><p>使用 Redis 的订阅发布模型，生产者可以将消息推送给某个 Channel (频道) ，多个消费者可以订阅该频道，从而同时得到消息。(可以理解为“你关注的 UP 主更新啦”)<br>用到的命令主要是</p>
<ul>
<li>Publish 推送</li>
<li>SubScribe 订阅</li>
<li>PSubScribe 订阅某个表达式匹配的多个频道这样就实现了多生产、多消费缺点比较多</li>
</ul>
<p>优点：<br>采用发布订阅模型，支持多生产，多消费<br>缺点：</p>
<ol>
<li>不支持数据持久化</li>
<li>无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）</li>
<li>消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）</li>
</ol>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><ul>
<li>Stream是Redis 5.0引入的一种新数据类型，可以时间一个功能非常完善的消息队列</li>
</ul>
<h2 id="核心命令"><a href="#核心命令" class="headerlink" title="核心命令"></a>核心命令</h2><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><code>XAdd</code>：添加消息&#x2F;创建队列，消息会自动持久化，不会丢失，每个消息都有唯一id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XADD streamName ID field1 value1 field2 value2 ... fieldN valueN</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>treamName是Stream的名称，ID是消息的唯一标识符，field和value是消息的键值对。</li>
<li>D有两种形式：和*。表示使用自动生成的ID，表示手动指定ID。如果使用$，那么ID的格式为timestamp-sequencenumber，其中timestamp是Unix时间戳，sequencenumber是一个递增的序列号。如果使用，那么ID必须是一个整数，并且必须比Stream中最后一条消息的ID大</li>
<li>XADD指令会返回新消息的ID，可以用这个ID来查询或删除消息。如果Stream不存在，XADD指令会自动创建一个新的Stream。</li>
</ul>
</blockquote>
<h3 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h3><p><code>XRead</code>：读取消息，支持多消费者读，可从指定id开读，支持阻塞读取最新消息<br>Redis Stream提供了多种方式来读取消息，以下是常用的几种方法：<br>XREAD：使用XREAD指令可以读取Stream中的消息。XREAD可以指定多个Stream和ID，返回的结果是一个数组，包含了每个Stream中指定ID之后的所有消息。</p>
<ul>
<li><p>XREAD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>
<p>其中，COUNT和BLOCK是可选参数。COUNT表示最多返回的消息数量，BLOCK表示阻塞的超时时间。如果不指定这两个参数，XREAD会一直阻塞直到Stream中有新的消息可读。<br>STREAMS后面跟着的是一个或多个Stream的名称，ID后面跟着的是一个或多个ID。XREAD会返回每个Stream中指定ID之后的所有消息。<br>XREAD返回的结果是一个数组，数组中的每个元素都是一个键值对，键是Stream的名称，值是一个数组，包含了Stream中指定ID之后的所有消息。<br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始<br>XREAD指令可以根据实际需求灵活使用。如果不需要阻塞等待新的消息，则可以不指定BLOCK参数；如果需要一次性读取多个Stream中的消息，则可以在STREAMS参数中指定多个Stream的名称。如果需要控制返回的消息数量，则可以使用COUNT参数。</p>
</li>
<li><p>阻塞读取最新消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREAD COUNT 2 BLOCK 10000 STREAMS users $</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//尝试读取队列中的消息，最多阻塞2秒</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 2 BLOCK 10000 STREAMS users $&quot;</span>);</span><br><span class="line">    <span class="comment">//没读取到，跳过下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理消息</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意：当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题</p>
</blockquote>
<ul>
<li>STREAM类型消息队列的XREAD命令特点 <ol>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有漏读消息的风险</li>
</ol>
</li>
</ul>
<h2 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h2><p>只用这两个命令还是不够的，因为目前只支持<code>阻塞读最新</code>消息，假设处理消息过程中又来了几条消息，可能出现<code>漏读消息</code>的情况<br>为解决上述问题，可以用 Stream 的以下特性:<br><code>消费组</code>: 同组内的多个消费者可以竞争消费(每个消息只有<code>一个</code>消费者能抢到) ，从而提高消费能力 (并发度) 。对应命令为<code>XGROUP</code>、<code>XREADGROUP</code> 等<br><code>消息标识</code>: 自动记录消费的进度，支持从上次未消费的地方开始接着消费，保证每条消息按顺序消费<br><code>消息确认机制</code>: 默认消费的消息为 pending 状态，会放到每个消费者的 pending list 中，只有消息由消费者确认 (ACK) ，才会从pending list 移除。这样如果消费业务处理异常，可以从 pending list 的开头依次读取未确认消息，重试处理。(也要避免无限重试，实在处理不成功就强制 ACK + 业务记日志)整个消费流程伪代码如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681813734547-cf20c3b8-8162-497e-971f-ff1653f75412.png#averageHue=%23f3f3f5&clientId=uf387f538-a383-4&from=paste&height=647&id=u0424266b&originHeight=970&originWidth=1064&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=276073&status=done&style=none&taskId=u210cccb8-a907-47ef-a20c-ed947cc9a52&title=&width=709.3333333333334" alt="image.png"></p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><code>消费者组</code>(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点</p>
<ol>
<li>消息分流：队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而加快消息处理的速度</li>
<li><code>消息标识</code>：消费者会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费</li>
<li>消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</li>
</ol>
<p>在Redis Stream中，消费者组的<code>创建和管理</code>都由<code>XGROUP</code>命令完成。XGROUP命令有两个子命令：CREATE和<code>SETID</code>。CREATE用于创建一个新的消费者组，SETID用于设置消费者组的<code>最后已读消息ID</code>。</p>
<p>创建消费者组后，可以使用<code>XREADGROUP</code>命令让多个消费者从<code>同一个Stream中读取消息</code>，并使用XACK命令确认已经消费的消息。这种方式可以保证消息不会被重复消费，也可以让多个消费者协同处理消息，提高处理效率。</p>
<p>需要注意的是，消费者组中的每个消费者都要有一个唯一的名称（即消费者ID），XGROUP和XREADGROUP命令都需要指定消费者ID。消费者ID可以自己定义，也可以由程序自动生成。另外，消费者组中的消费者数量应该根据实际需求进行适当控制，避免过多或过少导致性能问题。</p>
<p>创建消费者组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE key groupName ID [MKSTREAM]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>key <ul>
<li>队列名称</li>
</ul>
</li>
<li>groupName <ul>
<li>消费者组名称</li>
</ul>
</li>
<li>ID <ul>
<li>起始ID标识，$代表队列中的最后一个消息，0代表队列中的第一个消息</li>
</ul>
</li>
<li>MKSTREAM <ul>
<li>队列不存在时自动创建队列</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>删除指定的消费者组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure>
</li>
<li><p>给指定的消费者组添加消费者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupName consumerName</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除消费者中指定的消费者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupName consumerName</span><br></pre></td></tr></table></figure>
</li>
<li><p>从消费者中读取信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP groupName consumerName [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ul>
<li>group <ul>
<li>消费者组名称</li>
</ul>
</li>
<li>consumer <ul>
<li>消费者名，如果消费者不存在，会自动创建一个消费者</li>
</ul>
</li>
<li>count <ul>
<li>本次查询的最大数量</li>
</ul>
</li>
<li>BLOCK milliseconds <ul>
<li>当前没有消息时的最大等待时间</li>
</ul>
</li>
<li>NOACK <ul>
<li>无需手动ACK，获取到消息后自动确认（一般不用，我们都是手动确认）</li>
</ul>
</li>
<li>STREAMS key <ul>
<li>指定队列名称</li>
</ul>
</li>
<li><h2 id="ID-获取消息的起始ID"><a href="#ID-获取消息的起始ID" class="headerlink" title="ID-  获取消息的起始ID "></a>ID<br>-  获取消息的起始ID </h2><ul>
<li>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul>
</li>
</ul>
</blockquote>
<p>消费者监听消息的基本思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 尝试监听队列，使用阻塞模式，最大等待时长为2000ms</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 没监听到消息，重试</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//处理消息，完成后要手动确认ACK，ACK代码在handleMessage中编写</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//null表示没有异常消息，所有消息均已确认，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//说明有异常消息，再次处理</span></span><br><span class="line">                handleMessage(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">//再次出现异常，记录日志，继续循环</span></span><br><span class="line">                log.error(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>STREAM类型消息队列的XREADGROUP命令的特点 <ol>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681813769915-396e4ff5-1da4-4aea-921f-f89c05eed249.png#averageHue=%23f9f7f4&clientId=uf387f538-a383-4&from=paste&height=523&id=u37f0fd91&originHeight=784&originWidth=1778&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=272522&status=done&style=none&taskId=u0a199aa2-d48b-4d81-bbe5-c06d9a36405&title=&width=1185.3333333333333" alt="image-1.png"></p>
<h3 id="实现异步下单"><a href="#实现异步下单" class="headerlink" title="实现异步下单"></a>实现异步下单</h3><p>需求：</p>
<ol>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li>
</ol>
<p>步骤一：创建一个Stream类型的消息队列，名为stream.orders</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE stream.orders g1 0 MKSTREAM</span><br></pre></td></tr></table></figure>
<p>步骤二：修改Lua脚本，新增orderId参数，并将订单信息加入到消息队列中</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 订单id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的</span></span><br><span class="line"><span class="keyword">local</span> id = ARGV[<span class="number">3</span>]</span><br><span class="line"><span class="comment">-- 优惠券key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 判断用户是否下单</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 将userId存入当前优惠券的set集合</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 将下单数据保存到消息队列中</span></span><br><span class="line">redis.call(<span class="string">&quot;sadd&quot;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, id)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>步骤三：修改秒杀逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString(), String.valueOf(orderId));</span><br><span class="line">    <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤四：修改我们的VoucherOrderHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1. 获取队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.opsForStream().read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                        <span class="comment">//ReadOffset.lastConsumed()底层就是 &#x27;&gt;&#x27;</span></span><br><span class="line">                        StreamOffset.create(queueName, ReadOffset.lastConsumed()));</span><br><span class="line">                <span class="comment">//2. 判断消息是否获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (records == <span class="literal">null</span> || records.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3. 消息获取成功之后，我们需要将其转为对象</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = records.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; values = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//4. 获取成功，执行下单逻辑，将数据保存到数据库中</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">//5. 手动ACK，SACK stream.orders g1 id</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//订单异常的处理方式我们封装成一个函数，避免代码太臃肿</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0</span></span><br><span class="line">            List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(queueName, ReadOffset.from(<span class="string">&quot;0&quot;</span>)));</span><br><span class="line">            <span class="comment">//2. 判断pending-list中是否有未处理消息</span></span><br><span class="line">            <span class="keyword">if</span> (records == <span class="literal">null</span> || records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//如果没有就说明没有异常消息，直接结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3. 消息获取成功之后，我们需要将其转为对象</span></span><br><span class="line">            MapRecord&lt;String, Object, Object&gt; record = records.get(<span class="number">0</span>);</span><br><span class="line">            Map&lt;Object, Object&gt; values = record.getValue();</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4. 获取成功，执行下单逻辑，将数据保存到数据库中</span></span><br><span class="line">            handleVoucherOrder(voucherOrder);</span><br><span class="line">            <span class="comment">//5. 手动ACK，SACK stream.orders g1 id</span></span><br><span class="line">            stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理pending-list异常&quot;</span>);</span><br><span class="line">            <span class="comment">//如果怕异常多次出现，可以在这里休眠一会儿</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h1><p>修改点赞功能，利用Redis中的set集合来判断是否点赞过，未点赞则点赞数+1，已点赞则点赞数-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户信息</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isLiked</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">    <span class="keyword">if</span> (BooleanUtil.isFalse(isLiked)) &#123;</span><br><span class="line">        <span class="comment">//点赞数 +1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//将用户加入set集合</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//点赞数 -1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span> (success)&#123;</span><br><span class="line">            <span class="comment">//从set集合移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h1><p>实现：使用Redis SortedSet（自动按score排序的数据结构），把用户点赞时间作为score，使用ZRange范围查询TopN<br>修改代码likeBlog,存储点赞用户的时候还要有能区分先后顺序的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户信息</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">//尝试获取score</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    <span class="comment">//为null，则表示集合中没有该用户</span></span><br><span class="line">    <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//点赞数 +1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//将用户加入set集合</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//点赞数 -1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="comment">//从set集合移除</span></span><br><span class="line">            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">//zrange key 0 4  查询zset中前5个元素</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//如果是空的(可能没人点赞)，直接返回一个空集合</span></span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//将ids使用`,`拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排</span></span><br><span class="line">    <span class="comment">//所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">//select * from tb_user where id in (ids[0], ids[1] ...) order by field(id, ids[0], ids[1] ...)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query().in(<span class="string">&quot;id&quot;</span>, ids)</span><br><span class="line">            .last(<span class="string">&quot;order by field(id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            .list().stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这边的ids是取出来就是按照点赞时间排序的，假设点赞的是[5,1],所以要查5和1两个用户，同时5在前，但是一般的查询有下面的问题</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `tb_user` <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679819565995-204a993e-6d1b-4215-81e2-efa0222203bf.png#averageHue=%23f5f2f0&clientId=u7fe237e5-bb7e-4&from=paste&height=57&id=u812b333d&name=image.png&originHeight=86&originWidth=510&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5969&status=done&style=none&taskId=u5842c336-5424-48dd-8ebf-aa6ee105bd5&title=&width=340#averageHue=%23f5f2f0&id=Wb6MF&originHeight=86&originWidth=510&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>查询出来变成了1号用户在前面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `tb_user` <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> FIELD(id,<span class="number">5</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679819711378-6ebee88a-ef6e-4b95-9a75-9ae92a027a5f.png#averageHue=%23f5f2f0&clientId=u7fe237e5-bb7e-4&from=paste&height=57&id=u95be7968&name=image.png&originHeight=86&originWidth=504&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5804&status=done&style=none&taskId=u2083ad3d-1588-4431-aa7e-bf51ec7267f&title=&width=336#averageHue=%23f5f2f0&id=PRsQ5&originHeight=86&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>这边使用到了mybatis的last</p>
<h1 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h1><p>需求:计算两个人共同关注的所有用户<br>思路: 本质就是求两个用户关注集合的 <strong>交集</strong><br>实现: 使用 Redis Set 数据结构，每个 key 保存 1个用户的关注集合 (取关时从集合中移除对应用户)，最后对 2 个用户对应的 set 进行 intersect取交集操作即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFellow)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">//判断是否关注</span></span><br><span class="line">    <span class="keyword">if</span> (isFellow) &#123;</span><br><span class="line">        <span class="comment">//关注，则将信息保存到数据库</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="comment">//如果保存成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="comment">//则将数据也写入Redis</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//取关，则将数据从数据库中移除</span></span><br><span class="line">        LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);</span><br><span class="line">        <span class="comment">//如果取关成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> remove(queryWrapper);</span><br><span class="line">        <span class="comment">//则将数据也从Redis中移除</span></span><br><span class="line">        <span class="keyword">if</span> (success)&#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现公共关注代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">//对当前用户和博主用户的关注列表取交集</span></span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//无交集就返回个空集合</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果转为list</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//之后根据ids去查询共同关注的用户，封装成UserDto再返回</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream().map(user -&gt;</span><br><span class="line">            BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Feed流关注推送"><a href="#Feed流关注推送" class="headerlink" title="Feed流关注推送"></a>Feed流关注推送</h1><p>场景：当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂，为用户提供沉浸式体验，通过无限下拉刷新获取新的信息，</p>
<ul>
<li>Feed流的实现有两种模式 <ol>
<li>Timeline：不做内容筛选，简单的按照内容<code>发布时间</code>排序，常用于好友或关注(B站关注的up，朋友圈等) <ul>
<li>优点：信息全面，不会有缺失，并且实现也相对简单</li>
<li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li>
</ul>
</li>
<li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户<code>感兴趣</code>的信息来吸引用户 <ul>
<li>优点：投喂用户感兴趣的信息，用户粘度很高，容易沉迷</li>
<li>缺点：如果算法不精准，可能会起到反作用（给你推的你都不爱看）</li>
</ul>
</li>
</ol>
</li>
<li>那我们这里针对好友的操作，采用的是Timeline方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</li>
</ul>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="拉模式（读扩散）"><a href="#拉模式（读扩散）" class="headerlink" title="拉模式（读扩散）"></a>拉模式（读扩散）</h3><ul>
<li>该模式的核心含义是：当张三和李四、王五发了消息之后，都会保存到自己的发件箱中，如果赵六要读取消息，那么他会读取他自己的收件箱，此时系统会从他关注的人群中，将他关注人的信息全都进行拉取，然后进行排序</li>
<li>优点：比较节约空间，因为赵六在读取信息时，并没有重复读取，并且读取完之后，可以将他的收件箱清除</li>
<li>缺点：有延迟，当用户读取数据时，才会去关注的人的时发件箱中拉取信息，假设该用户关注了海量用户，那么此时就会拉取很多信息，对服务器压力巨大</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831142177-eec16b9f-5547-44c4-a315-b3247d3f78ef.png#averageHue=%23fcfcfb&clientId=ucc2cc29c-dcb2-4&from=paste&id=u0b810fd4&name=image.png&originHeight=636&originWidth=1477&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=299204&status=done&style=none&taskId=u1bd1e78a-ed8b-4219-94ea-0455d2e3d1a&title=#averageHue=%23fcfcfb&id=AW2pd&originHeight=636&originWidth=1477&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><ul>
<li>推模式是没有写邮箱的，当张三写了一个内容，此时会主动把张三写的内容发送到它粉丝的收件箱中，假设此时李四再来读取，就不用再去临时拉取了</li>
<li>优点：时效快，不用临时拉取</li>
<li>缺点：内存压力大，假设一个大V发了一个动态，很多人关注他，那么就会写很多份数据到粉丝那边去</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831159323-c8b68aac-7238-4f04-bf4e-c0799217dcb5.png#averageHue=%23fdfdfd&clientId=ucc2cc29c-dcb2-4&from=paste&id=u9807b0c6&name=image.png&originHeight=714&originWidth=1102&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=246856&status=done&style=none&taskId=u41bcdc42-6f05-4639-ba22-b5bdb0701cd&title=#averageHue=%23fdfdfd&id=BjhwJ&originHeight=714&originWidth=1102&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h3><ul>
<li>推拉模式是一个折中的方案，站在发件人这一边，如果是普通人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝收件箱中，因为普通人的粉丝数量较少，所以这样不会产生太大压力。但如果是大V，那么他是直接将数据写入一份到发件箱中去，在直接写一份到活跃粉丝的收件箱中，站在收件人这边来看，如果是活跃粉丝，那么大V和普通人发的都会写到自己的收件箱里，但如果是普通粉丝，由于上线不是很频繁，所以等他们上线的时候，再从发件箱中去拉取信息。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831189183-35e6d385-a0c9-4c18-8024-d2134f558bed.png#averageHue=%23fcfcfb&clientId=ucc2cc29c-dcb2-4&from=paste&id=u718e9b37&name=image.png&originHeight=634&originWidth=1432&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=303923&status=done&style=none&taskId=uc950f982-89f8-488d-8a5f-bede7e15f14&title=#averageHue=%23fcfcfb&id=rEcsG&originHeight=634&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681815380922-aaf78d43-aa3a-42b6-a2a3-201deff42876.png#averageHue=%23f8f5f3&clientId=uf387f538-a383-4&from=paste&height=552&id=uc3e8a299&originHeight=828&originWidth=1880&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=223851&status=done&style=none&taskId=u4c43a7eb-70a9-40db-9fa0-0782301d700&title=&width=1253.3333333333333" alt="image.png"></p>
<h2 id="推模式实现"><a href="#推模式实现" class="headerlink" title="推模式实现"></a>推模式实现</h2><p>因为推送是按时间排序的，所以可以使用SortedSet 数据结构来保存，每个 key 表示一个用户的收件箱，value 为推送 id、score 为推送时间戳。<br>查询所有推送时直接遍历 SortedSet 即可</p>
<h3 id="分页问题"><a href="#分页问题" class="headerlink" title="分页问题"></a>分页问题</h3><ul>
<li>Feed流中的数据会不断更新，所以数据的角标也会不断变化，所以我们不能使用传统的分页模式</li>
<li>假设在t1时刻，我们取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么我们拿到的就是10<del>6这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是6</del>2，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831641147-58170514-b54f-4e34-abf5-7db96a18ef6e.png#averageHue=%23faf9f8&clientId=ucc2cc29c-dcb2-4&from=paste&id=ufc97b562&name=image.png&originHeight=642&originWidth=1494&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=221148&status=done&style=none&taskId=ub4b84472-7d90-451f-9db8-e0cc817c688&title=#averageHue=%23faf9f8&id=sONhM&originHeight=642&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>因此，可以使用滚动分页，记录每次当前页查询到的最后一条数据的时间戳(类似游标) 。查询下一页时，从当前时间戳的下一条开始查询即可<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831668181-4e4dd5d6-0b80-4dd0-a8e5-bb567e00e3a2.png#averageHue=%23f9f9f8&clientId=ucc2cc29c-dcb2-4&from=paste&id=ubebabba6&name=image.png&originHeight=657&originWidth=1480&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=220226&status=done&style=none&taskId=uc076c65c-6ac0-4f91-8810-5e8154de3ff&title=#averageHue=%23f9f9f8&id=MOoCB&originHeight=657&originWidth=1480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 保存探店博文</span></span><br><span class="line">    save(blog);</span><br><span class="line">    <span class="comment">// 条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从follow表最中，查找当前用户的粉丝  select * from follow where follow_user_id = user_id</span></span><br><span class="line">    queryWrapper.eq(Follow::getFollowUserId, user.getId());</span><br><span class="line">    <span class="comment">//获取当前用户的粉丝</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.list(queryWrapper);</span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        <span class="comment">//推送数据</span></span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现分页查询收件箱"><a href="#实现分页查询收件箱" class="headerlink" title="实现分页查询收件箱"></a>实现分页查询收件箱</h2><p>可以使用 <code>SortedSet</code> 的 <code>ZRevRangeByScore</code> 命令实现，每次查询指定时间戳范围 (0，当前最大时间戳)的指定条数的数据。示例命令: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRevRangeByScore key 0 maxTimeStampoffset limit</span><br></pre></td></tr></table></figure>
<p>注意有个问题，可能出现相同时间戳戳的数据，因此第一次查询时 offset 为 0 (从第一条开始查)，之后每次查询，<code>offset</code> 为上一页中时间戳最小值的数量，保证不查出重复数据<br>比如 score 列表为: 5,4, 4,3,2,1。每页 3 条第一次查询 ZRevRangeByScore key 0 99999990 3 查出 5、4、4，最小值 4 重复 2 次，即下一次的最大值为 4、offset 为 2.所以第二次查询为 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRevRangeByScore key 0 4 2</span><br></pre></td></tr></table></figure>
<p> 查出 3、2、1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(<span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;,defaultValue = &quot;0&quot;)</span> Integer offset)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max,offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 查询该用户收件箱（之前我们存的key是固定前缀 + 粉丝id），所以根据当前用户id就可以查询是否有关注的人发了笔记</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    <span class="comment">// 2.表示每次查询两条，这边写死了</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typeTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//3. 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typeTuples == <span class="literal">null</span> || typeTuples.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 解析数据，blogId、minTime（时间戳）、offset，这里指定创建的list大小，可以略微提高效率，因为我们知道这个list就得是这么大</span></span><br><span class="line">    ArrayList&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typeTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typeTuple : typeTuples) &#123;</span><br><span class="line">        <span class="comment">//4.1 获取id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> typeTuple.getValue();</span><br><span class="line">        ids.add(Long.valueOf(id));</span><br><span class="line">        <span class="comment">//4.2 获取score（时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typeTuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span> (time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解决SQL的in不能排序问题，手动指定排序为传入的ids</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="comment">//5. 根据id查询blog</span></span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">//5.1 查询发布该blog的用户信息</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">//5.2 查询当前用户是否给该blog点过赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 封装结果并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    scrollResult.setList(blogs);</span><br><span class="line">    scrollResult.setOffset(os);</span><br><span class="line">    scrollResult.setMinTime(minTime);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="GEO地理坐标计算"><a href="#GEO地理坐标计算" class="headerlink" title="GEO地理坐标计算"></a>GEO地理坐标计算</h1><h2 id="GEO数据类型"><a href="#GEO数据类型" class="headerlink" title="GEO数据类型"></a>GEO数据类型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681816166386-ec9bc25f-94a6-4b1e-bc82-c900b4a63ba2.png#averageHue=%23f1f1f1&clientId=uf387f538-a383-4&from=paste&height=532&id=u667e9a76&originHeight=798&originWidth=1914&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=511613&status=done&style=none&taskId=u2c83c41c-cc11-4359-a5d5-3a212a41ee0&title=&width=1276" alt="image.png"><br>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据，常见的命令有</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member …]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>返回值：添加到sorted set元素的数⽬，但不包括已更新score的元素</li>
<li>复杂度：每⼀个元素添加是O(log(N)) ，N是sorted set的元素数量</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD china 13.361389 38.115556 &quot;shanghai&quot; </span><br><span class="line">15.087269 37.502669 &quot;beijing&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>GEODIST：计算指定的两个点之间的距离并返回<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果两个位置之间的其中⼀个不存在， 那么命令返回空值。</li>
<li>指定单位的参数 unit 必须是以下单位的其中⼀个： <ul>
<li>m 表⽰单位为⽶。</li>
<li>km 表⽰单位为千⽶。</li>
<li>mi 表⽰单位为英⾥。</li>
<li>ft 表⽰单位为英尺。</li>
</ul>
</li>
<li>如果⽤户没有显式地指定单位参数， 那么 GEODIST 默认使⽤⽶作为单位。</li>
<li>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这⼀假设最⼤会造成 0.5% 的误差</li>
<li>返回值：计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEODIST china beijing shanghai km</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GEOHASH：将指定member的坐标转化为hash字符串形式并返回</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOHASH key member [member …]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>通常使用表示位置的元素使用不同的技术，使用Geohash位置52点整数编码。由于编码和解码过程中所使用的初始最小和最大坐标不同，编码的编码也不同于标准。此命令返回一个标准的Geohash，在维基百科和geohash.org网站都有相关描述</li>
<li>返回值：一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应</li>
<li>复杂度：O(log(N)) for each member requested, where N is the number of elements in the sorted set</li>
</ul>
</blockquote>
</li>
<li><p>GEOPOS：返回指定member的坐标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOPOS key member [member …]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>给定一个sorted set表示的空间索引，密集使用 geoadd 命令，它以获得指定成员的坐标往往是有益的。当空间索引填充通过 geoadd 的坐标转换成一个52位Geohash，所以返回的坐标可能不完全以添加元素的，但小的错误可能会出台。</li>
<li>因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复</li>
<li>返回值：GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。当给定的位置元素不存在时， 对应的数组项为空值</li>
<li>复杂度：O(log(N)) for each member requested, where N is the number of elements in the sorted set</li>
</ul>
</blockquote>
</li>
<li><p><strong>GEOGADIUS</strong>：指定圆心、半径，找到该园内包含的所有member，并按照与圆心之间的距离排序后返回，6.2之后已废弃</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] </span><br><span class="line">[COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>范围可以使用以下其中一个单位： <ul>
<li>m 表示单位为米。</li>
<li>km 表示单位为千米。</li>
<li>mi 表示单位为英里。</li>
<li>ft 表示单位为英尺。</li>
</ul>
</li>
<li>在给定以下可选项时， 命令会返回额外的信息： <ul>
<li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li>
<li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li>
<li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li>
</ul>
</li>
<li>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式： <ul>
<li>ASC: 根据中心的位置， 按照从近到远的方式返回位置元素。</li>
<li>DESC: 根据中心的位置， 按照从远到近的方式返回位置元素。</li>
</ul>
</li>
<li>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的</li>
<li>返回值： <ul>
<li>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。</li>
<li>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。</li>
<li>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回： <ul>
<li>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<pre><code>  - geohash 整数。
  - 由两个元素组成的坐标，分别为经度和纬度
</code></pre>
</blockquote>
<ul>
<li><p><strong>GEOSEARCH</strong>：在指定范围内搜索member，并按照与制定点之间的距离排序后返回，范围可以使圆形或矩形，6.2的新功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOSEARCH key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] </span><br><span class="line">[BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure>
</li>
<li><p>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key，也是6.2的新功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOSEARCHSTORE destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] </span><br><span class="line">[BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] </span><br><span class="line">[ASC|DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点</li>
<li>指定成员的位置被用作查询的中心。</li>
<li>关于 GEORADIUSBYMEMBER 命令的更多信息， 请参考 GEORADIUS 命令的文档</li>
<li>复杂度：O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679905745055-21f78ee4-cafd-46f5-8afc-9c7a6f3faac0.png#averageHue=%23d9d9d7&clientId=u81ddba6a-6d17-4&from=paste&height=254&id=ua45eb1f1&name=image.png&originHeight=381&originWidth=702&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=125167&status=done&style=none&taskId=u40913940-bf3a-49c0-a7e1-c4324d394fa&title=&width=468#averageHue=%23d9d9d7&id=WJVFt&originHeight=381&originWidth=702&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679905938665-a2152d6d-335a-41b6-8605-4eb8c625f405.png#averageHue=%23e3d7d7&clientId=u81ddba6a-6d17-4&from=paste&height=463&id=ufa21e9f1&name=image.png&originHeight=695&originWidth=1405&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=290918&status=done&style=none&taskId=u6dcfa38b-fd72-4885-8a13-341daf9636a&title=&width=936.6666666666666#averageHue=%23e3d7d7&id=f1xWg&originHeight=695&originWidth=1405&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<blockquote>
<ul>
<li>后台： <ul>
<li>查询所有的店铺信息</li>
<li>根据类型分类店铺</li>
<li>将店铺的部分信息（id，经纬度）按照分组存储到Redis</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 查询所有店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    <span class="comment">//2. 按照typeId，将店铺进行分组</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">//3. 逐个写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//3.1 获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="comment">//3.2 获取同类型店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            <span class="comment">//3.3 写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">            stringRedisTemplate.opsForGeo().add(key,<span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(),shop.getY()),shop.getId().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">//GeoLocation 里面是name和point两个数据结构</span></span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(shops.size());</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            <span class="comment">//将当前type的商铺都添加到locations集合中</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//批量写入</span></span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附近功能"><a href="#附近功能" class="headerlink" title="附近功能"></a>附近功能</h2><p>需求：查询你附近的商铺，以及每个商铺和你的距离，并且安装由近及远排序</p>
<ul>
<li>引入依赖:SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的pom.xml文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId,current,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 判断是否需要根据距离查询</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 因为这个接口是复用的，x,y参数不是接口必须的，如果没有这个两个参数,就是按照热度排序</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据类型分页查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 计算分页查询参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">//3. 查询redis、按照距离排序、分页; 结果：shopId、distance</span></span><br><span class="line">        <span class="comment">//GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST LIMIT end</span></span><br><span class="line">        <span class="comment">// 商品类型 圆心 半径（默认m） </span></span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = </span><br><span class="line">            stringRedisTemplate.opsForGeo().search(key,GeoReference.fromCoordinate(x, y),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">    RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));</span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 解析出id</span></span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; from) &#123;</span><br><span class="line">            <span class="comment">//起始查询位置大于数据总量，则说明没数据了，返回空集合</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        HashMap&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        <span class="comment">// skip跳过前from</span></span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5. 根据id查询shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD( id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            <span class="comment">//设置shop的举例属性，从distanceMap中根据shopId查询</span></span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>多个二进制位组成的数据结构，每个二进制位对应一个业务的两种互斥状态。比如: 10010011.<br>BitMap 的优点是可以用最小的代码 (1 个 bit)来保存业务含义，从而大幅节省空间、实现高效运算等。比如可以把某个二进制位从 0 改为 1</p>
<blockquote>
<p>底层是 string 类型，以字节为单位存储，所以 bit 的长度为 8 的倍数</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681817342128-bf9efc40-3cf8-4647-9039-e4cbe737fcff.png#averageHue=%23f1f1f1&clientId=uf387f538-a383-4&from=paste&height=259&id=ue98311ca&originHeight=389&originWidth=888&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=192225&status=done&style=none&taskId=u7ea54330-8152-40ab-8f98-c4659b696c8&title=&width=592" alt="image.png"></p>
<h2 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679913528034-a60a5d3c-7153-4e6f-81ba-6fa6b6587019.png#averageHue=%23f6f4f4&clientId=u81ddba6a-6d17-4&from=paste&height=197&id=u4725c995&name=image.png&originHeight=295&originWidth=1662&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=60368&status=done&style=none&taskId=u0626b572-581b-402a-9fb3-0c4ef194ef7&title=&width=1108#averageHue=%23f6f4f4&id=eRvwz&originHeight=295&originWidth=1662&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p>
<ul>
<li>BitMap的操作命令有 <ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT：获取指定位置（offset）的bit值</li>
<li>BITCOUNT：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li>
<li>BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP：将多个BitMap的结果做位运算（与、或、异或）</li>
<li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
</li>
</ul>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>用 <code>BITSET</code> 设置某一天对应位置的 bit 值即可，需要查签到状态时可以用 <code>BITFIELD GET</code>取出整个 BitMap 的十进制值，再用 位运算 将十进制值转为业务需要的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">//3. 拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">//4. 获取今天是当月第几天(1~31)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">//5. 写入Redis  BITSET key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计连续签到天数"><a href="#统计连续签到天数" class="headerlink" title="统计连续签到天数"></a>统计连续签到天数</h2><p>可以先用 BITFIELD GET 取出整个 BitMap 的十进制值。然后循环右移，依次用1 去和BitMap 的最后一位进行<code>与运算</code>，即可得知当前位数是否为 1 (已签到)，配合计数器完成连续 1的统计。</p>
<ul>
<li>获取本月到今天为止的所有签到数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITFIELD key GET u[dayOfMonth] 0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0</span></span><br><span class="line">List&lt;Long&gt; result = stringRedisTemplate.opsForValue()</span><br><span class="line">    .bitField(key, BitFieldSubCommands.create()</span><br><span class="line">            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth))</span><br><span class="line">              .valueAt(<span class="number">0</span>));</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        count++;</span><br><span class="line">    num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog (HLL) 是 Redis 的高级数据结构，使用概率学算法实现，可以用极低的内存实现不重复元素个数的统计。<br>用法和集合类似，插入元素、求不重复元素个数、合并多个 HLL 等<br>优点: 占用内存极低，不会超过 16 Kb<br>缺点: 基于概率统计，存在&lt; 0.81% 的误差<br>因此，它很适合用于 UV、PV 等数据量大、精度要求不高的统计。</p>
<ul>
<li>HyperLogLog(HLL)是从Loglog算法派生的概率算法，用户确定非常大的集合基数，而不需要存储其所有值，算法相关原理可以参考下面这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></li>
</ul>
<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><ul>
<li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li>
<li>本博客的首页侧边栏就有本站访客量和本站总访问量，对应的就是UV和PV</li>
<li>通常来说PV会比UV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素。</li>
<li>UV统计在服务端做会很麻烦，因为要判断该用户是否已经统计过了，需要将统计过的信息保存，但是如果每个访问的用户都保存到Redis中，那么数据库会非常恐怖，那么该如何处理呢？</li>
</ul>
<p>只需要把用户 id 用PFADD 添加到 HLL 中，用 PFCOUNT 求值即可: 还可以用 PFMERGE合并多天的统计，来估算整月的 UV</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFADD key element [element...]</span><br><span class="line">summary: Adds the specified elements to the specified HyperLogLog</span><br><span class="line"></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line">Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</span><br><span class="line"></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br><span class="line">lnternal commands for debugging HyperLogLog values</span><br></pre></td></tr></table></figure>

<p>测试百万数据的统计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] users = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        j = i % <span class="number">1000</span>;</span><br><span class="line">        users[j] = <span class="string">&quot;user_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">999</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;HLL&quot;</span>, users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;HLL&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f8aace.png" target="_blank"><img class="post-qr-code-img" src="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f8aace.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f91526.png" target="_blank"><img class="post-qr-code-img" src="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f91526.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://y-yiqi.github.io/posts/6a89.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Redis&amp;url=https://y-yiqi.github.io/posts/6a89.html&amp;pic=/img/default_cover.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">4</span></a><a class="post-meta__box__tags" href="/tags/Redis/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Redis<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://y-yiqi.github.io/posts/6a89.html">原创</a><a class="post-copyright-title"><span>Redis</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="https://y-yiqi.github.io">奕七</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="https://y-yiqi.github.io/posts/6a89.html">https://y-yiqi.github.io/posts/6a89.html</a></span><span class="copy-button" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://y-yiqi.github.io" target="_blank">奕七</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/43de.html"><img class="prev-cover" src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM</div></div></a></div><div class="next-post pull-right"><a href="/posts/c44e.html"><img class="next-cover" src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式简介</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c44e.html" title="设计模式简介"><img class="cover" src="/img/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-03-23</div><div class="title">设计模式简介</div></div></a></div><div><a href="/posts/5ea3.html" title="多线程"><img class="cover" src="/img/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-01-23</div><div class="title">多线程</div></div></a></div><div><a href="/posts/43de.html" title="JVM"><img class="cover" src="/img/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2020-01-31</div><div class="title">JVM</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author-info-top"> <div class="card-info-avatar"><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="writing_hand" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270d.png">✍️</g-emoji><span>on Studying</span></div></div></div></div><div class="author-info__sayhi" id="author-info__sayhi"></div><h1 class="author-info__name">奕七</h1><div class="author-info__description"></div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)"><span class="banner-button-text">了解更多</span><i class="anzhiyufont anzhiyu-icon-arrow-circle-right" style="font-size: 1.5rem"></i></a></div><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/l-yiqi" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="mailto:2392889869@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">Redis入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8BSQL%E5%92%8CNoSQL%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.</span> <span class="toc-text">关系型SQL和NoSQL对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">Redis特征</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">2.2.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">2.3.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">2.4.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">2.5.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorted-Set"><span class="toc-number">2.6.</span> <span class="toc-text">Sorted Set</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%ABSession%EF%BC%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">共享Session（单点登录）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1key"><span class="toc-number">3.2.1.</span> <span class="toc-text">设计key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E5%8F%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">选取数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%88%E9%87%87%E7%94%A8string%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">具体流程（采用string）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">3.2.4.</span> <span class="toc-text">补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">缓存更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.</span> <span class="toc-text">核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">4.4.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">4.5.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">4.6.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">4.6.1.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F"><span class="toc-number">4.6.2.</span> <span class="toc-text">逻辑过期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85Redis%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.7.</span> <span class="toc-text">封装Redis工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80id%E7%94%9F%E6%88%90"><span class="toc-number">5.</span> <span class="toc-text">分布式全局id生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">设计实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80"><span class="toc-number">6.</span> <span class="toc-text">秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">超卖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">解决方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">7.</span> <span class="toc-text">一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.</span> <span class="toc-text">单机实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.</span> <span class="toc-text">分布式实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text">Redis分布式锁实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E6%83%85%E5%86%B5"><span class="toc-number">7.3.3.</span> <span class="toc-text">分布式锁误删情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B51"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">情况1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B52-%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">情况2-原子性问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redisson"><span class="toc-number">8.</span> <span class="toc-text">分布式锁-Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">分布式锁-redission功能介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.2.</span> <span class="toc-text">可重入原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%87%8D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">8.1.3.</span> <span class="toc-text">如何重试获取锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%94%81%E6%8F%90%E5%89%8D%E8%B6%85%E6%97%B6%E9%87%8A%E6%94%BE"><span class="toc-number">8.1.4.</span> <span class="toc-text">如何防止锁提前超时释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.</span> <span class="toc-text">如何解决主从一致性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">秒杀业务优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">8.3.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.2.</span> <span class="toc-text">基于阻塞队列实现秒杀优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">9.2.</span> <span class="toc-text">什么是消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-number">9.3.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List-1"><span class="toc-number">9.3.1.</span> <span class="toc-text">List</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pub-x2F-Sub"><span class="toc-number">9.4.</span> <span class="toc-text">Pub&#x2F;Sub</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream"><span class="toc-number">10.</span> <span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4"><span class="toc-number">10.1.</span> <span class="toc-text">核心命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">10.1.1.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B6%88%E6%81%AF"><span class="toc-number">10.1.2.</span> <span class="toc-text">读取消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">10.2.</span> <span class="toc-text">基于Stream的消息队列-消费者组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">10.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ID-%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E7%9A%84%E8%B5%B7%E5%A7%8BID"><span class="toc-number">10.3.</span> <span class="toc-text">ID-  获取消息的起始ID </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%B8%8B%E5%8D%95"><span class="toc-number">10.3.1.</span> <span class="toc-text">实现异步下单</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-number">12.</span> <span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">13.</span> <span class="toc-text">排行榜</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">14.</span> <span class="toc-text">共同关注</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Feed%E6%B5%81%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-number">15.</span> <span class="toc-text">Feed流关注推送</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">15.1.</span> <span class="toc-text">实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%AF%BB%E6%89%A9%E6%95%A3%EF%BC%89"><span class="toc-number">15.1.1.</span> <span class="toc-text">拉模式（读扩散）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.1.2.</span> <span class="toc-text">推模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E6%8B%89%E7%BB%93%E5%90%88"><span class="toc-number">15.1.3.</span> <span class="toc-text">推拉结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">15.1.4.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.</span> <span class="toc-text">推模式实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98"><span class="toc-number">15.2.1.</span> <span class="toc-text">分页问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E6%94%B6%E4%BB%B6%E7%AE%B1"><span class="toc-number">15.3.</span> <span class="toc-text">实现分页查询收件箱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GEO%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97"><span class="toc-number">16.</span> <span class="toc-text">GEO地理坐标计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.1.</span> <span class="toc-text">GEO数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E5%8A%9F%E8%83%BD"><span class="toc-number">16.2.</span> <span class="toc-text">附近功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BitMap"><span class="toc-number">17.</span> <span class="toc-text">BitMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">17.1.</span> <span class="toc-text">签到功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.1.1.</span> <span class="toc-text">基本实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E5%A4%A9%E6%95%B0"><span class="toc-number">17.2.</span> <span class="toc-text">统计连续签到天数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">18.</span> <span class="toc-text">HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UV%E7%BB%9F%E8%AE%A1"><span class="toc-number">18.1.</span> <span class="toc-text">UV统计</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c44e.html" title="设计模式简介"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式简介"/></a><div class="content"><a class="title" href="/posts/c44e.html" title="设计模式简介">设计模式简介</a><time datetime="2020-03-23T09:09:13.000Z" title="发表于 2020-03-23 17:09:13">2020-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6a89.html" title="Redis"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/posts/6a89.html" title="Redis">Redis</a><time datetime="2020-02-23T09:09:13.000Z" title="发表于 2020-02-23 17:09:13">2020-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/43de.html" title="JVM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/posts/43de.html" title="JVM">JVM</a><time datetime="2020-01-31T09:09:13.000Z" title="发表于 2020-01-31 17:09:13">2020-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5ea3.html" title="多线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/posts/5ea3.html" title="多线程">多线程</a><time datetime="2020-01-23T09:09:13.000Z" title="发表于 2020-01-23 17:09:13">2020-01-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 奕七</div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://anzhiy.cn/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div></footer></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://img01.anzhiy.cn/useruploads/0/2023/05/27/647164424e62a.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/05/27/647164424e62a.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=7451835303&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-31px;"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="center-console" type="button" title="中控台"><i class="anzhiyufont anzhiyu-icon-fish"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><div id="console-music-bg"></div><meting-js id="8897204599" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="console"><div class="close-btn" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-xmark" style="font-size: 35px;"></i></div><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f8aace.png" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f8aace.png"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f91526.png" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/05/27/64716c8f91526.png"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>4</sup></a><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/03/"><span class="card-archive-list-date">三月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/02/"><span class="card-archive-list-date">二月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/01/"><span class="card-archive-list-date">一月 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="rm.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8897204599&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.2.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.2.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.2.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@17.3.1/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("05/15/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 奕七 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.2.0/source/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";</script><script>//动态标题
let leaveTitle = 'w(ﾟДﾟ)w 不要走！再看看嘛！';
let backTitle = '♪(^∇^*)欢迎回来！';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/catalog-bar/catalog-bar.js"></script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/categoryBar/categoryBar.js"></script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.switchDarkMode = function () {
  // Switch Between Light And Dark Mode
  const nowMode = document.documentElement.getAttribute("data-theme") === "dark" ? "dark" : "light";
  if (nowMode === "light") {
    activateDarkMode();
    saveToLocal.set("theme", "dark", 2);
    GLOBAL_CONFIG.Snackbar !== undefined && anzhiyu.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night);
    document.querySelector(".menu-darkmode-text").textContent = "浅色模式";
  } else {
    activateLightMode();
    saveToLocal.set("theme", "light", 2);
    GLOBAL_CONFIG.Snackbar !== undefined && anzhiyu.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day);
    document.querySelector(".menu-darkmode-text").textContent = "深色模式";
  }
  // handle some cases
  typeof runMermaid === "function" && window.runMermaid();
  rm.hideRightMenu();
  anzhiyu.darkModeStatus();
};

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      false
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      false
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function () {
  var url = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", rm.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref);
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc);
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | 奕七")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();

anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.0/icon/ali_iconfont_css.css"><script src="/js/sun_moon.js" async></script><script id="click-show-text" src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)
  window.anzhiyuScrollFnToDo && window.removeEventListener('scroll', anzhiyuScrollFnToDo)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>