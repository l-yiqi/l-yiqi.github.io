<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式简介</title>
      <link href="/posts/c44e.html"/>
      <url>/posts/c44e.html</url>
      
        <content type="html"><![CDATA[<p>在线阅读:</p><h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="设计模式的产生背景"><a href="#设计模式的产生背景" class="headerlink" title="设计模式的产生背景"></a>设计模式的产生背景</h2><p>软件设计模式的产生背景可以追溯到20世纪60年代和70年代，当时计算机软件行业开始迅速发展。随着软件规模的不断扩大，软件开发人员发现传统的软件设计方法已经无法满足需求，因为它们缺乏可重用性、可维护性和可扩展性。<br>在这种情况下，一些软件开发专家开始研究如何通过规范化软件开发过程来解决这些问题。他们提出了一些通用的设计思想和解决方案，这些思想和方案被称为“设计模式”。<br>设计模式是指在软件开发中经常遇到的⼀些重复性问题，通过对这些问题的总结、抽象、归纳和提炼，得到的⼀些<br>解决问题的通⽤⽅案。<br>学习和使⽤设计模式可以帮助开发⼈员提⾼代码的可重⽤性、可维护性、可扩展性和可读性，从⽽提⾼开发效率和<br>代码质量。<br>设计模式分为三⼤类：</p><ul><li>创建型模式：共5种：⼯⼚⽅法模式、抽象⼯⼚模式、单例模式、建造者模式、原型模式</li><li>结构型模式：共7种：适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式</li><li>⾏为型模式：共11种：策略模式、模板⽅法模式、观察者模式、责任链模式、访问者模式、中介者模式、迭代器模式、命令模式、状态模式、备忘录模式、解释器模式</li></ul><h2 id="学习设计模式的必要性"><a href="#学习设计模式的必要性" class="headerlink" title="学习设计模式的必要性"></a>学习设计模式的必要性</h2><p>学习设计模式对于软件开发人员来说是非常必要的，因为：</p><ol><li>提高代码质量：设计模式可以提高代码的可重用性、可维护性和可扩展性，从而提高代码的质量。 </li><li>减少开发时间：通过使用设计模式，开发人员可以更快地开发出高质量的软件，因为他们不需要从头开始编写每个功能。 </li><li>降低错误率：设计模式可以帮助开发人员避免一些常见的编程错误，例如类的继承关系不清晰、代码重复等。 </li><li>提高团队协作效率：设计模式可以使团队成员更容易地理解和共享代码，从而提高团队的协作效率。 </li><li>增强软件的可读性和可维护性：设计模式可以使代码更易于阅读和维护，因为它们提供了一种通用的方法来解决特定的问题。</li></ol><p>总之，学习设计模式可以帮助开发人员更好地理解软件开发的本质和原理，提高他们的技能水平和工作效率，从而更好地应对日益复杂的软件开发挑战。</p><h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><p>设计模式有几个原则，其中比较著名的有 SOLID 原则、GRASP 原则、KISS 原则和 DRY 原则等。以下是这些原则的简要介绍：</p><ol><li>SOLID原则：SOLID 原则是一组面向对象设计的基本原则，包括单一职责原则、开放封闭原则、里氏替换原则、接口隔离原则和依赖倒置原则等。这些原则可以帮助开发人员编写更加灵活、可扩展和可维护的代码。 </li><li>GRASP原则：GRASP 原则是一组面向对象设计的准则，包括高内聚、低耦合、专注点、创造者、信息专家、纯粹制造者、多态性和保持简单等。这些原则可以帮助开发人员更好地理解和设计系统架构。 </li><li>KISS原则：KISS 原则是一种简单性原则，即“保持简单和直接”。这个原则的核心思想是，设计应该保持简单和直接，避免过度复杂化和过度设计。这样可以提高代码的可读性、可维护性和可重用性。 </li><li>DRY原则：DRY 原则是一种“不要重复自己”的原则，即相同的代码不应该重复出现在不同的地方。这个原则可以提高代码的可维护性和可重用性，避免重复的劳动和错误。</li></ol><p>这些原则都是在面向对象编程中非常重要的指导原则，可以帮助开发人员编写更加高质量、可维护和可重用的代码。它们不仅适用于设计模式的使用，也适用于其他编程范式和技术的开发过程中。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>单一职责原则</strong>（Single Responsibility Principle，SRP）是SOLID原则中的一条，指一个类或模块应该只有一个责任。具体来说，就是<strong>一个类或模块只负责一项功能或职责，不承担过多的职责</strong>，以提高其内聚性和可维护性。<br>单一职责原则的核心思想是将不同的职责分离开来，避免一个类或模块承担过多的职责，导致代码混乱、难以维护和扩展。如果一个类或模块承担了过多的职责，那么它就会变得臃肿、复杂、难以测试和修改。相反，如果每个类或模块只负责一项职责，那么它就会变得简单、清晰、易于理解和修改。<br>在实践中，如何判断一个类或模块是否遵循单一职责原则呢？可以通过以下几点来判断：</p><ol><li><strong>类或模块的职责是否明确</strong>：一个类或模块应该有一个明确的职责，而不是承担多个职责。如果一个类或模块有多个职责，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的方法数量是否合理</strong>：一个类或模块的方法数量应该与其职责相匹配。如果一个类或模块有大量的方法，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的复杂度是否合理</strong>：一个类或模块的复杂度应该与其职责相匹配。如果一个类或模块过于复杂，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的修改频率是否合理</strong>：一个类或模块的修改频率应该与其职责相匹配。如果一个类或模块经常需要修改，那么就需要考虑将其分解成多个类或模块。</li></ol><p>单一职责原则是面向对象编程中非常重要的原则之一，它可以提高代码的内聚性、可维护性和可扩展性。一个类或模块只负责一项职责，可以使它的职责更加明确、方法数量更加合理、复杂度更加合理、修改频率更加合理，从而使代码更加简单、清晰、易于理解和修改。在实践中，开发人员应该尽可能遵循单一职责原则，将不同的职责分离开来，避免一个类或模块承担过多的职责，导致代码难以维护和扩展。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>开闭原则</strong>(<strong>Open Closed Principle</strong>,<strong>OCP</strong>)是面向对象设计中的一项基本原则，它的核心思想是：对于一个软件实体(类、模块、函数等),应该<strong>对扩展开放，对修改关闭</strong>。<br>具体来说，开闭原则包括以下两点：</p><ol><li><strong>对扩展开放</strong>(Open for Extension):一个软件实体应该对新的功能或需求开放，也就是说，如果需要增加新的功能，应该通过添加新的方法、属性或者类来实现，而不是修改原有代码。这样可以保证代码的可扩展性和灵活性，同时也方便了维护和升级。 </li><li><strong>对修改封闭</strong>(Closed for Modification):一个软件实体不应该被修改，也就是说，如果需要修改已有的功能或需求，应该通过创建新的类、方法或者属性来实现，而不是修改原有代码。这样可以避免代码的不一致性和耦合性，提高了代码的可维护性和稳定性。</li></ol><p>开闭原则可以帮助开发人员编写出易于扩展和维护的高质量代码，同时也符合面向对象编程的基本原则之一——封装。通过遵循开闭原则，开发人员可以更好地管理软件实体的变化，使得系统更加健壮、可靠和可维护。</p><h2 id="里式替换原则📍"><a href="#里式替换原则📍" class="headerlink" title="里式替换原则📍"></a>里式替换原则📍</h2><p><strong>里式替换原则</strong>(Liskov Substitution Principle,LSP)是面向对象设计中的一项基本原则。<br><strong>通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</strong><br>由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h2 id="依赖倒装原则"><a href="#依赖倒装原则" class="headerlink" title="依赖倒装原则"></a>依赖倒装原则</h2><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节，细节应该依赖抽象；</li><li>依赖倒装的中心思想就是：面向接口编程；<blockquote><p><a href="https://blog.csdn.net/weixin_39327556/article/details/125250988?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BE%9D%E8%B5%96%E5%80%92%E8%A3%85%E5%8E%9F%E5%88%99&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-125250988.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">引用例子原文</a></p></blockquote></li></ul><p>场景：人们之间的沟通方式（电话、微信）</p><ul><li>错误设计（新增要修改代码，不好维护）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684569254312-87c9fd29-c94c-431c-ba35-9ccf4b39adc7.png#averageHue=%23fcfcfc&clientId=u03d49c43-b92a-4&from=paste&height=293&id=ue8eb6ba7&originHeight=396&originWidth=617&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=25308&status=done&style=none&taskId=u390229fd-9f33-45ac-b535-2270251f042&title=&width=457.0370693232974" alt="image.png"></p><ul><li>正确设计</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684569296519-f7c9e6dc-77aa-42f8-b91c-9c15fcc58d2f.png#averageHue=%23fcfbf9&clientId=u03d49c43-b92a-4&from=paste&id=ue276833a&originHeight=633&originWidth=782&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=35508&status=done&style=none&taskId=uf459a998-33df-4aa9-9f4c-04e60d61b70&title=" alt="image.png"></p><ul><li>peison类属于高层模块，不应该依赖于低层模块，而是要依赖于抽象。</li><li>细节（Email、Weixin）依赖抽象（IReciver）。</li></ul><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。<br><strong>每一个接口应该承担一种相对独立的角色，不干不该干的事情，干该干的事请。</strong><br><strong>在使用接口隔离原则时我们要控制接口的颗粒度，颗粒度不能太大，也不能太小。如果太小就会造成接口泛滥，不利于维护；接口入如果太大就会违背接口隔离原则，灵活性较差，使用起来不方便</strong>。一般来说接口中仅包含某业务模块的方法即可，不应该有其他业务模块的方法。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote><p><a href="https://blog.csdn.net/qq_34222160/article/details/123539464?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168456952816782425178194%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168456952816782425178194&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123539464-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99&spm=1018.2226.3001.4187">原文</a></p></blockquote><p>迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少的与其他实体发生相互作用。<br>如果一个系统满足迪米特法则，那么当其中一个软件实体发生变化时，就会尽量少的影响其他软件实体，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可以降低系统的耦合度，使类与类之间保持松耦合状态</strong>。<br>迪米特法则还有几种定义形式，包括：不要和”陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><ul><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。</li><li>当前对象创建的对象</li></ul><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则（Composition Over Inheritance，COI）是面向对象编程中的一个原则，它强调使用组合（Composition）而不是继承（Inheritance）来实现代码的复用。<br><strong>合成&#x2F;聚合复用原则是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的</strong>。<br>简述为：<strong>要尽量使用合成&#x2F;聚合，尽量不要使用继承</strong>。</p><ul><li>聚合has-A</li><li>组合contains-A</li><li>继承is-A</li></ul><p>具体来说，合成复用原则可以通过以下几点来实现：</p><ol><li>将类的<strong>功能分解</strong>为较小的粒度：将类的功能分解为较小的粒度，每个类只负责一项职责，这样可以提高代码的内聚性和可维护性。 </li><li>使用<strong>组合</strong>来实现代码复用：根据需要，将现有类的实例组合起来创建新的功能。这样可以使代码更加灵活、可扩展和可维护，同时避免了继承带来的一些问题。 </li><li><strong>优先使用接口</strong>而不是实现类：在使用组合时，优先使用接口而不是实现类。这样可以使代码更加灵活、可扩展和可维护，同时避免了依赖具体实现类带来的一些问题（如紧耦合、难以替换等）。 </li><li><strong>避免过度设计</strong>：在使用组合时，避免过度设计。只有当需要复用的功能足够复杂时才使用组合，否则可以直接在当前类中实现。过度设计会增加代码的复杂性和维护成本。</li></ol><p>合成复用原则是面向对象编程中非常重要的原则之一，它可以提高代码的灵活性、可扩展性和可维护性。使用组合而不是继承来实现代码的复用，可以避免继承带来的一些问题，如紧耦合、派生类的脆弱性等。在实践中，开发人员应该尽可能遵循合成复用原则，将现有的类组合起来创建新的功能，同时避免过度设计和依赖具体实现类，从而使代码更加灵活、可扩展和可维护。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/posts/6a89.html"/>
      <url>/posts/6a89.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串、哈希表、列表、集合、有序集合、位图、超级日志和地理空间索引等。与其他key-value存储不同的是，Redis提供了更为复杂的数据结构并且提供对他们的原子性操作</p><h3 id="关系型SQL和NoSQL对比"><a href="#关系型SQL和NoSQL对比" class="headerlink" title="关系型SQL和NoSQL对比"></a>关系型SQL和NoSQL对比</h3><p>关系型SQL数据库和NoSQL数据库是两种不同的数据库类型，它们在很多方面都有所不同。以下是它们的主要对比：</p><ol><li>数据模型<br>关系型SQL数据库使用表格来存储和组织数据，数据之间的关系通过外键来建立。而NoSQL数据库则使用不同的数据模型，如文档型、键值型、列族型、图形数据库等。 </li><li>数据库设计<br>关系型SQL数据库需要在设计时预先定义表格的结构和关系，而NoSQL数据库则更加灵活，可以在开发过程中根据需要动态添加数据。 </li><li>数据一致性<br>关系型SQL数据库强调数据一致性，支持ACID事务，保证数据的完整性和一致性。而NoSQL数据库则更加注重数据的可扩展性和分布式存储，在数据一致性上可能有所牺牲。 </li><li>读写性能<br>NoSQL数据库在读写性能上通常比关系型SQL数据库更好，因为NoSQL数据库可以水平扩展，支持分布式存储和处理，而关系型SQL数据库则更适合处理复杂的查询和事务操作。 </li><li>数据处理方式<br>关系型SQL数据库通常使用结构化查询语言（SQL）来处理数据，而NoSQL数据库则更加灵活，可以使用各种不同的数据处理方式和编程语言。 </li><li>数据存储方式<br>关系型SQL数据库通常使用磁盘存储，而NoSQL数据库则通常使用内存存储或者混合存储。 </li><li>数据复制和备份<br>NoSQL数据库通常具有更好的数据复制和备份功能，因为它们支持分布式存储和处理，而关系型SQL数据库则需要更多的复杂性和资源来实现数据复制和备份。</li></ol><p>总的来说，关系型SQL数据库适合处理结构化数据和需要保证数据一致性的场景，而NoSQL数据库则适合处理大量非结构化或半结构化数据，需要高可扩展性和高读写性能的场景。</p><h3 id="Redis特征"><a href="#Redis特征" class="headerlink" title="Redis特征"></a>Redis特征</h3><p>Redis是一种开源的内存数据存储系统，它具有以下几个特征：</p><ol><li>内存存储<br>Redis将所有数据都存储在内存中，这使得它具有极快的读写速度。同时，Redis也支持将数据持久化到磁盘中，以保证数据的可靠性。 </li><li>键值存储<br>Redis是一种键值存储系统，它支持多种数据类型，如字符串、列表、哈希表、集合等。用户可以根据需要选择合适的数据类型存储数据。 </li><li>高性能<br>Redis具有非常高的读写性能，它可以处理数以百万计的操作，每秒钟可以处理数百万个键值对的读写操作。 </li><li>支持多种数据结构<br>Redis支持多种数据结构，如字符串、列表、哈希表、集合、有序集合等。这些数据结构可以满足不同的数据处理需求，同时也可以提高数据处理效率。 </li><li>支持高级数据操作<br>Redis提供了许多高级数据操作，如事务、发布&#x2F;订阅、Lua脚本、自动过期等。这些功能可以帮助用户更方便地进行数据处理和管理。 </li><li>可扩展性<br>Redis具有良好的可扩展性，它支持分布式存储和集群模式，用户可以根据需要将数据分布到多个节点上，以实现更高的性能和可靠性。 </li><li>简单易用<br>Redis的命令和API非常简单易用，用户可以轻松地学习和使用Redis。同时，Redis还提供了丰富的客户端库和工具，可以方便地集成到各种应用中。</li></ol><p>总的来说，Redis具有高性能、灵活性、可扩展性和简单易用等特点，适用于多种场景，如缓存、消息队列、计数器、排行榜等。</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Redis 是一种基于内存的数据存储系统，它支持多种数据类型的存储和操作。以下是 Redis 的基本数据类型：</p><ol><li>String 类型：字符串类型是 Redis 中最基本的数据类型，可以存储任意类型的字符串，包括数字、浮点数、二进制数据等。 </li><li>Hash 类型：哈希类型用于存储键值对，其中键和值都是字符串类型。哈希类型适用于存储对象类型的数据，如存储用户信息等。 </li><li>List 类型：列表类型用于存储一个有序的字符串列表，其中每个元素都可以是字符串类型。列表类型适用于存储有序的数据集合，如存储日志数据等。 </li><li>Set 类型：集合类型用于存储一个<strong>无序</strong>的字符串集合，其中每个元素都是唯一的字符串类型。集合类型适用于存储无序的数据集合，如存储用户标签等。 </li><li>Sorted Set 类型：有序集合类型用于存储一个<strong>有序</strong>的字符串集合，其中每个元素都有一个分数值，根据分数值进行排序。有序集合类型适用于存储按照分数排序的数据集合，如存储排行榜等。</li></ol><p>除了上述基本数据类型，Redis 还提供了一些高级数据结构，如 Bitmap、HyperLogLog、GeoHash 等，用于支持更复杂的数据存储和操作需求。</p><p>需要注意的是，Redis 是一种基于内存的数据存储系统，因此在存储大量数据时需要注意内存使用情况，避免因为内存不足而导致系统崩溃。同时，为了保证数据的可靠性，需要定期对数据进行备份和恢复操作。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>以下是一些常用的 String 类型的命令：</p><ol><li>SET key value：设置 key 的值为 value。</li><li>GET key：获取 key 的值。</li><li>INCR key：将 key 的值增加 1。</li><li>DECR key：将 key 的值减少 1。</li><li>APPEND key value：将 value 追加到 key 的值末尾。</li><li>STRLEN key：获取 key 的值的长度。</li><li>MSET key1 value1 key2 value2 …：同时设置多个 key 的值。</li><li>MGET key1 key2 …：同时获取多个 key 的值。</li><li>SETEX key seconds value：设置 key 的值为 value，并且设置 key 的过期时间为 seconds 秒。</li><li>GETSET key value：将 key 的值设置为 value，并返回 key 原来的值。</li></ol><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash 是 Redis 的一种基本数据类型，用于存储键值对，其中键和值都是字符串类型。以下是一些常用的 Hash 命令：</p><ol><li>HSET key field value：设置 key 中指定 field 的值为 value。 </li><li>HGET key field：获取 key 中指定 field 的值。 </li><li>HMSET key field1 value1 field2 value2 …：同时设置 key 中多个 field 的值。 </li><li>HMGET key field1 field2 …：同时获取 key 中多个 field 的值。 </li><li>HLEN key：获取 key 中 field 的数量。 </li><li>HDEL key field1 field2 …：删除 key 中指定的 field。 </li><li>HEXISTS key field：判断 key 中是否存在指定的 field。 </li><li>HKEYS key：获取 key 中所有的 field。 </li><li>HVALS key：获取 key 中所有的 value。 </li><li>HINCRBY key field increment：将 key 中指定的 field 的值增加 increment。</li></ol><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 是 Redis 的一种基本数据类型，用于存储一个有序的字符串列表，其中每个元素都可以是字符串类型。以下是一些常用的 List 命令：</p><ol><li>LPUSH key value1 value2 …：将一个或多个值插入到 key 的头部。 </li><li>RPUSH key value1 value2 …：将一个或多个值插入到 key 的尾部。 </li><li>LPOP key：移除并返回 key 的头部元素。 </li><li>RPOP key：移除并返回 key 的尾部元素。 </li><li>LINDEX key index：获取 key 中指定索引位置的元素。 </li><li>LLEN key：获取 key 中元素的数量。 </li><li>LRANGE key start stop：获取 key 中指定范围内的元素。 </li><li>LREM key count value：从 key 中移除指定数量的元素。 </li><li>LSET key index value：将 key 中指定索引位置的元素设置为 value。 </li><li>LTRIM key start stop：截取 key 中指定范围内的元素。</li></ol><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 是 Redis 的一种基本数据类型，用于存储一个<strong>无序</strong>的、<strong>不重复</strong>的字符串集合。以下是一些常用的 Set 命令：</p><ol><li>SADD key member1 member2 …：向 key 中添加一个或多个 member 元素，如果 member 已经存在于集合中，则不进行任何操作。 </li><li>SREM key member1 member2 …：从 key 中移除一个或多个 member 元素。 </li><li>SMEMBERS key：返回 key 中所有的元素。 </li><li>SISMEMBER key member：判断 member 是否存在于 key 中。 </li><li>SCARD key：返回 key 中元素的数量。 </li><li>SPOP key：随机移除并返回 key 中的一个元素。 </li><li>SRANDMEMBER key [count]：随机返回 key 中的一个或多个元素，如果 count 参数为正数，则返回的元素不重复，如果为负数，则返回的元素可能重复。 </li><li>SINTER key1 key2 …：返回多个集合的<strong>交集</strong>。 </li><li>SUNION key1 key2 …：返回多个集合的<strong>并集</strong>。 </li><li>SDIFF key1 key2 …：返回多个集合的<strong>差集</strong>。</li></ol><p>这些命令可以用于对 Redis 中的 Set 类型数据进行基本的存储和操作。除了这些基本命令，Redis 还提供了一些高级的 Set 命令，如 SINTERSTORE、SUNIONSTORE、SDIFFSTORE 等，可以根据具体的需求选择合适的命令进行操作。</p><p>需要注意的是，Set 类型是一个无序的数据结构，可以支持快速的插入、删除和判断元素是否存在的操作，但是在获取所有元素时需要进行扫描，效率较低。此外，当 Set 类型的键中存储的元素数量较多时，会影响 Redis 的性能和内存使用情况。因此，在使用 Set 类型时，应该根据具体的需求选择合适的命令进行操作，以及避免在 Set 类型的键中存储过多的元素。</p><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>Sorted Set 是 Redis 的一种基本数据类型，用于存储一个有序的、不重复的字符串集合，其中每个元素都有一个对应的分数，可以根据分数的大小进行排序。以下是一些常用的 Sorted Set 命令：</p><ol><li>ZADD key score1 member1 score2 member2 …：向 key 中添加一个或多个 member 元素，每个元素都有一个对应的分数 <strong>score</strong>。 </li><li>ZREM key member1 member2 …：从 key 中移除一个或多个 member 元素。 </li><li>ZRANGE key start stop [WITHSCORES]：返回 key 中指定范围内的元素，按照分数从小到大排序，如果指定了 WITHSCORES 参数，则同时返回元素的分数。 </li><li>ZREVRANGE key start stop [WITHSCORES]：返回 key 中指定范围内的元素，按照分数从大到小排序，如果指定了 WITHSCORES 参数，则同时返回元素的分数。 </li><li>ZSCORE key member：返回 member 在 key 中的分数。 </li><li>ZCARD key：返回 key 中元素的数量。 </li><li>ZCOUNT key min max：返回 key 中分数在指定范围内的元素数量。 </li><li>ZRANK key member：返回 member 在 key 中按照分数排序后的排名，排名从 0 开始。 </li><li>ZREVRANK key member：返回 member 在 key 中按照分数排序后的倒序排名，排名从 0 开始。 </li><li>ZINCRBY key increment member：将 member 在 key 中的分数增加 increment。</li></ol><p>这些命令可以用于对 Redis 中的 Sorted Set 类型数据进行基本的存储和操作。除了这些基本命令，Redis 还提供了一些高级的 Sorted Set 命令，如 ZINTERSTORE、ZUNIONSTORE、ZREMRANGEBYRANK、ZREMRANGEBYSCORE 等，可以根据具体的需求选择合适的命令进行操作。<br>需要注意的是，Sorted Set 类型是一个有序的数据结构，可以支持根据分数进行范围查找、排序和计算排名等操作，但是在获取所有元素时需要进行扫描，效率较低。此外，当 Sorted Set 类型的键中存储的元素数量较多时，会影响 Redis 的性能和内存使用情况。因此，在使用 Sorted Set 类型时，应该根据具体的需求选择合适的命令进行操作，以及避免在 Sorted Set 类型的键中存储过多的元素。</p><h1 id="共享Session（单点登录）"><a href="#共享Session（单点登录）" class="headerlink" title="共享Session（单点登录）"></a>共享Session（单点登录）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>共享session是指在多台服务器之间共享session数据。这样做的目的是为了支持<code>负载均衡</code>，即当多台服务器使用同一套网站代码时，用户请求被分发到不同的服务器上。这种情况下，用户第一次请求时，在一台服务器上生成了sessionid，但在其他服务器上也需要访问该session数据。<br>例如，如果一个用户在网站上登录了，他的登录信息会被存储在session中。如果该用户的下一个请求被分发到另一台服务器上，那么这台服务器也需要访问该用户的登录信息。因此，需要在多台服务器之间共享session数据。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679480448867-eddb1974-7a41-4a0b-8887-ca8c9ef8587a.png#averageHue=%23f6f4f4&clientId=ua6475701-a0dd-4&from=paste&height=503&id=u6872694b&name=image.png&originHeight=754&originWidth=1723&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=346019&status=done&style=none&taskId=u695756d8-dc4d-40ac-aabd-ba629eb843a&title=&width=1148.6666666666667#averageHue=%23f6f4f4&id=jXvcH&originHeight=754&originWidth=1723&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="设计key"><a href="#设计key" class="headerlink" title="设计key"></a>设计key</h3><p>随机生成token</p><h3 id="选取数据结构"><a href="#选取数据结构" class="headerlink" title="选取数据结构"></a>选取数据结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679480882862-adcc8755-03ce-46cd-a9bf-8f126905780f.png#averageHue=%23f2e9e5&clientId=ua6475701-a0dd-4&from=paste&height=443&id=u9db5000e&name=image.png&originHeight=664&originWidth=1019&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=192073&status=done&style=none&taskId=u6f68a962-b81c-4d36-b4d6-bb75f184333&title=&width=679.3333333333334#averageHue=%23f2e9e5&id=mJ8qb&originHeight=664&originWidth=1019&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>两种方案：</p><ol><li>先在程序中将对象进行JSON序列化，在以string类型写入</li><li>直接以hash数据结构写入🔥</li></ol><h3 id="具体流程（采用string）"><a href="#具体流程（采用string）" class="headerlink" title="具体流程（采用string）"></a>具体流程（采用string）</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679481109556-9e7134c4-75be-4564-ba6b-e39c40b1864e.png#averageHue=%23f0ecec&clientId=ua6475701-a0dd-4&from=paste&height=603&id=u40a8c449&name=image.png&originHeight=904&originWidth=1726&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=451855&status=done&style=none&taskId=u003b9837-6127-4427-8491-f8a810e15d1&title=&width=1150.6666666666667#averageHue=%23f0ecec&id=K6VMK&originHeight=904&originWidth=1726&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><ul><li>存储session<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 将User对象转为HashMap存储</span></span><br><span class="line"><span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7存储</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 设置token有效期</span></span><br><span class="line">stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回token</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(token);</span><br></pre></td></tr></table></figure>注意StringRedisTemplate要求类型是String，但是我们的UserDto里面有一个Long类型的id，所以需要先进行转换<br><strong>注意事项</strong>：</li></ul><ol><li>存入Redis的数据一定要设置过期时间</li><li>存入Redis的数据尽量精简和安全，比如用户信息脱敏</li><li><strong>已登录用户访问系统后，要刷新token过期时间（续期）。访问任何路径都要刷新token，不然时间到了会被强制退出</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679482336011-04410982-ea2b-46c8-a76e-991ecec2e229.png#averageHue=%23e9d5d2&clientId=ua6475701-a0dd-4&from=paste&height=357&id=uf30981b2&name=image.png&originHeight=535&originWidth=1046&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=121501&status=done&style=none&taskId=u72935797-95ba-4740-9cb2-1ab8b2bd387&title=&width=697.3333333333334#averageHue=%23e9d5d2&id=Ouo4R&originHeight=535&originWidth=1046&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><blockquote><p>get:拦截器是手动创建的，不是SpringBoot构建的，不会帮我们注入依赖</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679482546551-3a6efe2c-5c8b-4a3e-8aea-0d5340c9bb6d.png#averageHue=%23faf9f6&clientId=ua6475701-a0dd-4&from=paste&height=288&id=ueaf4171a&name=image.png&originHeight=432&originWidth=1617&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=116557&status=done&style=none&taskId=u32dc2a1a-a96b-44b2-bccc-11993ba52f1&title=&width=1078#averageHue=%23faf9f6&id=VAYYz&originHeight=432&originWidth=1617&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。<br><strong>UserHolder是一个ThreadLocal对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//这里并不是自动装配，因为RefreshTokenInterceptor是我们手动在WebConfig里new出来的</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 如果token是空，直接放行，交给LoginInterceptor处理</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        <span class="comment">//3. 基于token获取Redis中的用户数据</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">//4. 判断用户是否存在，不存在，也放行，交给LoginInterceptor</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 将查询到的Hash数据转化为UserDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//6. 将用户信息保存到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">//7. 刷新tokenTTL，这里的存活时间根据需要自己设置，这里的常量值我改为了30分钟</span></span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不存在则拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//到了这里才能自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RefreshTokenInterceptor是我们手动new出来的</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意toke拦截器要在登录拦截器前执行，一直方法是吧token拦截器写在前面，一种是order，数字越小，顺序越早</p></blockquote><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>缓存(Cache)就是数据交换的缓冲区，俗称的缓存就是缓冲区内的数据，一般从数据库中获取，存储于本地<br>缓存是一种用于提高系统性能的技术。它可以通过将数据存储在内存中，从而减少对磁盘或网络的访问，来提高数据访问速度。这样，当需要访问相同的数据时，可以直接从缓存中获取，而不需要再次访问磁盘或网络¹。</p><p>缓存的主要优点是可以实现高性能和高并发。它可以减少对数据库或其他外部资源的访问，从而减少系统的响应时间。此外，缓存还可以减少服务器的负载，提高系统的可扩展性¹。</p><p>但是，使用缓存也有一些潜在的风险。如果缓存中的数据过期或不一致，可能会导致系统出现错误。因此，在使用缓存时，需要注意数据的有效性和一致性。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol><li>暂无缓存，从数据库中读，然后设置（更新）缓存</li><li>一有缓存，直接读缓存</li></ol><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><ul><li><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</li><li><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</li><li><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679487448289-73fae28e-fb31-4c4e-81b2-46614b2e5949.png#averageHue=%23e1d0d0&clientId=ua6475701-a0dd-4&from=paste&height=489&id=u0f93aca8&name=image.png&originHeight=734&originWidth=1613&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=307125&status=done&style=none&taskId=ue2d34ff4-0671-45a6-adc9-b05d113cd46&title=&width=1075.3333333333333#averageHue=%23e1d0d0&id=dKzOA&originHeight=734&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>主动更新缓存是指在数据发生变化时，主动更新缓存中的数据，以保证缓存中的数据与数据库中的数据一致。常见的主动更新缓存的方式有以下几种:</p><ol><li><strong>读写操作同时进行</strong>: 在执行写操作时，同时更新缓存中的数据。这种方式可以保证缓存中的数据与数据库中的数据一致，但可能会增加写操作的延迟。</li><li><strong>定时更新</strong>: 定时从数据库中读取数据，更新缓存中的数据。这种方式可以减少写操作的延迟，但可能会导致缓存中的数据与数据库中的数据不一致。</li><li><strong>异步更新</strong>: 在执行写操作后，异步更新缓存中的数据。这种方式可以减少写操作的延迟，并且可以保证缓存中的数据与数据库中的数据一致，但需要额外的线程来执行异步更新。</li></ol><p>选择删除缓存还是更新缓存？<br>建议删除缓存，等待下次查询自动设置缓存，做到随用随取，可以避免每次更新数据库后都更新缓存的无效操作</p><p>先删除缓存还是先操作数据库？</p><ol><li>更新缓存：每次更新数据库都要更新缓存–写多读少时会导致多次无效写操作</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1682081700363-f5e5f90b-91d6-4ad6-a300-e615bd26d03b.png#averageHue=%23c8f8f8&clientId=uf8948dec-d357-4&from=paste&height=747&id=ud617427c&originHeight=1120&originWidth=1213&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=460605&status=done&style=none&taskId=u88ad9f45-166f-4836-9af4-22c4a98581b&title=&width=808.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1682081680894-7a9a574b-4be8-4da0-8297-096f5834522a.png#averageHue=%23c9f8f8&clientId=uf8948dec-d357-4&from=paste&height=733&id=u6c1124f0&originHeight=1099&originWidth=1263&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=481203&status=done&style=none&taskId=ue8eeb0a8-7a6c-477b-9269-2ebb0cb197e&title=&width=842" alt="image.png"><br>在更新数据时，通常建议先操作数据库，然后再删除缓存。这样做的原因是为了保证数据的一致性。<br>如果先删除缓存，那么在删除缓存和更新数据库之间，可能会有一段时间缓存中没有数据。这种情况下，如果有请求访问该数据，那么需要从数据库中读取数据。但是，如果此时数据库中的数据还没有更新，那么请求会读取到旧的数据。<br>如果先操作数据库，然后再删除缓存，那么可以避免上述问题。即使在更新数据库和删除缓存之间有请求访问该数据，也会从缓存中读取到旧的数据。当缓存被删除后，下一个请求会从数据库中读取到新的数据。<br>因此，在更新数据时，通常建议先操作数据库，然后再删除缓存。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>缓存穿透、缓存击穿和缓存雪崩都是缓存中的常见问题，它们之间的区别如下：</p><ol><li>缓存穿透</li></ol><p>当请求的数据在缓存中<code>不存在</code>，且数据库中也<code>不存在</code>该数据时，就会发生缓存穿透。这种情况下，每次请求都需要从数据库中查询数据，导致数据库压力过大，可能会引起雪崩效应。<br>解决方法：可以在缓存中设置一个<code>空值</code>或者布尔值，表示该数据不存在，这样下次请求时就会直接返回空值，避免了对数据库的查询。</p><ol start="2"><li>缓存击穿</li></ol><p>当一个热点数据过期或者被删除，而此时有大量的请求访问这个数据时，就会发生缓存击穿。这种情况下，大量的请求都会访问数据库，导致数据库压力过大，可能会引起雪崩效应。<br>解决方法：可以在缓存中设置一个短暂的过期时间，当缓存过期时，先返回<code>旧值</code>，并异步更新缓存，避免了对数据库的大量查询。</p><ol start="3"><li>缓存雪崩</li></ol><p>当缓存中的大量数据同时过期失效，导致大量请求都落到数据库上时，就会发生缓存雪崩。这种情况下，数据库的压力会剧增，可能会导致数据库宕机或崩溃。<br>解决方法：可以在缓存中设置不同的过期时间，避免所有数据同时失效。另外，可以采用多级缓存、热点数据预加载等方式来避免缓存雪崩。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。<br>常见的解决方案有两种：</p><ul><li>缓存空对象 <ul><li>优点：实现简单，维护方便</li><li>缺点： <ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤 <ul><li>优点：内存占用较少，没有多余key</li><li>缺点： <ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了<br><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，<br>假设布隆过滤器判断这个数据不存在，则直接返回<br>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679538039906-ff893fe0-89fb-42af-95fa-ee8280ce19fd.png#averageHue=%23f8f6f5&clientId=u13b1c3e4-cb39-4&from=paste&height=549&id=ue33c9b2a&name=image.png&originHeight=823&originWidth=1470&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=263421&status=done&style=none&taskId=ued9c7128-e471-4561-b53c-1a47059694c&title=&width=980#averageHue=%23f8f6f5&id=FudEK&originHeight=823&originWidth=1470&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>预防做法：</p><ol><li>增强对请求数据的校验</li><li>增强对数据格式的控制</li><li>增强id复杂度，避免被猜测id规律（可以采用雪花算法）</li><li>增强用户权限校验</li><li>限流</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679538112846-963b5504-7434-4c90-87f2-3c9e7baba3b1.png#averageHue=%23eeebeb&clientId=u13b1c3e4-cb39-4&from=paste&height=472&id=u68222c95&name=image.png&originHeight=708&originWidth=1676&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=365890&status=done&style=none&taskId=ucf0c4b03-9058-4b40-9275-c076e9660cc&title=&width=1117.3333333333333#averageHue=%23eeebeb&id=L1vgz&originHeight=708&originWidth=1676&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果查询到的是空字符串，则说明是我们缓存的空数据</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则去数据库中查</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//查不到，则将空字符串写入Redis</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的常量值是2分钟</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li>缓存雪崩是指在同一时间段，<code>大量缓存的key同时失效</code>，或者<code>Redis服务宕机</code>，导致大量请求到达数据库，带来巨大压力</li><li>解决方案 <ul><li>给不同的Key的TTL添加随机值，让其在不同时间段分批失效</li><li>利用Redis集群提高服务的可用性（使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。 ）</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存（浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库）</li></ul></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li>缓存击穿也叫<code>热点Key</code>问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击</li><li>举个不太恰当的例子：一件秒杀中的商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿</li><li>逻辑分析：假设线程1在查询缓存之后未命中，本来应该去查询数据库，重建缓存数据，完成这些之后，其他线程也就能从缓存中加载这些数据了。但是在线程1还未执行完毕时，又进来了线程2、3、4同时来访问当前方法，那么这些线程都不能从缓存中查询到数据，那么他们就会在同一时刻访问数据库，执行SQL语句查询，对数据库访问压力过大</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681644333844-a9e5cafb-f3a3-484b-897d-dd824dd1ae56.png#averageHue=%23f3f2eb&clientId=u58a9a4fb-4925-4&from=paste&height=242&id=uffb2972d&originHeight=363&originWidth=616&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=100557&status=done&style=none&taskId=uec3e7ddc-1c40-47b0-919c-eb6ef61e228&title=&width=410.6666666666667" alt="image.png"></p><ul><li>常见的解决方案有两种 <ol><li><strong>互斥锁</strong>：只有一个线程复制缓存重建，其余线程拿不到锁，就等着</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679543412026-b1e927ec-b533-4d63-aac7-aca4447a09e7.png#averageHue=%23ebe9e8&clientId=u1ca47393-cf9e-4&from=paste&id=u1246c27a&name=image.png&originHeight=850&originWidth=655&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=270192&status=done&style=none&taskId=ucf3a57ca-cd09-4be5-84d5-8b200a3d2ca&title=#averageHue=%23ebe9e8&id=ltdNe&originHeight=850&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><ol start="2"><li><strong>逻辑过期：</strong>key设置为永不过期，在value中添加其它字段记录过期时间，业务中根据过期时间判断缓存是否有效；如果缓存已经过去，只有一个线程能抢到锁，开启独立线程去更显缓存，然后立即返回过期数据；其它抢不到锁的线程也立即返回过期数据，不用等锁释放</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679543465399-9545689e-2892-457a-9b33-d7565a9c85fa.png#averageHue=%23e8e4e3&clientId=u1ca47393-cf9e-4&from=paste&id=u9732ff99&name=image.png&originHeight=757&originWidth=871&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=301880&status=done&style=none&taskId=ua37f95c8-2395-4d6d-994f-b7d6c43d6be&title=#averageHue=%23e8e4e3&id=I5wEH&originHeight=757&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>方案优缺点对比<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681644716598-c59d6dc7-e717-4c8a-9e74-74029127550c.png#averageHue=%23f6f5f3&clientId=u58a9a4fb-4925-4&from=paste&height=264&id=u61bbc144&originHeight=396&originWidth=988&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=101831&status=done&style=none&taskId=uec023c45-9c34-411e-b2b1-cd4a443b723&title=&width=658.6666666666666" alt="image.png"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679543534010-f84388df-7ad3-4258-933e-8bebdbf75aed.png#averageHue=%23faf5f5&clientId=u1ca47393-cf9e-4&from=paste&id=u2536802d&name=image.png&originHeight=749&originWidth=1076&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=279114&status=done&style=none&taskId=u37a34493-9b09-4c3a-837a-cbd030430b8&title=#averageHue=%23faf5f5&from=url&id=wSBCU&originHeight=749&originWidth=1076&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><ul><li>核心：利用redis的setnx方法来表示获取锁，如果redis没有这个key，则插入成功，返回1，如果已经存在这个key，则插入失败，返回0。在StringRedisTemplate中返回true&#x2F;false，我们可以根据返回值来判断是否有线程成功获取到了锁<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//避免返回值为null，我们这里使用了BooleanUtil工具类</span></span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//否则去数据库中查</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">        <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(LOCK_SHOP_KEY + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><ul><li>需求：根据id查询商铺的业务，基于<code>逻辑过期</code>方式来解决缓存击穿问题</li><li>思路分析：当用户开始查询redis时，判断是否命中<ul><li>如果没有命中则直接返回空数据，不查询数据库</li><li>如果命中，则将value取出，判断value中的过期时间是否满足<ul><li>如果没有过期，则直接返回redis中的数据</li><li>如果过期，则在开启独立线程后，直接返回之前的数据，独立线程去重构数据，重构完成后再释放互斥锁<a href="https://pic1.imgdb.cn/item/6355073c16f2c2beb1375808.jpg"><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679641139130-cbba7b89-062d-408c-8f2f-b0fed1a31915.png#averageHue=%23f8f3f3&clientId=u93ccb212-de26-4&from=paste&id=u59b44c08&name=image.png&originHeight=629&originWidth=1229&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=272539&status=done&style=none&taskId=u0cf0d253-426c-4518-8050-f765cc93ede&title=#averageHue=%23f8f3f3&from=url&id=SOtG0&originHeight=629&originWidth=1229&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></a></li></ul></li></ul></li><li>封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么新建一个类包含原有的数据和过期时间</li></ul><p>这里我们选择新建一个实体类，包含原有数据(用万能的Object)和过期时间，这样对原有的代码没有侵入性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expirSeconds)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expirSeconds));</span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h2><ul><li>基于StringRedisTemplate封装一个缓存工具类</li><li>方法一：将任意Java对象序列化为JSON，并存储到String类型的Key中，并可以设置TTL过期时间</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法2：将任意Java对象序列化为JSON，并存储在String类型的Key中，并可以设置逻辑过期时间，用于处理缓存击穿问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicExpire</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//由于需要设置逻辑过期时间，所以我们需要用到RedisData</span></span><br><span class="line">    RedisData&lt;Object&gt; redisData = <span class="keyword">new</span> <span class="title class_">RedisData</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//redisData的data就是传进来的value对象</span></span><br><span class="line">    redisData.setData(value);</span><br><span class="line">    <span class="comment">//逻辑过期时间就是当前时间加上传进来的参数时间，用TimeUnit可以将时间转为秒，随后与当前时间相加</span></span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">    <span class="comment">//由于是逻辑过期，所以这里不需要设置过期时间，只存一下key和value就好了，同时注意value是ridisData类型</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：根据指定的Key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题<br>原来的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithPassThrough</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shopjson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则去数据库中查</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">    <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, jsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改为通用方法，那么返回值就需要进行修改，不能返回Shop了，那我们直接设置一个泛型，同时ID的类型，也不一定都是Long类型，所以我们也采用泛型。</li><li>Key的前缀也会随着业务需求的不同而修改，所以参数列表里还需要加入Key的前缀</li><li>通过id去数据库查询的具体业务需求我们也不清楚，所以我们也要在参数列表中加入一个查询数据库逻辑的函数</li><li>最后再加上设置TTL需要的两个参数</li><li>那么综上所述，我们的参数列表需要 <ol><li>key前缀</li><li>id（类型泛型）</li><li>返回值类型（泛型）</li><li>查询的函数</li><li>TTL需要的两个参数</li></ol></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为R类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则去数据库中查，查询逻辑用我们参数中注入的函数</span></span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">    <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(r);</span><br><span class="line">    <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">    <span class="built_in">this</span>.set(key, jsonStr, time, timeUnit);</span><br><span class="line">    <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.</span><br><span class="line">            queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：根据指定的Key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 从redis中查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2. 如果未命中，则返回空</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 命中，将json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">//4. 判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">//5. 未过期，直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 过期，尝试获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">//7. 获取到了锁</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">//8. 开启独立线程</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">R</span> <span class="variable">tmp</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                <span class="built_in">this</span>.setWithLogicExpire(key, tmp, time, timeUnit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//9. 直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//10. 未获取到锁，直接返回商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法5：根据指定的Key查询缓存，并反序列化为指定类型，需要利用互斥锁解决缓存击穿问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">    <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//否则去数据库中查</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, timeUnit);</span><br><span class="line">        &#125;</span><br><span class="line">        r = dbFallback.apply(id);</span><br><span class="line">        <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, timeUnit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.RedisData;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicExpire</span><span class="params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        RedisData&lt;Object&gt; redisData = <span class="keyword">new</span> <span class="title class_">RedisData</span>&lt;&gt;();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//如果不为空（查询到了），则转为R类型直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则去数据库中查，查询逻辑用我们参数中注入的函数</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查到了则转为json字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(r);</span><br><span class="line">        <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, jsonStr, time, timeUnit);</span><br><span class="line">        <span class="comment">//最终把查询到的商户信息返回给前端</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 从redis中查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2. 如果未命中，则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 命中，将json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//4. 判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//5. 未过期，直接返回商铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 过期，尝试获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">//7. 获取到了锁</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//8. 开启独立线程</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">R</span> <span class="variable">tmp</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicExpire(key, tmp, time, timeUnit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//9. 直接返回商铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//10. 未获取到锁，直接返回商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="comment">//先从Redis中查，这里的常量值是固定的前缀 + 店铺id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//如果不为空（查询到了），则转为Shop类型直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//否则去数据库中查</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">//查不到，则将空值写入Redis</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//并存入redis，设置TTL</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, timeUnit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分布式全局id生成"><a href="#分布式全局id生成" class="headerlink" title="分布式全局id生成"></a>分布式全局id生成</h1><ul><li>如果使用数据库自增ID就会存在一些问题 <ol><li>id规律性太明显</li><li>受单表数据量的限制</li></ol></li><li>全局ID生成器是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足一下特性 <ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul></li></ul><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681645376670-917c4244-2986-4587-8bb8-8b3b8ce9f1ad.png#averageHue=%23f7f6f6&clientId=u58a9a4fb-4925-4&from=paste&height=300&id=ue088a6be&originHeight=450&originWidth=970&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=142203&status=done&style=none&taskId=u93e5b036-dfe7-4b8a-ae16-0521deae911&title=&width=646.6666666666666" alt="image.png"></p><ul><li>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其他信息</li><li>ID组成部分 <ul><li>符号位：1bit，永远为0</li><li>时间戳：31bit，以秒为单位，可以使用69年（2^31秒约等于69年）</li><li>序列号：32bit，秒内的计数器，支持每秒传输2^32个不同ID<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="comment">//设置起始时间，我这里设定的是2022.01.01 00:00:00</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">//序列号长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">COUNT_BIT</span> <span class="operator">=</span> <span class="number">32L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> currentSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2. 生成序列号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;inc:&quot;</span>+keyPrefix+<span class="string">&quot;:&quot;</span>+date);</span><br><span class="line">        <span class="comment">//3. 拼接并返回，简单位运算</span></span><br><span class="line">        <span class="keyword">return</span> timeStamp &lt;&lt; COUNT_BIT | count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>stringRedisTemplate.opsForValue().increment(“inc:”+keyPrefix+”:”+date)是Redis中的一个原子操作，用于获取指定key的值并将其自增1。具体解释如下：</p><ul><li>stringRedisTemplate是一个StringRedisTemplate类型的对象，用于操作Redis中的字符串类型数据。</li><li>opsForValue()方法返回一个ValueOperations类型的对象，用于操作Redis中的字符串类型数据。</li><li>increment(key)方法用于获取指定key的值并将其自增1。如果key不存在，则会先将其初始化为0，然后再执行自增操作。</li></ul></blockquote>在这段代码中，”inc:”+keyPrefix+”:”+date是一个Redis的key，用于存储每天的序列号。其中，keyPrefix是一个前缀，用于区分不同种类的ID，date是当前日期（格式为”yyyy:MM:dd”），用于按天存储序列号。每次调用increment()方法时，会自动获取当天的序列号并将其加1，然后返回加1后的值。这样可以保证每天的序列号是唯一的，且是连续的。</li></ul></li></ul><h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><p>核心流程：判断日期（是否开启结束活动）和库存、扣减库存、创建订单<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679646991653-5c59b606-c702-4ca0-a977-996eca0aa82f.png#averageHue=%23faf8f8&clientId=u93ccb212-de26-4&from=paste&height=499&id=u37552472&name=image.png&originHeight=749&originWidth=1410&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=189490&status=done&style=none&taskId=ubbe33f63-c3d6-431d-afc6-2cc1eee5cba&title=&width=940#averageHue=%23faf8f8&id=OoSSt&originHeight=749&originWidth=1410&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647202344-e58f37f3-5d6f-42fb-9087-162a7f3599a3.png#averageHue=%23fcfcfb&clientId=u93ccb212-de26-4&from=paste&height=260&id=fPoGf&name=image.png&originHeight=390&originWidth=676&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56981&status=done&style=none&taskId=ud9fea0a2-6b19-428e-a9e6-26e3dc7f29d&title=&width=450.6666666666667#averageHue=%23fcfcfb&id=JWaHy&originHeight=390&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647229131-0b8f954f-cd8b-4132-8ec9-13514f6591fe.png#averageHue=%23f2f2f1&clientId=u93ccb212-de26-4&from=paste&height=559&id=ub3f80388&name=image.png&originHeight=839&originWidth=1667&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=169407&status=done&style=none&taskId=u8c78f38d-5980-4261-bf58-ea319ddc187&title=&width=1111.3333333333333#averageHue=%23f2f2f1&id=LRYY6&originHeight=839&originWidth=1667&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647250229-4ea29080-91de-4ed1-abbf-38a7a2883996.png#averageHue=%23f5f0ef&clientId=u93ccb212-de26-4&from=paste&height=394&id=ua7a74957&name=image.png&originHeight=591&originWidth=1423&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=289141&status=done&style=none&taskId=u5dc24863-8d82-4511-8895-e2f085ac62f&title=&width=948.6666666666666#averageHue=%23f5f0ef&id=vsB9v&originHeight=591&originWidth=1423&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br><strong>悲观锁：</strong><br>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等<br><strong>乐观锁：</strong>假定并发不一定会冲突，所以不加锁，而是通过判断数据是否在查出来之后被其它线程修改过，来决定是否运行操作</p><p>乐观锁主要有版本号法和CAS两种实现方式</p><ul><li>版本号法：给数据增加一个版本号字段，每次修改操作版本号+1，就可以通过版本号来片段是否有被修改</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681728499601-3cd30a77-3d47-4dbc-9655-6bb84cab5cad.png#averageHue=%23f9f8f8&clientId=uc6d03285-7526-4&from=paste&height=296&id=uda9d781a&originHeight=444&originWidth=988&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=142224&status=done&style=none&taskId=u082a9274-8b55-401b-a477-ceaa86a7715&title=&width=658.6666666666666" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">    .eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); <span class="comment">//where id = ？ and stock = ?</span></span><br></pre></td></tr></table></figure><ul><li>CAS是对乐观锁的简化，即直接用一个每次都会查询和更新的字段来代替版本号，比如库存stock字段</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681728571837-846cf1f8-e33f-4d01-b9ee-d80fda839660.png#averageHue=%23fafafa&clientId=uc6d03285-7526-4&from=paste&height=291&id=ud413dcfe&originHeight=436&originWidth=980&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=118694&status=done&style=none&taskId=u3651f5f1-84c5-4127-9cac-89e7b7db72b&title=&width=653.3333333333334" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update(); <span class="comment">//where id = ? and stock &gt; 0</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>优点：性能好</li><li>缺点：存在成功率低的问题（很多人查到的版本号是一样的，结果只能有一个人操作成功），使用分段锁来改进。比如将100个库存分为10分，大家分别抢这10分</li></ul></blockquote><p>对于以上场景，其实不用判断stock是否变化，直接判断stock&gt;0.从而保证成功率</p><h1 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h1><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单<br><strong>现在的问题在于：</strong><br>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679647698772-0be59b9c-7fa9-4124-a3bc-30114e7bde16.png#averageHue=%23faf8f8&clientId=u93ccb212-de26-4&from=paste&height=322&id=u87a39ba7&name=image.png&originHeight=483&originWidth=1012&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=113348&status=done&style=none&taskId=ub57286b9-90f2-4545-bdc8-06f0316af7d&title=&width=674.6666666666666#averageHue=%23faf8f8&id=gQYKJ&originHeight=483&originWidth=1012&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>因为订单是创建数据，无法使用乐观锁，使用悲观锁实现</p><h2 id="单机实现"><a href="#单机实现" class="headerlink" title="单机实现"></a>单机实现</h2><p>单机部署后端服务器时，可以使用java自带的<code>Synchronized</code>关键字作为悲观锁<br>注意事项：</p><ol><li><p>Synchronized锁的范围不能太大，不能锁住整个对象，会严重影响性能。因为是一人一单，所以可以每个用户一把独立的锁</p></li><li><p>注意，锁住对象时要用<code>toString.intern</code>，保证同id的用户始终是同一个对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;voucherId&quot;</span>, voucherId).eq(<span class="string">&quot;userId&quot;</span>, userId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;你已经抢过优惠券了哦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">//6.1 设置订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">//6.2 设置用户id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//6.3 设置代金券id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setUserId(id);</span><br><span class="line">        <span class="comment">//7. 将订单数据保存到表中</span></span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="comment">//8. 返回订单id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到这里，锁已经被释放了，但是可能当前事务还未提交，如果此时有线程进来，不能确保事务不出问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>userId.toString().intern()是Java中的字符串常量池（String Pool）机制，用于将字符串对象放入常量池中，并返回常量池中的引用。具体解释如下：</p><ul><li>userId是一个Long类型的对象，调用toString()方法可以将其转换为字符串类型。</li><li>intern()方法是String类中的一个方法，用于将字符串对象放入常量池中，并返回常量池中的引用。</li><li>当调用intern()方法时，JVM首先检查常量池中是否已经存在相同值的字符串对象，如果存在，则返回常量池中的引用；如果不存在，则将该字符串对象放入常量池中，然后返回常量池中的引用。</li><li>要注意即使是toString（）每次创建都都是一个新对象，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</li></ul></blockquote></li><li><p>Synchronized必须在使用<code>@Transactional</code>注解的方法外层使用，因为<code>@Transactional</code>是使用动态代理，在方法执行结束后才提交事务。如果把Synchronized写在事务方法内，提交事务前锁已经释放，但此时数据还未更新，其它线程依然能获取锁并顺利执行</p></li><li><p>调用事务方法时不能用this对象，因为@Transactional注解实际上是调用Spring生成的代理对象的方法，如果调用this对象的方法会无法使用事务功能，所以要获取代理对象并调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 一人一单逻辑</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;voucherId&quot;</span>, voucherId).eq(<span class="string">&quot;userId&quot;</span>, userId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;你已经抢过优惠券了哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">            .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">//6.1 设置订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">//6.2 设置用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//6.3 设置代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(id);</span><br><span class="line">    <span class="comment">//7. 将订单数据保存到表中</span></span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="comment">//8. 返回订单id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h2><p>Synchronized关键字只对单个JVM有效，多机部署时还是可能会同时有多个不同JVM的线程访问已加锁的方法<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679654809416-a086161e-8482-4942-97ce-e6fb2f4ea697.png#averageHue=%23eeebea&clientId=u93ccb212-de26-4&from=paste&height=502&id=u64fa1957&name=image.png&originHeight=753&originWidth=1708&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=355271&status=done&style=none&taskId=u79aa1e21-6d1a-4647-a2dd-1057e9a8aeb&title=&width=1138.6666666666667#averageHue=%23eeebea&id=gymaM&originHeight=753&originWidth=1708&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>因此，我们不能把锁存储到单个服务器上，而是应该使用一个集中的存储来管理锁，所有的进程都能读到他，这就需要分布式锁</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul><li>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</li><li>分布式锁的两个基本特征：<ul><li>多进程（线程）可见（读写）</li><li>互斥</li></ul></li><li>还应具备的特征<ul><li>高可用：不能挂机</li><li>高性能：读写要快</li><li>安全性：不能出现死锁</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679654873984-7edb8dfc-bd42-4e89-bade-1b22d4111a25.png#averageHue=%23f2f1f1&clientId=u93ccb212-de26-4&from=paste&height=541&id=ude651043&name=image.png&originHeight=812&originWidth=1591&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=358347&status=done&style=none&taskId=u2ee91661-0d92-4c29-8dc0-56ef3d5b2af&title=&width=1060.6666666666667#averageHue=%23f2f1f1&id=WAxUQ&originHeight=812&originWidth=1591&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679654888124-ca0a7120-a8fe-41f4-8ccb-6efc145a2134.png#averageHue=%23d6c0bf&clientId=u93ccb212-de26-4&from=paste&height=403&id=u652eccc7&name=image.png&originHeight=604&originWidth=1685&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=203873&status=done&style=none&taskId=ue89bcda7-7fda-4cfc-ac1b-b4f3201ddd9&title=&width=1123.3333333333333#averageHue=%23d6c0bf&id=FhCMD&originHeight=604&originWidth=1685&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li>获取锁（setnx）： <ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li></ul><p>注意事项：</p><ol><li>为了防止setnx后就宕机了导致lock永久存在，必须私用set [key] ex nx的原子命令，保证每个lock都有过期时间</li></ol><ul><li>释放锁： <ul><li>主动释放：业务执行完后删除key，注意需要把锁释放的逻辑放到finally里保证一定执行</li><li>超时释放：获取锁时添加一个超时时间<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    <span class="comment">//锁的前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//这里不需要@Autowired，因为该对象是我们使用构造函数手动new出来的</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标识</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//自动拆箱可能会出现null，这样写更稳妥</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//通过DEL来删除锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">// 创建锁对象</span></span><br><span class="line"><span class="type">SimpleRedisLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line"><span class="comment">// 获取锁对象</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock(<span class="number">120</span>);</span><br><span class="line"><span class="comment">// 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span></span><br><span class="line"><span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许抢多张优惠券&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    redisLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol><li><p>注意这边使用代理要添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动类上加注解 @EnableAspectJAutoProxy(exposeProxy &#x3D; true)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="分布式锁误删情况"><a href="#分布式锁误删情况" class="headerlink" title="分布式锁误删情况"></a>分布式锁误删情况</h3><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p>逻辑说明</p><ul><li>持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放</li><li>此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到</li><li>但是现在线程1阻塞完了，继续往下执行，要开始释放锁了</li><li>那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681730800881-831ff771-8996-4614-a0a4-94bb2061c416.png#averageHue=%23f9f9f8&clientId=uc6d03285-7526-4&from=paste&height=279&id=u4a0557b9&originHeight=418&originWidth=985&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=120152&status=done&style=none&taskId=u0451b92c-d775-40c2-8334-950811ed9db&title=&width=656.6666666666666" alt="image.png"><br>解决方案</p><ul><li>解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的（获取锁的时候在value中存入[本机标识+线程id]），如果不属于自己，则不进行删除操作。</li><li>假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁</li></ul><p>注意：不能只在value中存入线程id，因为多个机器的线程id可能是一样的，任然肯会出现误删</p><h4 id="情况2-原子性问题"><a href="#情况2-原子性问题" class="headerlink" title="情况2-原子性问题"></a>情况2-原子性问题</h4><p>假设线程A释放锁时已经判断了是自己的锁，但在这时候，线程A卡住了，锁超时释放了，线程B拿到了锁并执行业务，这时，线程A醒了，释放了B的锁<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679656285059-d901e586-9c7c-4a4e-88d9-56c886288015.png#averageHue=%23fbfafa&clientId=u93ccb212-de26-4&from=paste&height=547&id=ubb79267f&name=image.png&originHeight=820&originWidth=1723&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=215685&status=done&style=none&taskId=u14d6f930-1bf0-4266-8f07-1a28a995c70&title=&width=1148.6666666666667#averageHue=%23fbfafa&id=CwWHM&originHeight=820&originWidth=1723&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><p>解决方案<br>问题的本质是判断锁和删除锁是两个动作，不具备原子性，可以使用Redis Lua脚本，将多个Redis命令放到一个脚本中，整个脚本<br><a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679656633823-cb5ca03d-176f-4621-9c1a-d330f01cef0c.png#averageHue=%23c2c7b9&clientId=u93ccb212-de26-4&from=paste&height=536&id=ue7fef514&name=image.png&originHeight=804&originWidth=1753&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=561968&status=done&style=none&taskId=ue4d1ca6c-7844-4512-a9cd-eea1205383c&title=&width=1168.6666666666667#averageHue=%23c2c7b9&id=dJopT&originHeight=804&originWidth=1753&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>放在Resources目录下</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里的KEYS[1]就是传入锁的key</span></span><br><span class="line"><span class="comment">-- 这里的ARGV[1]就是线程标识</span></span><br><span class="line"><span class="comment">-- 比较锁中 的线程标识与线程标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致则释放锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在RedisTemplate中，可以利用execute方法去执行lua脚本</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T <span class="built_in">execute</span>(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.scriptExecutor.<span class="built_in">execute</span>(script, keys, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.execute(UNLOCK_SCRIPT,</span><br><span class="line">                                Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">                                ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>利用SET NX EX获取锁，并设置过期时间，保存线程标识</li><li>释放锁时先判断线程标识是否与自己一致，一致则删除所 <ul><li>特性 <ul><li>利用SET NX满足互斥性</li><li>利用SET EX保证故障时依然能释放锁，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul></blockquote><h1 id="分布式锁-Redisson"><a href="#分布式锁-Redisson" class="headerlink" title="分布式锁-Redisson"></a>分布式锁-Redisson</h1><h2 id="分布式锁-redission功能介绍"><a href="#分布式锁-redission功能介绍" class="headerlink" title="分布式锁-redission功能介绍"></a>分布式锁-redission功能介绍</h2><p>基于setnx实现的分布式锁存在下面的问题：</p><ul><li><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁。</li><li><strong>不可重试</strong>：是指目前的分布式只能尝试一次，合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</li><li><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</li><li><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕了，就会出现死锁问题。</li></ul><p>那么什么是Redission呢<br>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。<br>官网：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a><br>中文文档：<a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95</a></p><ul><li>Redis提供了分布式锁的多种多样功能 <ol><li>可重入锁(Reentrant Lock)</li><li>公平锁(Fair Lock)</li><li>联锁(MultiLock)</li><li>红锁(RedLock)</li><li>读写锁(ReadWriteLock)</li><li>信号量(Semaphore)</li><li>可过期性信号量(PermitExpirableSemaphore)</li><li>闭锁(CountDownLatch)</li></ol></li></ul><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol><li><p>导入依赖</p></li><li><p>配置Redisson客户端，在config包下新建<code>RedissonConfig</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">            .setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改之前的代码</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//1. 查询优惠券</span></span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    <span class="comment">//2. 判断秒杀时间是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀还未开始，请耐心等待&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 判断秒杀时间是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许抢多张优惠券&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><blockquote><p>可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。<br>与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。可重入锁的工作原理很简单，就是用一个计数器来记录锁被获取的次数，获取锁一次计数器+1，释放锁一次计数器-1，当计数器为0时，表示锁可用。<br>不可重入锁也叫自旋锁。</p></blockquote><p>可重入锁的实现原理是基于计数器的，每次获取锁时，计数器自增，每次释放锁时，计数器自减，从而实现了线程间的同步和互斥。具体地，当线程持有锁时，计数器加1；当线程释放锁时，计数器减1。当计数器减至0时，锁被释放，此时线程可以继续执行。这种同步机制可以有效地避免死锁等问题，提高程序的并发性和可靠性。</p><ul><li>在Lock锁中，他是借助于等曾的一个voaltile的一个state变量来记录重入的状态的 <ul><li>如果当前没有人持有这把锁，那么state &#x3D; 0</li><li>如果有人持有这把锁，那么state &#x3D; 1 <ul><li>如果持有者把锁的人再次持有这把锁，那么state会+1</li></ul></li><li>如果对于synchronize而言，他在c语言代码中会有一个count</li><li>原理与state类似，也是重入一次就+1，释放一次就-1，直至减到0，表示这把锁没有被人持有</li></ul></li><li>在redisson中，我们也支持可重入锁 <ul><li>在分布式锁中，它采用hash结构来存储锁，其中外层key表示这把锁是否存在，内层key则记录当前这把锁被哪个线程持有</li></ul></li><li>由于我们需要额外存储一个state，所以用字符串型SET NX EX是不行的，需要用到Hash结构，但是Hash结构又没有NX这种方法，所以我们需要将原有的逻辑拆开，进行手动判断</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679738915658-07739206-a06d-43bb-9af9-ea871a4de358.png#averageHue=%23e8dfde&clientId=u51856e4d-12b3-4&from=paste&id=u337f15c8&name=image.png&originHeight=688&originWidth=636&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=238378&status=done&style=none&taskId=u2d7678f9-73ff-49ce-a12b-f1e89277a20&title=#averageHue=%23e8dfde&id=E1zcv&originHeight=688&originWidth=636&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>为了保证原子性，所以流程图中的业务逻辑也是需要用Lua来实现</p><ul><li><p>获取锁的逻辑</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]; <span class="comment">-- 锁的key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]; <span class="comment">-- 线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]; <span class="comment">-- 锁的自动释放时间</span></span><br><span class="line"><span class="comment">-- 锁不存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 获取锁并添加线程标识，state设为1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">-- 设置锁有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁存在，判断threadId是否为自己</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁存在，重入次数 +1，这里用的是hash结构的incrby增长</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, thread, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">-- 设置锁的有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">-- 代码走到这里，说明获取锁的不是自己，获取锁失败</span></span><br></pre></td></tr></table></figure></li><li><p>释放锁的逻辑</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">-- 如果锁不是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; <span class="comment">-- 直接返回</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁是自己的，锁计数-1，还是用hincrby，不过自增长的值为-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 判断重入次数为多少</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 大于0，重置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 否则直接释放锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="如何重试获取锁"><a href="#如何重试获取锁" class="headerlink" title="如何重试获取锁"></a>如何重试获取锁</h3><p>基于Redis Pub&#x2F;Sub发布订阅机制。如果获取锁失败，则阻塞订阅释放锁的消息；当锁被释放时，会触发推送（告诉其它线程我被释放了），然后其它线程再重试获取；如此往复知道超时</p><h3 id="如何防止锁提前超时释放"><a href="#如何防止锁提前超时释放" class="headerlink" title="如何防止锁提前超时释放"></a>如何防止锁提前超时释放</h3><p>基于<strong>看门狗机制</strong>。如果不手动设置锁释放时间 (leaseTime) ，默认设置 30 秒过期，并目给当前锁注册一个定时任务，该定时任务每隔 1&#x2F;3 的锁释放时间 (一般是 10 秒)会重置锁的过期时间(递归调用，一次续期完了再)<br>需要思考两个问题:</p><ol><li>如何保证同一个锁只注册一个定时任务?</li><li>如何防止无限续期?</li></ol><p>要解决这些问题，使用全局 ConcurrentHashMap 来管理锁 &#x3D;&gt; 任务信息，key 为锁的id，从而保证唯一。当某个锁释放时，从全局 ConcurrentHashMap 中取出定时任务并取消掉，然后把锁的信息从 Map 中删掉即可。<br>最终，完整的分布式锁流程如下<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679714572280-1fbba4ec-3b96-45ce-bc60-a8ee46289386.png#averageHue=%23faf6f6&clientId=u909f52ab-0fa4-4&from=paste&height=528&id=u13ed5ec8&name=image.png&originHeight=792&originWidth=1740&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=334255&status=done&style=none&taskId=u3219ee15-2a06-42f7-87c7-76a9162405c&title=&width=1160#averageHue=%23faf6f6&id=yu9hV&originHeight=792&originWidth=1740&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h2 id="如何解决主从一致性问题"><a href="#如何解决主从一致性问题" class="headerlink" title="如何解决主从一致性问题"></a>如何解决主从一致性问题</h2><p>如果使用主从复制的 Redis 集群，可能出现主从节点设置的锁状态不一致的问题可以使用 Redisson 的 MultiLock (联锁) 来解决，核心思想是开启多个独立的 Redis 主节点，设置锁时必须在所有主节点都写入成功，才算设置成功。这样做之后，哪怕有部分节点挂掉，其他线程也无法 setnx 全部成功，就不会出现重复执行业务的情况。<br>如下图:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681732694779-5bf00dd9-c14e-41c8-8d37-47ff81e797bf.png#averageHue=%23f5f4f0&clientId=uc6d03285-7526-4&from=paste&height=249&id=ua490693f&originHeight=373&originWidth=990&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=171249&status=done&style=none&taskId=ub7813047-c49d-49f1-a65b-f9551efe0ca&title=&width=660" alt="image.png"><br>实现 MultiLock 的几个关键:</p><ol><li>遍历所有节点，依次设置锁，并使用列表来记录所有主节点的锁是否设置成功。</li><li>只要有一个节点设置不成功，就要释放所有的锁，从头来过。</li><li>因为不同节点设置锁成功的时间不同，所以在所有锁设置成功后，要统一设置过期时间(但如果 leaseTime &#x3D; -1 就不用了，因为开启了看门狗机制会自动续期)</li><li>锁释放时间 (leaseTime) 必须要大于抢锁最大等待时间 (waitTime) ，否则可能出现第一个节点抢到锁，最后一个节点还没抢到锁，之前的锁就已经超时释放了。所以如果指定了 waitTime 和 leaseTime，默认 leaseTime &#x3D; waitTime * 2</li></ol><p>MultiLock 最安全，但同样会带来很大的运维成本</p><h2 id="秒杀业务优化"><a href="#秒杀业务优化" class="headerlink" title="秒杀业务优化"></a>秒杀业务优化</h2><p>我们先来回顾一下下单流程<br>当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤</p><ol><li>查询优惠券</li><li>判断秒杀库存是否足够</li><li>查询订单</li><li>校验是否一人一单</li><li>扣减库存</li><li>创建订单</li></ol><ul><li>在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？</li><li>优化方案：我们将耗时较短的逻辑判断放到Redis中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679795940035-050f0b62-6ac6-4f8d-9d35-e02215f0004f.png#averageHue=%23faf6f6&clientId=uaf30bc39-5a32-4&from=paste&id=u29e65c67&name=image.png&originHeight=732&originWidth=1540&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=423648&status=done&style=none&taskId=u070515ef-409f-4cba-ab7c-d58280195f5&title=#averageHue=%23faf6f6&id=Pdrmz&originHeight=732&originWidth=1540&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><ul><li>但是这里还存在两个难点 <ol><li>我们怎么在Redis中快速校验是否一人一单，还有库存判断</li><li>我们校验一人一单和将下单数据写入数据库，这是两个线程，我们怎么知道下单是否完成。 <ul><li>我们需要将一些信息返回给前端，同时也将这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询下单逻辑是否完成</li></ul></li></ol></li><li>我们现在来看整体思路：当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将userId和优惠券存入到Redis中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作，同时由于我们需要在Redis中查询优惠券信息，所以在我们新增秒杀优惠券的同时，需要将优惠券信息保存到Redis中</li><li>完成以上逻辑判断时，我们只需要判断当前Redis中的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单，其阿奴单可以通过返回订单的id来判断是否下单成功</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679795974724-d93dabe5-c9ad-40eb-a1d4-d978736cd505.png#averageHue=%23f2eded&clientId=uaf30bc39-5a32-4&from=paste&id=u4e25731c&name=image.png&originHeight=760&originWidth=1606&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=413127&status=done&style=none&taskId=ua7f3dfb8-229d-40a6-a4f4-d68e5ed3118&title=#averageHue=%23f2eded&id=v0nPj&originHeight=760&originWidth=1606&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中(修改之前添加的逻辑）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀优惠券信息到Reids，这里并不需要设置有效期，等秒杀活动过了，我们再手动将其删除</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Lua脚本：lua的字符串拼接使用..，字符串转数字是tonumber()</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 订单id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 优惠券key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 判断用户是否下单</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 将userId存入当前优惠券的set集合</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"><span class="comment">//1. 执行lua脚本</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">  Collections.emptyList(), voucherId.toString(),</span><br><span class="line">  UserHolder.getUser().getId().toString());</span><br><span class="line"><span class="comment">//2. 判断返回值，并返回错误信息</span></span><br><span class="line"><span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"><span class="comment">//TODO 保存阻塞队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 返回订单id</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这边由于没有key，所以使用Collections.emptyList()</p></blockquote><h3 id="基于阻塞队列实现秒杀优化"><a href="#基于阻塞队列实现秒杀优化" class="headerlink" title="基于阻塞队列实现秒杀优化"></a>基于阻塞队列实现秒杀优化</h3><ul><li>修改下单的操作，我们在下单时，是通过Lua表达式去原子执行判断逻辑，如果判断结果不为0，返回错误信息，如果判断结果为0，则将下单的逻辑保存到队列中去，然后异步执行</li><li>需求 <ol><li>如果秒杀成功，则将优惠券id和用户id封装后存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ol></li><li>步骤一：创建阻塞队列<br>阻塞队列有一个特点：当一个线程尝试从阻塞队列里获取元素的时候，如果没有元素，那么该线程就会被阻塞，直到队列中有元素，才会被唤醒，并去获取元素<br>阻塞队列的创建需要指定一个大小<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>那么把优惠券id和用户id封装后存入阻塞队列<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString());</span><br><span class="line">    <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//加入到阻塞队列</span></span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>实现异步下单功能</li></ul><ol><li><p>创建一个线程池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></li><li><p>创建线程任务：秒杀业务需要在类初始化之后，就立即执行，这里用到@PostConstruct注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1. 获取队列中的订单信息</span></span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                <span class="comment">//2. 创建订单</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建订单逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="comment">//2. 创建锁对象，作为兜底方案</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">    <span class="comment">//3. 获取锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">    <span class="comment">//4. 判断是否获取锁成功(理论上必成功，redis已经帮我们判断了)</span></span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;不允许重复下单!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//5. 使用代理对象，由于这里是另外一个线程，</span></span><br><span class="line">        proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看AopContext源码，它的获取代理对象也是通过ThreadLocal进行获取的，由于我们这里是异步下单，和主线程不是一个线程，所以不能获取成功</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Object&gt; currentProxy = <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>(<span class="string">&quot;Current AOP proxy&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是我们可以将proxy放在成员变量的位置，然后在主线程中获取代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString());</span><br><span class="line">    <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">//加入到阻塞队列</span></span><br><span class="line">    orderTasks.add(voucherOrder);</span><br><span class="line">    <span class="comment">//主线程获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.dto.Result;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.VoucherOrder;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.mapper.VoucherOrderMapper;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.service.ISeckillVoucherService;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.service.IVoucherOrderService;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.RedisIdWorker;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.utils.UserHolder;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.AopContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IVoucherOrderService proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="comment">//2. 创建锁对象，作为兜底方案</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//3. 获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisLock.tryLock();</span><br><span class="line">        <span class="comment">//4. 判断是否获取锁成功(理论上必成功，redis已经帮我们判断了)</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;不允许重复下单!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//5. 使用代理对象，由于这里是另外一个线程，</span></span><br><span class="line">            proxy.createVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//1. 获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">//2. 创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(), voucherId.toString(),</span><br><span class="line">                UserHolder.getUser().getId().toString());</span><br><span class="line">        <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">//封装到voucherOrder中</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">//加入到阻塞队列</span></span><br><span class="line">        orderTasks.add(voucherOrder);</span><br><span class="line">        <span class="comment">//主线程获取代理对象</span></span><br><span class="line">        proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 一人一单逻辑</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">        <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;user_id&quot;</span>, userId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;你已经抢过优惠券了哦&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5. 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                    .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                    .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                    .update();</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//7. 将订单数据保存到表中</span></span><br><span class="line">            save(voucherOrder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>JDK 中的阻塞队列（BlockingQueue）是一种线程安全的队列，它可以在多线程环境下使用。但是，使用阻塞队列也可能存在一些问题，以下是其中的一些：</p><ol><li>死锁：如果多个线程同时尝试获取队列的元素，但队列已满或已空，则可能会导致死锁。这是因为队列的操作是阻塞的，一旦有线程获取了队列的元素，其他线程就必须等待，直到队列中有空间可用。</li><li>竞争条件：如果多个线程同时尝试获取队列的元素，但队列中已经有一个线程正在等待，则其他线程可能会被阻塞，直到队列中有空间可用。这会导致系统资源的浪费。</li><li>不确定性：由于阻塞队列是线程安全的，因此在某些情况下，线程可能会在等待队列操作完成时发生阻塞，而无法立即执行其他操作。这会导致程序的性能下降。</li><li>不可恢复性：如果队列被意外地破坏，例如由于系统故障或异常，则可能会导致数据丢失或不一致。这使得阻塞队列在某些情况下不可恢复。</li></ol><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>最简单的消息队列模型包括3个角色</p><ol><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ol><p>使用队列的好处在于解耦：举个例子，快递员(生产者)吧快递放到驿站&#x2F;快递柜里去(Message Queue)去，我们(消费者)从快递柜&#x2F;驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的<br>那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度<br>这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案(学完Redis我就去学微服务)</p><h2 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><p>Redis的list数据结构是一个<strong>双向链表</strong>，很容易模拟出队列的效果<br>队列的入口和出口不在同一边，所以我们可以利用：LPUSH模拟生产者发送消息入队，使用<br>BRPOP或者BLPOP来实现阻塞效果<br><code>BRPOP</code> 命令用于阻塞地等待队列中有空闲空间(队列长度&gt;0)，并在有空闲空间时立即返回消息。如果队列为空，则 BRPOP 命令会阻塞等待，直到有空闲空间可用。<br><code>BLPOP</code> 命令用于立即获取队列中的消息，并在有消息可用时返回。如果队列为空，则 BLPOP 命令会阻塞等待，直到有消息可用。<br>基于List的消息队列有哪些优缺点？<br>优点</p><ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性</li></ol><p>缺点</p><ol><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li></ol><h2 id="Pub-x2F-Sub"><a href="#Pub-x2F-Sub" class="headerlink" title="Pub&#x2F;Sub"></a>Pub&#x2F;Sub</h2><p>使用 Redis 的订阅发布模型，生产者可以将消息推送给某个 Channel (频道) ，多个消费者可以订阅该频道，从而同时得到消息。(可以理解为“你关注的 UP 主更新啦”)<br>用到的命令主要是</p><ul><li>Publish 推送</li><li>SubScribe 订阅</li><li>PSubScribe 订阅某个表达式匹配的多个频道这样就实现了多生产、多消费缺点比较多</li></ul><p>优点：<br>采用发布订阅模型，支持多生产，多消费<br>缺点：</p><ol><li>不支持数据持久化</li><li>无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）</li><li>消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）</li></ol><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><ul><li>Stream是Redis 5.0引入的一种新数据类型，可以时间一个功能非常完善的消息队列</li></ul><h2 id="核心命令"><a href="#核心命令" class="headerlink" title="核心命令"></a>核心命令</h2><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><code>XAdd</code>：添加消息&#x2F;创建队列，消息会自动持久化，不会丢失，每个消息都有唯一id</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XADD streamName ID field1 value1 field2 value2 ... fieldN valueN</span><br></pre></td></tr></table></figure><blockquote><ul><li>treamName是Stream的名称，ID是消息的唯一标识符，field和value是消息的键值对。</li><li>D有两种形式：和*。表示使用自动生成的ID，表示手动指定ID。如果使用$，那么ID的格式为timestamp-sequencenumber，其中timestamp是Unix时间戳，sequencenumber是一个递增的序列号。如果使用，那么ID必须是一个整数，并且必须比Stream中最后一条消息的ID大</li><li>XADD指令会返回新消息的ID，可以用这个ID来查询或删除消息。如果Stream不存在，XADD指令会自动创建一个新的Stream。</li></ul></blockquote><h3 id="读取消息"><a href="#读取消息" class="headerlink" title="读取消息"></a>读取消息</h3><p><code>XRead</code>：读取消息，支持多消费者读，可从指定id开读，支持阻塞读取最新消息<br>Redis Stream提供了多种方式来读取消息，以下是常用的几种方法：<br>XREAD：使用XREAD指令可以读取Stream中的消息。XREAD可以指定多个Stream和ID，返回的结果是一个数组，包含了每个Stream中指定ID之后的所有消息。</p><ul><li><p>XREAD</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><p>其中，COUNT和BLOCK是可选参数。COUNT表示最多返回的消息数量，BLOCK表示阻塞的超时时间。如果不指定这两个参数，XREAD会一直阻塞直到Stream中有新的消息可读。<br>STREAMS后面跟着的是一个或多个Stream的名称，ID后面跟着的是一个或多个ID。XREAD会返回每个Stream中指定ID之后的所有消息。<br>XREAD返回的结果是一个数组，数组中的每个元素都是一个键值对，键是Stream的名称，值是一个数组，包含了Stream中指定ID之后的所有消息。<br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始<br>XREAD指令可以根据实际需求灵活使用。如果不需要阻塞等待新的消息，则可以不指定BLOCK参数；如果需要一次性读取多个Stream中的消息，则可以在STREAMS参数中指定多个Stream的名称。如果需要控制返回的消息数量，则可以使用COUNT参数。</p></li><li><p>阻塞读取最新消息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREAD COUNT 2 BLOCK 10000 STREAMS users $</span><br></pre></td></tr></table></figure></li><li><p>业务伪代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//尝试读取队列中的消息，最多阻塞2秒</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 2 BLOCK 10000 STREAMS users $&quot;</span>);</span><br><span class="line">    <span class="comment">//没读取到，跳过下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理消息</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题</p></blockquote><ul><li>STREAM类型消息队列的XREAD命令特点 <ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol></li></ul><h2 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h2><p>只用这两个命令还是不够的，因为目前只支持<code>阻塞读最新</code>消息，假设处理消息过程中又来了几条消息，可能出现<code>漏读消息</code>的情况<br>为解决上述问题，可以用 Stream 的以下特性:<br><code>消费组</code>: 同组内的多个消费者可以竞争消费(每个消息只有<code>一个</code>消费者能抢到) ，从而提高消费能力 (并发度) 。对应命令为<code>XGROUP</code>、<code>XREADGROUP</code> 等<br><code>消息标识</code>: 自动记录消费的进度，支持从上次未消费的地方开始接着消费，保证每条消息按顺序消费<br><code>消息确认机制</code>: 默认消费的消息为 pending 状态，会放到每个消费者的 pending list 中，只有消息由消费者确认 (ACK) ，才会从pending list 移除。这样如果消费业务处理异常，可以从 pending list 的开头依次读取未确认消息，重试处理。(也要避免无限重试，实在处理不成功就强制 ACK + 业务记日志)整个消费流程伪代码如下</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681813734547-cf20c3b8-8162-497e-971f-ff1653f75412.png#averageHue=%23f3f3f5&clientId=uf387f538-a383-4&from=paste&height=647&id=u0424266b&originHeight=970&originWidth=1064&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=276073&status=done&style=none&taskId=u210cccb8-a907-47ef-a20c-ed947cc9a52&title=&width=709.3333333333334" alt="image.png"></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><code>消费者组</code>(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点</p><ol><li>消息分流：队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而加快消息处理的速度</li><li><code>消息标识</code>：消费者会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息，确保每一个消息都会被消费</li><li>消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</li></ol><p>在Redis Stream中，消费者组的<code>创建和管理</code>都由<code>XGROUP</code>命令完成。XGROUP命令有两个子命令：CREATE和<code>SETID</code>。CREATE用于创建一个新的消费者组，SETID用于设置消费者组的<code>最后已读消息ID</code>。</p><p>创建消费者组后，可以使用<code>XREADGROUP</code>命令让多个消费者从<code>同一个Stream中读取消息</code>，并使用XACK命令确认已经消费的消息。这种方式可以保证消息不会被重复消费，也可以让多个消费者协同处理消息，提高处理效率。</p><p>需要注意的是，消费者组中的每个消费者都要有一个唯一的名称（即消费者ID），XGROUP和XREADGROUP命令都需要指定消费者ID。消费者ID可以自己定义，也可以由程序自动生成。另外，消费者组中的消费者数量应该根据实际需求进行适当控制，避免过多或过少导致性能问题。</p><p>创建消费者组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE key groupName ID [MKSTREAM]</span><br></pre></td></tr></table></figure><blockquote><ul><li>key <ul><li>队列名称</li></ul></li><li>groupName <ul><li>消费者组名称</li></ul></li><li>ID <ul><li>起始ID标识，$代表队列中的最后一个消息，0代表队列中的第一个消息</li></ul></li><li>MKSTREAM <ul><li>队列不存在时自动创建队列</li></ul></li></ul></blockquote><ul><li><p>删除指定的消费者组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure></li><li><p>给指定的消费者组添加消费者</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupName consumerName</span><br></pre></td></tr></table></figure></li><li><p>删除消费者中指定的消费者</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupName consumerName</span><br></pre></td></tr></table></figure></li><li><p>从消费者中读取信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP groupName consumerName [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure></li></ul><blockquote><ul><li>group <ul><li>消费者组名称</li></ul></li><li>consumer <ul><li>消费者名，如果消费者不存在，会自动创建一个消费者</li></ul></li><li>count <ul><li>本次查询的最大数量</li></ul></li><li>BLOCK milliseconds <ul><li>当前没有消息时的最大等待时间</li></ul></li><li>NOACK <ul><li>无需手动ACK，获取到消息后自动确认（一般不用，我们都是手动确认）</li></ul></li><li>STREAMS key <ul><li>指定队列名称</li></ul></li><li><h2 id="ID-获取消息的起始ID"><a href="#ID-获取消息的起始ID" class="headerlink" title="ID-  获取消息的起始ID "></a>ID<br>-  获取消息的起始ID </h2><ul><li>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li></ul></li></ul></blockquote><p>消费者监听消息的基本思路</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 尝试监听队列，使用阻塞模式，最大等待时长为2000ms</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 没监听到消息，重试</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//处理消息，完成后要手动确认ACK，ACK代码在handleMessage中编写</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(msg == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//null表示没有异常消息，所有消息均已确认，结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//说明有异常消息，再次处理</span></span><br><span class="line">                handleMessage(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                <span class="comment">//再次出现异常，记录日志，继续循环</span></span><br><span class="line">                log.error(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>STREAM类型消息队列的XREADGROUP命令的特点 <ol><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ol></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681813769915-396e4ff5-1da4-4aea-921f-f89c05eed249.png#averageHue=%23f9f7f4&clientId=uf387f538-a383-4&from=paste&height=523&id=u37f0fd91&originHeight=784&originWidth=1778&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=272522&status=done&style=none&taskId=u0a199aa2-d48b-4d81-bbe5-c06d9a36405&title=&width=1185.3333333333333" alt="image-1.png"></p><h3 id="实现异步下单"><a href="#实现异步下单" class="headerlink" title="实现异步下单"></a>实现异步下单</h3><p>需求：</p><ol><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li></ol><p>步骤一：创建一个Stream类型的消息队列，名为stream.orders</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XGROUP CREATE stream.orders g1 0 MKSTREAM</span><br></pre></td></tr></table></figure><p>步骤二：修改Lua脚本，新增orderId参数，并将订单信息加入到消息队列中</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 订单id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的</span></span><br><span class="line"><span class="keyword">local</span> id = ARGV[<span class="number">3</span>]</span><br><span class="line"><span class="comment">-- 优惠券key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 判断用户是否下单</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 将userId存入当前优惠券的set集合</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 将下单数据保存到消息队列中</span></span><br><span class="line">redis.call(<span class="string">&quot;sadd&quot;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, id)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>步骤三：修改秒杀逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">            Collections.emptyList(), voucherId.toString(),</span><br><span class="line">            UserHolder.getUser().getId().toString(), String.valueOf(orderId));</span><br><span class="line">    <span class="keyword">if</span> (result.intValue() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(result.intValue() == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程获取代理对象</span></span><br><span class="line">    proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤四：修改我们的VoucherOrderHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1. 获取队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</span></span><br><span class="line">                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.opsForStream().read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                        StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                        <span class="comment">//ReadOffset.lastConsumed()底层就是 &#x27;&gt;&#x27;</span></span><br><span class="line">                        StreamOffset.create(queueName, ReadOffset.lastConsumed()));</span><br><span class="line">                <span class="comment">//2. 判断消息是否获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (records == <span class="literal">null</span> || records.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3. 消息获取成功之后，我们需要将其转为对象</span></span><br><span class="line">                MapRecord&lt;String, Object, Object&gt; record = records.get(<span class="number">0</span>);</span><br><span class="line">                Map&lt;Object, Object&gt; values = record.getValue();</span><br><span class="line">                <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//4. 获取成功，执行下单逻辑，将数据保存到数据库中</span></span><br><span class="line">                handleVoucherOrder(voucherOrder);</span><br><span class="line">                <span class="comment">//5. 手动ACK，SACK stream.orders g1 id</span></span><br><span class="line">                stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;订单处理异常&quot;</span>, e);</span><br><span class="line">                <span class="comment">//订单异常的处理方式我们封装成一个函数，避免代码太臃肿</span></span><br><span class="line">                handlePendingList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0</span></span><br><span class="line">            List&lt;MapRecord&lt;String, Object, Object&gt;&gt; records = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                    Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                    StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                    StreamOffset.create(queueName, ReadOffset.from(<span class="string">&quot;0&quot;</span>)));</span><br><span class="line">            <span class="comment">//2. 判断pending-list中是否有未处理消息</span></span><br><span class="line">            <span class="keyword">if</span> (records == <span class="literal">null</span> || records.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//如果没有就说明没有异常消息，直接结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3. 消息获取成功之后，我们需要将其转为对象</span></span><br><span class="line">            MapRecord&lt;String, Object, Object&gt; record = records.get(<span class="number">0</span>);</span><br><span class="line">            Map&lt;Object, Object&gt; values = record.getValue();</span><br><span class="line">            <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(values, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//4. 获取成功，执行下单逻辑，将数据保存到数据库中</span></span><br><span class="line">            handleVoucherOrder(voucherOrder);</span><br><span class="line">            <span class="comment">//5. 手动ACK，SACK stream.orders g1 id</span></span><br><span class="line">            stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;处理pending-list异常&quot;</span>);</span><br><span class="line">            <span class="comment">//如果怕异常多次出现，可以在这里休眠一会儿</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h1><p>修改点赞功能，利用Redis中的set集合来判断是否点赞过，未点赞则点赞数+1，已点赞则点赞数-1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户信息</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isLiked</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());</span><br><span class="line">    <span class="keyword">if</span> (BooleanUtil.isFalse(isLiked)) &#123;</span><br><span class="line">        <span class="comment">//点赞数 +1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//将用户加入set集合</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//点赞数 -1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span> (success)&#123;</span><br><span class="line">            <span class="comment">//从set集合移除</span></span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h1><p>实现：使用Redis SortedSet（自动按score排序的数据结构），把用户点赞时间作为score，使用ZRange范围查询TopN<br>修改代码likeBlog,存储点赞用户的时候还要有能区分先后顺序的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户信息</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 如果当前用户未点赞，则点赞数 +1，同时将用户加入set集合</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">//尝试获取score</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">    <span class="comment">//为null，则表示集合中没有该用户</span></span><br><span class="line">    <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//点赞数 +1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="comment">//将用户加入set集合</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 如果当前用户已点赞，则取消点赞，将用户从set集合中移除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//点赞数 -1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="comment">//从set集合移除</span></span><br><span class="line">            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">    <span class="comment">//zrange key 0 4  查询zset中前5个元素</span></span><br><span class="line">    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//如果是空的(可能没人点赞)，直接返回一个空集合</span></span><br><span class="line">    <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//将ids使用`,`拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排</span></span><br><span class="line">    <span class="comment">//所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">    <span class="comment">//select * from tb_user where id in (ids[0], ids[1] ...) order by field(id, ids[0], ids[1] ...)</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.query().in(<span class="string">&quot;id&quot;</span>, ids)</span><br><span class="line">            .last(<span class="string">&quot;order by field(id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">            .list().stream()</span><br><span class="line">            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这边的ids是取出来就是按照点赞时间排序的，假设点赞的是[5,1],所以要查5和1两个用户，同时5在前，但是一般的查询有下面的问题</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `tb_user` <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679819565995-204a993e-6d1b-4215-81e2-efa0222203bf.png#averageHue=%23f5f2f0&clientId=u7fe237e5-bb7e-4&from=paste&height=57&id=u812b333d&name=image.png&originHeight=86&originWidth=510&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5969&status=done&style=none&taskId=u5842c336-5424-48dd-8ebf-aa6ee105bd5&title=&width=340#averageHue=%23f5f2f0&id=Wb6MF&originHeight=86&originWidth=510&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>查询出来变成了1号用户在前面</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `tb_user` <span class="keyword">where</span> id <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> FIELD(id,<span class="number">5</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679819711378-6ebee88a-ef6e-4b95-9a75-9ae92a027a5f.png#averageHue=%23f5f2f0&clientId=u7fe237e5-bb7e-4&from=paste&height=57&id=u95be7968&name=image.png&originHeight=86&originWidth=504&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5804&status=done&style=none&taskId=u2083ad3d-1588-4431-aa7e-bf51ec7267f&title=&width=336#averageHue=%23f5f2f0&id=PRsQ5&originHeight=86&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>这边使用到了mybatis的last</p><h1 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h1><p>需求:计算两个人共同关注的所有用户<br>思路: 本质就是求两个用户关注集合的 <strong>交集</strong><br>实现: 使用 Redis Set 数据结构，每个 key 保存 1个用户的关注集合 (取关时从集合中移除对应用户)，最后对 2 个用户对应的 set 进行 intersect取交集操作即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">follow</span><span class="params">(Long followUserId, Boolean isFellow)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">//判断是否关注</span></span><br><span class="line">    <span class="keyword">if</span> (isFellow) &#123;</span><br><span class="line">        <span class="comment">//关注，则将信息保存到数据库</span></span><br><span class="line">        <span class="type">Follow</span> <span class="variable">follow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Follow</span>();</span><br><span class="line">        follow.setUserId(userId);</span><br><span class="line">        follow.setFollowUserId(followUserId);</span><br><span class="line">        <span class="comment">//如果保存成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> save(follow);</span><br><span class="line">        <span class="comment">//则将数据也写入Redis</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//取关，则将数据从数据库中移除</span></span><br><span class="line">        LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, followUserId);</span><br><span class="line">        <span class="comment">//如果取关成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> remove(queryWrapper);</span><br><span class="line">        <span class="comment">//则将数据也从Redis中移除</span></span><br><span class="line">        <span class="keyword">if</span> (success)&#123;</span><br><span class="line">            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现公共关注代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;follows:&quot;</span> + userId;</span><br><span class="line">    <span class="comment">//对当前用户和博主用户的关注列表取交集</span></span><br><span class="line">    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);</span><br><span class="line">    <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//无交集就返回个空集合</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果转为list</span></span><br><span class="line">    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//之后根据ids去查询共同关注的用户，封装成UserDto再返回</span></span><br><span class="line">    List&lt;UserDTO&gt; userDTOS = userService.listByIds(ids).stream().map(user -&gt;</span><br><span class="line">            BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Feed流关注推送"><a href="#Feed流关注推送" class="headerlink" title="Feed流关注推送"></a>Feed流关注推送</h1><p>场景：当我们关注了用户之后，这个用户发布了动态，那我们应该把这些数据推送给用户，这个需求，我们又称其为Feed流，关注推送也叫作Feed流，直译为投喂，为用户提供沉浸式体验，通过无限下拉刷新获取新的信息，</p><ul><li>Feed流的实现有两种模式 <ol><li>Timeline：不做内容筛选，简单的按照内容<code>发布时间</code>排序，常用于好友或关注(B站关注的up，朋友圈等) <ul><li>优点：信息全面，不会有缺失，并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul></li><li>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容，推送用户<code>感兴趣</code>的信息来吸引用户 <ul><li>优点：投喂用户感兴趣的信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能会起到反作用（给你推的你都不爱看）</li></ul></li></ol></li><li>那我们这里针对好友的操作，采用的是Timeline方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</li></ul><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="拉模式（读扩散）"><a href="#拉模式（读扩散）" class="headerlink" title="拉模式（读扩散）"></a>拉模式（读扩散）</h3><ul><li>该模式的核心含义是：当张三和李四、王五发了消息之后，都会保存到自己的发件箱中，如果赵六要读取消息，那么他会读取他自己的收件箱，此时系统会从他关注的人群中，将他关注人的信息全都进行拉取，然后进行排序</li><li>优点：比较节约空间，因为赵六在读取信息时，并没有重复读取，并且读取完之后，可以将他的收件箱清除</li><li>缺点：有延迟，当用户读取数据时，才会去关注的人的时发件箱中拉取信息，假设该用户关注了海量用户，那么此时就会拉取很多信息，对服务器压力巨大</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831142177-eec16b9f-5547-44c4-a315-b3247d3f78ef.png#averageHue=%23fcfcfb&clientId=ucc2cc29c-dcb2-4&from=paste&id=u0b810fd4&name=image.png&originHeight=636&originWidth=1477&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=299204&status=done&style=none&taskId=u1bd1e78a-ed8b-4219-94ea-0455d2e3d1a&title=#averageHue=%23fcfcfb&id=AW2pd&originHeight=636&originWidth=1477&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h3><ul><li>推模式是没有写邮箱的，当张三写了一个内容，此时会主动把张三写的内容发送到它粉丝的收件箱中，假设此时李四再来读取，就不用再去临时拉取了</li><li>优点：时效快，不用临时拉取</li><li>缺点：内存压力大，假设一个大V发了一个动态，很多人关注他，那么就会写很多份数据到粉丝那边去</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831159323-c8b68aac-7238-4f04-bf4e-c0799217dcb5.png#averageHue=%23fdfdfd&clientId=ucc2cc29c-dcb2-4&from=paste&id=u9807b0c6&name=image.png&originHeight=714&originWidth=1102&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=246856&status=done&style=none&taskId=u41bcdc42-6f05-4639-ba22-b5bdb0701cd&title=#averageHue=%23fdfdfd&id=BjhwJ&originHeight=714&originWidth=1102&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h3><ul><li>推拉模式是一个折中的方案，站在发件人这一边，如果是普通人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝收件箱中，因为普通人的粉丝数量较少，所以这样不会产生太大压力。但如果是大V，那么他是直接将数据写入一份到发件箱中去，在直接写一份到活跃粉丝的收件箱中，站在收件人这边来看，如果是活跃粉丝，那么大V和普通人发的都会写到自己的收件箱里，但如果是普通粉丝，由于上线不是很频繁，所以等他们上线的时候，再从发件箱中去拉取信息。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831189183-35e6d385-a0c9-4c18-8024-d2134f558bed.png#averageHue=%23fcfcfb&clientId=ucc2cc29c-dcb2-4&from=paste&id=u718e9b37&name=image.png&originHeight=634&originWidth=1432&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=303923&status=done&style=none&taskId=uc950f982-89f8-488d-8a5f-bede7e15f14&title=#averageHue=%23fcfcfb&id=rEcsG&originHeight=634&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681815380922-aaf78d43-aa3a-42b6-a2a3-201deff42876.png#averageHue=%23f8f5f3&clientId=uf387f538-a383-4&from=paste&height=552&id=uc3e8a299&originHeight=828&originWidth=1880&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=223851&status=done&style=none&taskId=u4c43a7eb-70a9-40db-9fa0-0782301d700&title=&width=1253.3333333333333" alt="image.png"></p><h2 id="推模式实现"><a href="#推模式实现" class="headerlink" title="推模式实现"></a>推模式实现</h2><p>因为推送是按时间排序的，所以可以使用SortedSet 数据结构来保存，每个 key 表示一个用户的收件箱，value 为推送 id、score 为推送时间戳。<br>查询所有推送时直接遍历 SortedSet 即可</p><h3 id="分页问题"><a href="#分页问题" class="headerlink" title="分页问题"></a>分页问题</h3><ul><li>Feed流中的数据会不断更新，所以数据的角标也会不断变化，所以我们不能使用传统的分页模式</li><li>假设在t1时刻，我们取读取第一页，此时page &#x3D; 1，size &#x3D; 5，那么我们拿到的就是10<del>6这几条记录，假设t2时刻有发布了一条新纪录，那么在t3时刻，我们来读取第二页，此时page &#x3D; 2，size &#x3D; 5，那么此时读取的数据是从6开始的，读到的是6</del>2，那么我们就读到了重复的数据，所以我们要使用Feed流的分页，不能使用传统的分页</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831641147-58170514-b54f-4e34-abf5-7db96a18ef6e.png#averageHue=%23faf9f8&clientId=ucc2cc29c-dcb2-4&from=paste&id=ufc97b562&name=image.png&originHeight=642&originWidth=1494&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=221148&status=done&style=none&taskId=ub4b84472-7d90-451f-9db8-e0cc817c688&title=#averageHue=%23faf9f8&id=sONhM&originHeight=642&originWidth=1494&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br>因此，可以使用滚动分页，记录每次当前页查询到的最后一条数据的时间戳(类似游标) 。查询下一页时，从当前时间戳的下一条开始查询即可<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679831668181-4e4dd5d6-0b80-4dd0-a8e5-bb567e00e3a2.png#averageHue=%23f9f9f8&clientId=ucc2cc29c-dcb2-4&from=paste&id=ubebabba6&name=image.png&originHeight=657&originWidth=1480&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=220226&status=done&style=none&taskId=uc076c65c-6ac0-4f91-8810-5e8154de3ff&title=#averageHue=%23f9f9f8&id=MOoCB&originHeight=657&originWidth=1480&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取登录用户</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">    blog.setUserId(user.getId());</span><br><span class="line">    <span class="comment">// 保存探店博文</span></span><br><span class="line">    save(blog);</span><br><span class="line">    <span class="comment">// 条件构造器</span></span><br><span class="line">    LambdaQueryWrapper&lt;Follow&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从follow表最中，查找当前用户的粉丝  select * from follow where follow_user_id = user_id</span></span><br><span class="line">    queryWrapper.eq(Follow::getFollowUserId, user.getId());</span><br><span class="line">    <span class="comment">//获取当前用户的粉丝</span></span><br><span class="line">    List&lt;Follow&gt; follows = followService.list(queryWrapper);</span><br><span class="line">    <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">        <span class="comment">//推送数据</span></span><br><span class="line">        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回id</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现分页查询收件箱"><a href="#实现分页查询收件箱" class="headerlink" title="实现分页查询收件箱"></a>实现分页查询收件箱</h2><p>可以使用 <code>SortedSet</code> 的 <code>ZRevRangeByScore</code> 命令实现，每次查询指定时间戳范围 (0，当前最大时间戳)的指定条数的数据。示例命令: </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRevRangeByScore key 0 maxTimeStampoffset limit</span><br></pre></td></tr></table></figure><p>注意有个问题，可能出现相同时间戳戳的数据，因此第一次查询时 offset 为 0 (从第一条开始查)，之后每次查询，<code>offset</code> 为上一页中时间戳最小值的数量，保证不查出重复数据<br>比如 score 列表为: 5,4, 4,3,2,1。每页 3 条第一次查询 ZRevRangeByScore key 0 99999990 3 查出 5、4、4，最小值 4 重复 2 次，即下一次的最大值为 4、offset 为 2.所以第二次查询为 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZRevRangeByScore key 0 4 2</span><br></pre></td></tr></table></figure><p> 查出 3、2、1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/follow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(<span class="meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="meta">@RequestParam(value = &quot;offset&quot;,defaultValue = &quot;0&quot;)</span> Integer offset)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> blogService.queryBlogOfFollow(max,offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 查询该用户收件箱（之前我们存的key是固定前缀 + 粉丝id），所以根据当前用户id就可以查询是否有关注的人发了笔记</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> FEED_KEY + userId;</span><br><span class="line">    <span class="comment">// 2.表示每次查询两条，这边写死了</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typeTuples = stringRedisTemplate.opsForZSet()</span><br><span class="line">            .reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//3. 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (typeTuples == <span class="literal">null</span> || typeTuples.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 解析数据，blogId、minTime（时间戳）、offset，这里指定创建的list大小，可以略微提高效率，因为我们知道这个list就得是这么大</span></span><br><span class="line">    ArrayList&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typeTuples.size());</span><br><span class="line">    <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">os</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typeTuple : typeTuples) &#123;</span><br><span class="line">        <span class="comment">//4.1 获取id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> typeTuple.getValue();</span><br><span class="line">        ids.add(Long.valueOf(id));</span><br><span class="line">        <span class="comment">//4.2 获取score（时间戳）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typeTuple.getScore().longValue();</span><br><span class="line">        <span class="keyword">if</span> (time == minTime)&#123;</span><br><span class="line">            os++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            minTime = time;</span><br><span class="line">            os = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解决SQL的in不能排序问题，手动指定排序为传入的ids</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="comment">//5. 根据id查询blog</span></span><br><span class="line">    List&lt;Blog&gt; blogs = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD(id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        <span class="comment">//5.1 查询发布该blog的用户信息</span></span><br><span class="line">        queryBlogUser(blog);</span><br><span class="line">        <span class="comment">//5.2 查询当前用户是否给该blog点过赞</span></span><br><span class="line">        isBlogLiked(blog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 封装结果并返回</span></span><br><span class="line">    <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">    scrollResult.setList(blogs);</span><br><span class="line">    scrollResult.setOffset(os);</span><br><span class="line">    scrollResult.setMinTime(minTime);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GEO地理坐标计算"><a href="#GEO地理坐标计算" class="headerlink" title="GEO地理坐标计算"></a>GEO地理坐标计算</h1><h2 id="GEO数据类型"><a href="#GEO数据类型" class="headerlink" title="GEO数据类型"></a>GEO数据类型</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681816166386-ec9bc25f-94a6-4b1e-bc82-c900b4a63ba2.png#averageHue=%23f1f1f1&clientId=uf387f538-a383-4&from=paste&height=532&id=u667e9a76&originHeight=798&originWidth=1914&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=511613&status=done&style=none&taskId=u2c83c41c-cc11-4359-a5d5-3a212a41ee0&title=&width=1276" alt="image.png"><br>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据，常见的命令有</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member …]</span><br></pre></td></tr></table></figure><blockquote><ul><li>返回值：添加到sorted set元素的数⽬，但不包括已更新score的元素</li><li>复杂度：每⼀个元素添加是O(log(N)) ，N是sorted set的元素数量</li></ul></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD china 13.361389 38.115556 &quot;shanghai&quot; </span><br><span class="line">15.087269 37.502669 &quot;beijing&quot;</span><br></pre></td></tr></table></figure><ul><li>GEODIST：计算指定的两个点之间的距离并返回<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果两个位置之间的其中⼀个不存在， 那么命令返回空值。</li><li>指定单位的参数 unit 必须是以下单位的其中⼀个： <ul><li>m 表⽰单位为⽶。</li><li>km 表⽰单位为千⽶。</li><li>mi 表⽰单位为英⾥。</li><li>ft 表⽰单位为英尺。</li></ul></li><li>如果⽤户没有显式地指定单位参数， 那么 GEODIST 默认使⽤⽶作为单位。</li><li>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这⼀假设最⼤会造成 0.5% 的误差</li><li>返回值：计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值</li></ul></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEODIST china beijing shanghai km</span><br></pre></td></tr></table></figure><ul><li><p>GEOHASH：将指定member的坐标转化为hash字符串形式并返回</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOHASH key member [member …]</span><br></pre></td></tr></table></figure><blockquote><ul><li>通常使用表示位置的元素使用不同的技术，使用Geohash位置52点整数编码。由于编码和解码过程中所使用的初始最小和最大坐标不同，编码的编码也不同于标准。此命令返回一个标准的Geohash，在维基百科和geohash.org网站都有相关描述</li><li>返回值：一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应</li><li>复杂度：O(log(N)) for each member requested, where N is the number of elements in the sorted set</li></ul></blockquote></li><li><p>GEOPOS：返回指定member的坐标</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOPOS key member [member …]</span><br></pre></td></tr></table></figure><blockquote><ul><li>给定一个sorted set表示的空间索引，密集使用 geoadd 命令，它以获得指定成员的坐标往往是有益的。当空间索引填充通过 geoadd 的坐标转换成一个52位Geohash，所以返回的坐标可能不完全以添加元素的，但小的错误可能会出台。</li><li>因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复</li><li>返回值：GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。当给定的位置元素不存在时， 对应的数组项为空值</li><li>复杂度：O(log(N)) for each member requested, where N is the number of elements in the sorted set</li></ul></blockquote></li><li><p><strong>GEOGADIUS</strong>：指定圆心、半径，找到该园内包含的所有member，并按照与圆心之间的距离排序后返回，6.2之后已废弃</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] </span><br><span class="line">[COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure><blockquote><ul><li>范围可以使用以下其中一个单位： <ul><li>m 表示单位为米。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li></ul></li><li>在给定以下可选项时， 命令会返回额外的信息： <ul><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li><li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li></ul></li><li>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式： <ul><li>ASC: 根据中心的位置， 按照从近到远的方式返回位置元素。</li><li>DESC: 根据中心的位置， 按照从远到近的方式返回位置元素。</li></ul></li><li>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的</li><li>返回值： <ul><li>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。</li><li>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。</li><li>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回： <ul><li>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。</li></ul></li></ul></li></ul></blockquote></li></ul><blockquote><pre><code>  - geohash 整数。  - 由两个元素组成的坐标，分别为经度和纬度</code></pre></blockquote><ul><li><p><strong>GEOSEARCH</strong>：在指定范围内搜索member，并按照与制定点之间的距离排序后返回，范围可以使圆形或矩形，6.2的新功能</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOSEARCH key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] </span><br><span class="line">[BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</span><br></pre></td></tr></table></figure></li><li><p>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key，也是6.2的新功能</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOSEARCHSTORE destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] </span><br><span class="line">[BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] </span><br><span class="line">[ASC|DESC] [COUNT count [ANY]] [STOREDIST]</span><br></pre></td></tr></table></figure><blockquote><ul><li>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点</li><li>指定成员的位置被用作查询的中心。</li><li>关于 GEORADIUSBYMEMBER 命令的更多信息， 请参考 GEORADIUS 命令的文档</li><li>复杂度：O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index</li></ul></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679905745055-21f78ee4-cafd-46f5-8afc-9c7a6f3faac0.png#averageHue=%23d9d9d7&clientId=u81ddba6a-6d17-4&from=paste&height=254&id=ua45eb1f1&name=image.png&originHeight=381&originWidth=702&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=125167&status=done&style=none&taskId=u40913940-bf3a-49c0-a7e1-c4324d394fa&title=&width=468#averageHue=%23d9d9d7&id=WJVFt&originHeight=381&originWidth=702&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679905938665-a2152d6d-335a-41b6-8605-4eb8c625f405.png#averageHue=%23e3d7d7&clientId=u81ddba6a-6d17-4&from=paste&height=463&id=ufa21e9f1&name=image.png&originHeight=695&originWidth=1405&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=290918&status=done&style=none&taskId=u6dcfa38b-fd72-4885-8a13-341daf9636a&title=&width=936.6666666666666#averageHue=%23e3d7d7&id=f1xWg&originHeight=695&originWidth=1405&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><blockquote><ul><li>后台： <ul><li>查询所有的店铺信息</li><li>根据类型分类店铺</li><li>将店铺的部分信息（id，经纬度）按照分组存储到Redis</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 查询所有店铺信息</span></span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    <span class="comment">//2. 按照typeId，将店铺进行分组</span></span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="comment">//3. 逐个写入Redis</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//3.1 获取类型id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="comment">//3.2 获取同类型店铺的集合</span></span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            <span class="comment">//3.3 写入redis GEOADD key 经度 纬度 member</span></span><br><span class="line">            stringRedisTemplate.opsForGeo().add(key,<span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(),shop.getY()),shop.getId().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadShopData</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Shop&gt; shopList = shopService.list();</span><br><span class="line">    Map&lt;Long, List&lt;Shop&gt;&gt; map = shopList.stream().collect(Collectors.groupingBy(Shop::getTypeId));</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">typeId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        List&lt;Shop&gt; shops = entry.getValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">//GeoLocation 里面是name和point两个数据结构</span></span><br><span class="line">        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(shops.size());</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            <span class="comment">//将当前type的商铺都添加到locations集合中</span></span><br><span class="line">            locations.add(<span class="keyword">new</span> <span class="title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(shop.getId().toString(), <span class="keyword">new</span> <span class="title class_">Point</span>(shop.getX(), shop.getY())));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//批量写入</span></span><br><span class="line">        stringRedisTemplate.opsForGeo().add(key, locations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附近功能"><a href="#附近功能" class="headerlink" title="附近功能"></a>附近功能</h2><p>需求：查询你附近的商铺，以及每个商铺和你的距离，并且安装由近及远排序</p><ul><li>引入依赖:SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的pom.xml文件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/of/type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> shopService.queryShopByType(typeId,current,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopByType</span><span class="params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 判断是否需要根据距离查询</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 因为这个接口是复用的，x,y参数不是接口必须的，如果没有这个两个参数,就是按照热度排序</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || y == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据类型分页查询</span></span><br><span class="line">            Page&lt;Shop&gt; page = query()</span><br><span class="line">                .eq(<span class="string">&quot;type_id&quot;</span>, typeId)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(page.getRecords());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 计算分页查询参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (current - <span class="number">1</span>) * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> current * SystemConstants.MAX_PAGE_SIZE;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> SHOP_GEO_KEY + typeId;</span><br><span class="line">        <span class="comment">//3. 查询redis、按照距离排序、分页; 结果：shopId、distance</span></span><br><span class="line">        <span class="comment">//GEOSEARCH key FROMLONLAT x y BYRADIUS 5000 m WITHDIST LIMIT end</span></span><br><span class="line">        <span class="comment">// 商品类型 圆心 半径（默认m） </span></span><br><span class="line">        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = </span><br><span class="line">            stringRedisTemplate.opsForGeo().search(key,GeoReference.fromCoordinate(x, y),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Distance</span>(<span class="number">5000</span>),</span><br><span class="line">    RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));</span><br><span class="line">        <span class="keyword">if</span> (results == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4. 解析出id</span></span><br><span class="line">        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; from) &#123;</span><br><span class="line">            <span class="comment">//起始查询位置大于数据总量，则说明没数据了，返回空集合</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        HashMap&lt;String, Distance&gt; distanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(list.size());</span><br><span class="line">        <span class="comment">// skip跳过前from</span></span><br><span class="line">        list.stream().skip(from).forEach(result -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">shopIdStr</span> <span class="operator">=</span> result.getContent().getName();</span><br><span class="line">            ids.add(Long.valueOf(shopIdStr));</span><br><span class="line">            <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> result.getDistance();</span><br><span class="line">            distanceMap.put(shopIdStr, distance);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5. 根据id查询shop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">idsStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        List&lt;Shop&gt; shops = query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;ORDER BY FIELD( id,&quot;</span> + idsStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (Shop shop : shops) &#123;</span><br><span class="line">            <span class="comment">//设置shop的举例属性，从distanceMap中根据shopId查询</span></span><br><span class="line">            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shops);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>多个二进制位组成的数据结构，每个二进制位对应一个业务的两种互斥状态。比如: 10010011.<br>BitMap 的优点是可以用最小的代码 (1 个 bit)来保存业务含义，从而大幅节省空间、实现高效运算等。比如可以把某个二进制位从 0 改为 1</p><blockquote><p>底层是 string 类型，以字节为单位存储，所以 bit 的长度为 8 的倍数</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681817342128-bf9efc40-3cf8-4647-9039-e4cbe737fcff.png#averageHue=%23f1f1f1&clientId=uf387f538-a383-4&from=paste&height=259&id=ue98311ca&originHeight=389&originWidth=888&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=192225&status=done&style=none&taskId=u7ea54330-8152-40ab-8f98-c4659b696c8&title=&width=592" alt="image.png"></p><h2 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679913528034-a60a5d3c-7153-4e6f-81ba-6fa6b6587019.png#averageHue=%23f6f4f4&clientId=u81ddba6a-6d17-4&from=paste&height=197&id=u4725c995&name=image.png&originHeight=295&originWidth=1662&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=60368&status=done&style=none&taskId=u0626b572-581b-402a-9fb3-0c4ef194ef7&title=&width=1108#averageHue=%23f6f4f4&id=eRvwz&originHeight=295&originWidth=1662&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" alt="image.png"></p><ul><li>BitMap的操作命令有 <ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT：获取指定位置（offset）的bit值</li><li>BITCOUNT：统计BitMap中值为1的bit位的数量</li><li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP：将多个BitMap的结果做位运算（与、或、异或）</li><li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li></ul></li></ul><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>用 <code>BITSET</code> 设置某一天对应位置的 bit 值即可，需要查签到状态时可以用 <code>BITFIELD GET</code>取出整个 BitMap 的十进制值，再用 位运算 将十进制值转为业务需要的格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 获取当前用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//2. 获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">//3. 拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">//4. 获取今天是当月第几天(1~31)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">//5. 写入Redis  BITSET key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计连续签到天数"><a href="#统计连续签到天数" class="headerlink" title="统计连续签到天数"></a>统计连续签到天数</h2><p>可以先用 BITFIELD GET 取出整个 BitMap 的十进制值。然后循环右移，依次用1 去和BitMap 的最后一位进行<code>与运算</code>，即可得知当前位数是否为 1 (已签到)，配合计数器完成连续 1的统计。</p><ul><li>获取本月到今天为止的所有签到数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITFIELD key GET u[dayOfMonth] 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//5. 获取截止至今日的签到记录  BITFIELD key GET uDay 0</span></span><br><span class="line">List&lt;Long&gt; result = stringRedisTemplate.opsForValue()</span><br><span class="line">    .bitField(key, BitFieldSubCommands.create()</span><br><span class="line">            .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth))</span><br><span class="line">              .valueAt(<span class="number">0</span>));</span><br><span class="line"><span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        count++;</span><br><span class="line">    num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog (HLL) 是 Redis 的高级数据结构，使用概率学算法实现，可以用极低的内存实现不重复元素个数的统计。<br>用法和集合类似，插入元素、求不重复元素个数、合并多个 HLL 等<br>优点: 占用内存极低，不会超过 16 Kb<br>缺点: 基于概率统计，存在&lt; 0.81% 的误差<br>因此，它很适合用于 UV、PV 等数据量大、精度要求不高的统计。</p><ul><li>HyperLogLog(HLL)是从Loglog算法派生的概率算法，用户确定非常大的集合基数，而不需要存储其所有值，算法相关原理可以参考下面这篇文章：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a></li></ul><h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li><li>本博客的首页侧边栏就有本站访客量和本站总访问量，对应的就是UV和PV</li><li>通常来说PV会比UV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素。</li><li>UV统计在服务端做会很麻烦，因为要判断该用户是否已经统计过了，需要将统计过的信息保存，但是如果每个访问的用户都保存到Redis中，那么数据库会非常恐怖，那么该如何处理呢？</li></ul><p>只需要把用户 id 用PFADD 添加到 HLL 中，用 PFCOUNT 求值即可: 还可以用 PFMERGE合并多天的统计，来估算整月的 UV</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFADD key element [element...]</span><br><span class="line">summary: Adds the specified elements to the specified HyperLogLog</span><br><span class="line"></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line">Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</span><br><span class="line"></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br><span class="line">lnternal commands for debugging HyperLogLog values</span><br></pre></td></tr></table></figure><p>测试百万数据的统计</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHyperLogLog</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] users = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        j = i % <span class="number">1000</span>;</span><br><span class="line">        users[j] = <span class="string">&quot;user_&quot;</span> + i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">999</span>) &#123;</span><br><span class="line">            stringRedisTemplate.opsForHyperLogLog().add(<span class="string">&quot;HLL&quot;</span>, users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="string">&quot;HLL&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/43de.html"/>
      <url>/posts/43de.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>参考：<a href="https://javaguide.cn/java/jvm/memory-area.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">https://javaguide.cn/java/jvm/memory-area.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F</a></p></blockquote><p>Java程序的具体运行过程如下：</p><ol><li>Java源文件被编译器编译成字节码文件</li><li>JVM将字节码文件编译成对应操作系统的机器码</li><li>机器码调用相应操作系统的本地方法库执行相应的方法</li></ol><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。<br>JDK1.8和之前的版本略有不同，我们这里以JDK1.7和JDK1.8这两个版本为例介绍。<br>JDK1.7<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549410036-90c7236d-8a09-496b-8c48-d7a6adea79ab.png" alt="image.png"><br>JDK1.8<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549564819-26518ebd-f88c-4093-ba31-fea1211758e9.png" alt="image.png"><br><strong>线程私有的</strong>：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的</strong>：</p><ul><li>堆</li><li>方法区</li><li>直接内存（非运行时数据的一部分）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683550157412-b0e7c7e8-13df-4cf1-ae46-6393d80d39b8.png#averageHue=%23f8e6b1&clientId=ua79c1db5-d450-4&from=paste&height=653&id=u5c02a440&originHeight=882&originWidth=569&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=28977&status=done&style=none&taskId=u3ed5fb2e-32d7-4fd5-9172-26939920d5a&title=&width=421.4815112560068" alt="image.png"></p><h2 id="程序计数器：线程私有，无内存溢出问题"><a href="#程序计数器：线程私有，无内存溢出问题" class="headerlink" title="程序计数器：线程私有，无内存溢出问题"></a>程序计数器：线程私有，无内存溢出问题</h2><h2 id="虚拟机栈：线程私有，描述Java方法的执行过程"><a href="#虚拟机栈：线程私有，描述Java方法的执行过程" class="headerlink" title="虚拟机栈：线程私有，描述Java方法的执行过程"></a>虚拟机栈：线程私有，描述Java方法的执行过程</h2><h2 id="本地方法区：线程私有"><a href="#本地方法区：线程私有" class="headerlink" title="本地方法区：线程私有"></a>本地方法区：线程私有</h2><h2 id="堆：也叫做运行时数据区，线程共享"><a href="#堆：也叫做运行时数据区，线程共享" class="headerlink" title="堆：也叫做运行时数据区，线程共享"></a>堆：也叫做运行时数据区，线程共享</h2><p>在JVM运行过程中创建的对象和产生的数据都被存储在堆中，堆是被线程共享的内存区域，也是垃圾收集器进行垃圾回收的最主要的内存区域。由于现代JVM采用<strong>分代收集算法</strong>，因此Java堆从GC（Garbage Collection，垃圾回收）的角度还以细分为：<strong>新生代、老年代和永久代</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630793404-9b3b6bee-23d1-4cdb-a2f3-d8df84d58540.png#averageHue=%23fafaf9&clientId=u275002bd-b1a6-4&from=paste&height=401&id=uca692266&originHeight=541&originWidth=992&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=25692&status=done&style=none&taskId=u9e373ecb-226d-4e34-bde9-24ab7e825df&title=&width=734.8148667240049" alt="image.png"></p><h3 id="新生代📑"><a href="#新生代📑" class="headerlink" title="新生代📑"></a>新生代📑</h3><p>JVM的新生代是垃圾回收器的主要关注区域之一，也是Java程序中最常用的内存区域之一。新生代被分为三个不同的区域：Eden区、Survivor区和Old区。JVM创建的对象（除了大对象）会被放在新生代</p><ol><li>Eden区：是新生代中最大的一个区域，主要用于存放新创建的对象。当一个对象被创建时，它会被分配到Eden区中，经过一段时间后，如果该对象没有被任何其他引用指向，就会被移动到Survivor区中。 </li><li>Survivor From区：</li><li>Survivor To区：</li></ol><p>JVM的新生代采用复制算法进行垃圾回收，即将存活的对象复制到另一个空闲的区域中，以便减少垃圾回收器的扫描范围。这种算法的优点是可以减少扫描的范围，但缺点是需要更多的内存来存储复制后的对象。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代是Java虚拟机(JVM)中的一个重要的内存区域，用于存放生命周期较长、存活时间较长的对象。当一个对象被创建时，它会被分配到新生代中的Eden区或Survivor区中，如果经过多次垃圾回收后仍然存活，那么它就会被晋升到老年代中。</p><p>在老年代中，垃圾回收器不会进行复制算法，而是采用标记清除、标记整理、分代收集等方式进行垃圾回收。因为老年代中的对象生命周期较长，所以它们占用的内存也较大，如果使用复制算法，会浪费更多的内存空间。</p><p>老年代中的对象通常包含一些重要的信息，比如类元数据、常量池等，因此在进行垃圾回收时需要特别小心，以免误删重要对象导致程序出错。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>永久代是Java虚拟机(JVM)中的一个特殊的内存区域，主要用于存放类的信息、常量池、静态变量等。在JDK1.8及之前的版本中，永久代是JVM的一部分，而在JDK1.8中，永久代被移除并取代为元空间(Metaspace),但是一些老的应用程序仍然在使用永久代。</p><p>在永久代中，所有的类信息和常量池都被存储在一个叫做“类定义”的表格中，每个类都有一个唯一的标识符作为键值。当一个类被加载时，它的类定义会被复制到永久代中，并且在运行时可以通过类名来访问。</p><p>由于永久代的特殊作用，它在垃圾回收中具有重要的地位。在垃圾回收过程中，如果永久代中存在未被引用的对象，那么这些对象就会被认为已经死亡，并且可以被回收。但是由于永久代的特殊性质，垃圾回收器需要特别小心，以免误删重要对象导致程序出错。</p><h2 id="方法区：线程共享"><a href="#方法区：线程共享" class="headerlink" title="方法区：线程共享"></a>方法区：线程共享</h2><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629182248-e3c2609d-1dd2-491a-9304-cdc7f1a188aa.png#averageHue=%23f2fbf4&clientId=u275002bd-b1a6-4&from=paste&id=ua8435a7c&originHeight=177&originWidth=361&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=true&size=6293&status=done&style=none&taskId=ufe20066a-bf7a-45ad-9596-300804335f1&title=%E5%AF%B9%E8%B1%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8" alt="对象循环引用" title="对象循环引用"></p><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<br>下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629305757-0545fc81-98da-4b24-8a6e-ec79be5733b8.png#averageHue=%23f5fef7&clientId=u275002bd-b1a6-4&from=paste&id=u32975fbe&originHeight=541&originWidth=721&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=44067&status=done&style=none&taskId=uecf32805-1127-4af8-9030-e47f5405b0b&title=" alt="image.png"></p><h3 id="哪些对象可以作为GC-Roots"><a href="#哪些对象可以作为GC-Roots" class="headerlink" title="哪些对象可以作为GC Roots"></a>哪些对象可以作为GC Roots</h3><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="对象可以被回收，就代表一定会被回收吗？"><a href="#对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="对象可以被回收，就代表一定会被回收吗？"></a>对象可以被回收，就代表一定会被回收吗？</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 <code>finalize </code>方法，或 <code>finalize </code>方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h2 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。<br>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629511889-7f16b482-7a56-4001-9053-293de927737e.png#averageHue=%23a5d5d4&clientId=u275002bd-b1a6-4&from=paste&id=u02a3e29c&originHeight=451&originWidth=651&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=32144&status=done&style=none&taskId=u444eac74-6c75-4c59-8eb3-ff68efe92fb&title=" alt="image.png"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p> 为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629545584-086144bd-459b-486c-b312-bcf37e57c101.png#averageHue=%23f4fdf6&clientId=u275002bd-b1a6-4&from=paste&id=u55c6a486&originHeight=451&originWidth=741&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=37560&status=done&style=none&taskId=u6bd3b62e-c754-444e-b12b-8d2b2361c39&title=" alt="image.png"><br>改进了标记-清除算法，但依然存在下面的问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能就会变得很差</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p> 标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629673024-50bb9a34-5cc5-41dd-b5b9-039c7c94d94c.png#averageHue=%2391cbcc&clientId=u275002bd-b1a6-4&from=paste&id=ue0af7be4&originHeight=451&originWidth=661&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=31336&status=done&style=none&taskId=ub287cd0d-9b61-46a2-b4d8-dda4ccd9c25&title=" alt="image.png"><br>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，针对不同类型的对象类型，JVM采用了不同的垃圾回收算法。将 Java 堆分为新生代和老年代，新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，每次进行垃圾回收都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，可回收的对象相对较少<br>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“<strong>标记-清除</strong>”或“标记-整理”算法进行垃圾收集。<br>JVM将新生代进一步划分。JVM在运行过程中主要使用Eden区和Survivor From区，进行垃圾回收时会将Eden区和Survivor From区中存活的对象复制到Survivor To区，然后清理两个区的内存空间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630382838-fc023dfe-bf13-4a03-bd1e-11f81db51cf2.png#averageHue=%23f9f6ee&clientId=u275002bd-b1a6-4&from=paste&height=240&id=uf23644c4&originHeight=324&originWidth=845&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=12661&status=done&style=none&taskId=u76d2236b-2722-44e0-8d29-80a4b3cc947&title=&width=625.9259701429276" alt="image.png"><br><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？<br>根据上面的对分代收集算法的介绍回答。</p><h1 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h1><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。<br>Java中的四种引用类型包括：</p><ol><li>强引用(Strong Reference):是最常见的引用类型，如果一个对象被强引用指向，垃圾回收器就不会回收它。 </li><li>软引用(Soft Reference):用来描述一些还有用但并非必需的对象。只有当内存不足时，垃圾回收器才会回收被软引用指向的对象。 </li><li>弱引用(Weak Reference):用来描述非必需对象，但是比软引用更弱。如果一个对象只被弱引用所指向，那么垃圾回收器在下一次回收时就会回收它。 </li><li>虚引用(Phantom Reference):是最弱的引用类型，用来描述不可能存活的对象。如果一个对象只被虚引用所指向，那么垃圾回收器在任何时候都有可能回收它。</li></ol><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>Java堆内存分为新生代和老年代：新生代主要存储短期生命周期对象，适合使用复制算法进行垃圾回收；老年代主要存储长生命周期的对象，适合使用标记整理算法进行垃圾回收.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631816626-8133fe52-fd39-4b9f-ab52-26a570234e07.png#averageHue=%23fbf2eb&clientId=u275002bd-b1a6-4&from=paste&height=430&id=u13b342a1&originHeight=581&originWidth=1468&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=75257&status=done&style=none&taskId=ueefb1479-498d-44f4-afdb-80b29ef0b5b&title=&width=1087.4074842246362" alt="image.png"><br>JVM(Java虚拟机)垃圾收集器是用于自动管理堆内存的一组工具。它们的主要目标是尽可能地减少应用程序暂停时间，以提高应用程序的性能和响应能力。</p><p>以下是一些常见的JVM垃圾收集器：</p><ol><li>Serial收集器：这是默认的收集器，它使用单线程来标记和清除存活的对象。它适用于小型应用程序，因为它的缺点是垃圾回收时间较长，可能会导致应用程序暂停。 </li><li>Parallel收集器：这是一种多线程收集器，它可以利用多个CPU核心并行执行标记和清除操作，从而缩短垃圾回收时间。它适用于大型应用程序，但需要更多的系统资源。 </li><li>CMS收集器：这是一种低延迟收集器，它可以在应用程序运行时进行垃圾回收，而不会影响应用程序的性能。它适用于对响应时间要求较高的应用程序。 </li><li>G1收集器：这是一种基于区域的收集器，它将堆划分为多个大小相等的区域，并在这些区域内进行垃圾回收。它可以减少GC暂停时间并提高吞吐量。它适用于大型应用程序和高负载环境。</li></ol><p>JVM垃圾收集器的选择取决于应用程序的需求和环境。在选择垃圾收集器时，需要考虑应用程序的性质、硬件配置、可用内存等因素。</p><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><h3 id="Serial收集器：单线程，复制算法"><a href="#Serial收集器：单线程，复制算法" class="headerlink" title="Serial收集器：单线程，复制算法"></a>Serial收集器：单线程，复制算法</h3><p>Serial垃圾收集器基于复制算法实现，它是一个单线程收集器，在它正在进行垃圾收集时，必须暂停其它工作线程，直到垃圾收集完毕<br>特点：简单、高效<br>是Java虚拟机运行在Client模式下的新生代的默认垃圾处理器<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631968047-9ae37729-acbd-4099-8c4e-5766fa6c7bbf.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=ueda4f2cf&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=u43d8d21c-2fae-4754-b613-adde849c645&title=" alt="image.png"></p><h3 id="ParNew收集器：多线程，复制算法"><a href="#ParNew收集器：多线程，复制算法" class="headerlink" title="ParNew收集器：多线程，复制算法"></a>ParNew收集器：多线程，复制算法</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632203749-aa4e1baa-dc1f-40e9-8bcd-043597efb590.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u722ab4f7&originHeight=245&originWidth=853&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=23095&status=done&style=none&taskId=uedad3fd7-98d4-457a-9f86-55dad756f63&title=" alt="image.png"></p><h3 id="Parallel-Scavenge收集器：多线程，复制算法"><a href="#Parallel-Scavenge收集器：多线程，复制算法" class="headerlink" title="Parallel Scavenge收集器：多线程，复制算法"></a>Parallel Scavenge收集器：多线程，复制算法</h3><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632308217-b9c5b923-2fb8-401f-ba88-d9678cd79d5b.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=uceece797&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u978058f2-2415-4553-b2f3-b99efd0682c&title=" alt="image.png"><br><strong>这是 JDK1.8 默认收集器</strong></p><h2 id="老年代-1"><a href="#老年代-1" class="headerlink" title="老年代"></a>老年代</h2><h3 id="Serial-Old收集器：单线程，标记整理算法"><a href="#Serial-Old收集器：单线程，标记整理算法" class="headerlink" title="Serial Old收集器：单线程，标记整理算法"></a>Serial Old收集器：单线程，标记整理算法</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632429864-a623c075-fe2e-40c3-8ed4-f09c84941d19.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=u3fc3b7df&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=uda15cb43-7ea0-4939-b27b-79c006bbacc&title=" alt="image.png"></p><h3 id="Parallel-Old收集器：多线程，标记整理算法"><a href="#Parallel-Old收集器：多线程，标记整理算法" class="headerlink" title="Parallel Old收集器：多线程，标记整理算法"></a>Parallel Old收集器：多线程，标记整理算法</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632442127-02a1b005-0e75-48b1-97f8-696544f00177.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=u28ac7316&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u873b20f7-d26a-497c-9c7a-9669df7fb71&title=" alt="image.png"></p><h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong><br><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong><br>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632462911-869d143d-c390-4310-a541-ea3cdb9cebff.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=ubcf34b5e&originHeight=259&originWidth=1070&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27060&status=done&style=none&taskId=ucca971d1-af12-4c5d-8a6d-eebad040f40&title=" alt="image.png"><br>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong><br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632495542-8ffb84e3-2063-4feb-8814-4d10007c4fab.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u196f3523&originHeight=262&originWidth=999&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27690&status=done&style=none&taskId=u3fd59542-6ed5-48fa-8f17-62d4d92655b&title=" alt="image.png"><br><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/posts/5ea3.html"/>
      <url>/posts/5ea3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://juejin.cn/post/6844903919781412877">https://juejin.cn/post/6844903919781412877</a></p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li><code>并行</code>：指两个以上事件在<code>同一时刻</code>发生</li><li><code>并发</code>：指两个以上事件在<code>同一个时间段内</code>发生</li></ul><h1 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h1><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口⭐"><a href="#实现Runnable接口⭐" class="headerlink" title="实现Runnable接口⭐"></a>实现Runnable接口⭐</h3><p>将<code>线程</code>和<code>任务</code>分开</p><ul><li>Thread代表线程</li><li>Runnabl代表可运行的任务（线程要执行的代码） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>例如<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>java8以后可以使用·lambda精简代码·<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></li></ul><h3 id="FutureTask配合Thread（了解）"><a href="#FutureTask配合Thread（了解）" class="headerlink" title="FutureTask配合Thread（了解）"></a>FutureTask配合Thread（了解）</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><h3 id="继承方式和实现方式的区别"><a href="#继承方式和实现方式的区别" class="headerlink" title="继承方式和实现方式的区别"></a>继承方式和实现方式的区别</h3><p>区别：</p><ul><li>继承Thread类：线程代码存放在Thread子类的run（）方法中</li><li>实现Runnable接口：线程代码存放在接口的子类的run（）方法中</li></ul><p>实现方法的好处：</p><ul><li>避免了单继承的局限性</li><li>多个线程可以共享同一个接口实现类对象，非常适合多个相同线程来处理同一份资源</li></ul><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;Thread-&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> factory.newThread(runnable);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> factory.newThread(runnable);</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure><h3 id="Executor线程池-最推荐）"><a href="#Executor线程池-最推荐）" class="headerlink" title="Executor线程池(最推荐）"></a>Executor线程池(最推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread with Runnable started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">executor.execute(runnable);</span><br><span class="line">executor.execute(runnable);</span><br><span class="line">executor.execute(runnable);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="设置线程名称"><a href="#设置线程名称" class="headerlink" title="设置线程名称"></a>设置线程名称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(String name)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target, String name)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure><h3 id="获取当前线程"><a href="#获取当前线程" class="headerlink" title="获取当前线程"></a>获取当前线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="获取线程的名称"><a href="#获取线程的名称" class="headerlink" title="获取线程的名称"></a>获取线程的名称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul><li><p>设置线程的优先级</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setPriority(<span class="type">int</span> newPriority)</span><br></pre></td></tr></table></figure></li><li><p>获取线程的优先级</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getPriority()</span><br></pre></td></tr></table></figure><blockquote><p>其中 setPriority 方法需要一个整数，并且范围在 [1,10] 之间，通常推荐设置 Thread 类的三个优先级常量：<br>public final static int MIN_PRIORITY &#x3D; 1;<br>public final static int NORM_PRIORITY &#x3D; 5;<br>public final static int MAX_PRIORITY &#x3D; 10;</p></blockquote></li></ul><p><strong>注意</strong></p><ul><li>线程创建时继承的是父线程的优先级</li><li>优先级低只是获得调度的概率低，并非一定是在高优先级线程之后才会被调用</li></ul><h3 id="插入线程（了解）"><a href="#插入线程（了解）" class="headerlink" title="插入线程（了解）"></a>插入线程（了解）</h3><p>在Java中，<code>join</code> 方法是<code>Thread</code>类提供的一个方法，用于等待一个线程结束。当一个线程调用另一个线程的 <code>join</code> 方法时，当前线程会被阻塞，直到另一个线程执行完毕，或者等待指定的时间结束。<br><code>join</code> 方法有两种重载形式：</p><ul><li><code>join()</code>：等待该线程执行完成。</li><li><code>join(long millis)</code> 或 <code>join(long millis, int nanos)</code>：等待该线程指定的时间内执行完成。</li></ul><p>例如，下面的代码示例展示了如何使用 <code>join</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">    // 线程 t1 执行的代码</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">    // 线程 t2 执行的代码</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    t1.join(); // 等待 t1 线程执行完成</span><br><span class="line">    t2.join(1000); // 等待 t2 线程执行 1 秒钟</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    // 处理InterruptedException异常</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主线程继续执行</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们创建了两个线程 <code>t1</code> 和 <code>t2</code>，并分别启动它们。然后，我们在主线程中调用了 <code>t1.join()</code> 和 <code>t2.join(1000)</code> 方法，分别等待 <code>t1</code> 线程和 <code>t2</code> 线程执行完成。如果等待时间超时，那么当前线程会继续执行。<br><code>join</code> 方法的作用是让多个线程之间协调工作，等待其他线程完成后再继续执行。这种协作方式可以有效地避免多线程并发执行带来的竞态条件和数据不一致的问题。但是需要注意的是，如果一个线程的 <code>join</code> 方法被调用过多次，那么就会抛出 <code>InterruptedException</code> 异常。因此，需要在异常处理中处理这种情况。<br><code>join</code> 方法主要用于协调多个线程之间的执行顺序，通常用于以下场景：</p><ol><li>等待其他线程完成后再继续执行：在多线程程序中，如果一个线程依赖于另一个线程的执行结果，那么可以使用 <code>join</code> 方法等待其他线程完成后再继续执行。例如，在主线程中启动了多个子线程，需要等待所有子线程执行完成后再进行下一步操作，可以在主线程中使用 <code>join</code> 方法等待所有子线程执行完成。 </li><li>控制多个线程的执行顺序：在多线程程序中，有时需要控制多个线程的执行顺序，例如按照某个规定的顺序依次执行多个任务。可以通过在每个线程中调用其他线程的 <code>join</code> 方法来实现控制执行顺序的目的。 </li><li>等待资源的释放：在多线程程序中，如果多个线程需要访问共享资源，可能会出现竞态条件和数据不一致的问题。可以使用 <code>join</code> 方法等待其他线程释放资源后再进行操作，从而避免竞态条件和数据不一致的问题。</li></ol><p>需要注意的是，<code>join</code> 方法可能会导致线程的阻塞，因此在使用时需要根据具体的场景进行灵活的设计和调整。同时，如果使用不当， <code>join</code> 方法可能会导致死锁或线程饥饿等问题，因此需要谨慎使用。</p><h3 id="线程礼让（了解）"><a href="#线程礼让（了解）" class="headerlink" title="线程礼让（了解）"></a>线程礼让（了解）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">yield</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>暂停当前正在执行的线程，把执行机会让给优先级相同或者更高的线程</li><li>若队列中没有同优先级的线程，忽略此方法</li></ul><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ul><li>调用sleep会让当前线程从Running进入Timed Waiting转态（阻塞）</li><li>其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException </li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全的原因"><a href="#线程安全的原因" class="headerlink" title="线程安全的原因"></a>线程安全的原因</h2><p>多线程环境下操作同一资源（成员变量）</p><h2 id="线程安全的解决方法"><a href="#线程安全的解决方法" class="headerlink" title="线程安全的解决方法"></a>线程安全的解决方法</h2><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行</p><h3 id="旧的版本"><a href="#旧的版本" class="headerlink" title="旧的版本"></a>旧的版本</h3><p><code>同步机制</code></p><ul><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁对象)&#123; </span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁对象必须是唯一的</p></blockquote></li><li><p>同步方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">权限修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特点：</p><ul><li>同步方法是锁住方法里面所有的代码</li><li>锁对象不能自己指定<ul><li>非静态：this</li><li>静态：当前类的字节码文件对象</li></ul></li></ul></blockquote></li><li><p>示例：同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;出售第&quot;</span> + <span class="built_in">this</span>.tickets-- + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例：同步方法、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;出售第&quot;</span> + <span class="built_in">this</span>.tickets-- + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>synchronized 的锁是什么？ </p><ul><li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。</li><li>同步方法的锁：静态方法（ 类名.class ）、非静态方法（ this ）。</li><li>同步代码块：自己指定，很多时候也是指定为 this 或 类名.class 。<br>注意事项：<br>必须确保使用同一个资源的 多个线程共用一把锁 ，这个非常重要，否则就无法保证共享资源的安全。<br>一个线程类中的所有静态方法共用同一把锁（ 类名.class ），所有非静态方 法共用同一把锁（ this ），同步代码块（指定需谨慎）。</li></ul><h3 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h3><ul><li>从 JDK 5.0 开始，Java 提供了更强大的线程同步机制——通过显式定义同 步锁对象来实现同步</li><li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Loc k对象加锁，线程开始访问共享资源之前应先获得 Lock 对象。 </li><li><code>ReentrantLock</code> 类实现了 <code>Lock</code> ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock ，可以显式加锁、释放锁</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁： </p><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。</li></ul><p>解决方法：</p><ul><li>专门的算法、原则。</li><li>尽量减少同步资源的定义。</li><li>尽量避免嵌套同步。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;线程A&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程A获取A锁，等待B锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A获取B锁&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;...线程A结束&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;线程B&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B获取B锁，等待A锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程B获取A锁&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;...线程B结束&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679708229503-70f4b5f5-e958-4998-83cd-bed2ae440eb8.png#averageHue=%23fbf9f7&clientId=u1c75dec8-961c-4&from=paste&height=346&id=u28797d69&originHeight=519&originWidth=384&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47746&status=done&style=none&taskId=u95bc8cd5-ada1-4388-baa7-517c08b42a9&title=&width=256" alt="image.png"></li></ul><h3 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h3><ul><li>Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码锁和方法锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（体统更多子类）</li></ul><h2 id="ReentrantLock⭐"><a href="#ReentrantLock⭐" class="headerlink" title="ReentrantLock⭐"></a>ReentrantLock⭐</h2><p><code>ReentrantLock</code> 是 Java 提供的一种<strong>可重入</strong>的互斥锁，它与 <code>synchronized</code> 相比，具有更高的灵活性和扩展性。<code>ReentrantLock</code> 提供了以下特性：</p><ol><li>可重入：同一个线程可以对一个 <code>ReentrantLock</code> 对象多次加锁而不会发生死锁。</li><li>公平性：可以选择指定公平锁或非公平锁。公平锁能够保证线程获得锁的顺序与线程等待的顺序一致，而非公平锁则允许插队，可能会导致某些线程一直无法获得锁。</li><li>中断响应：支持线程中断，即当一个线程在等待锁的过程中，可以通过中断响应来退出等待。</li><li>条件变量支持：可以通过 <code>ReentrantLock</code> 创建一个或多个 <code>Condition</code> 对象，使线程能够在条件变量满足时等待或唤醒。</li></ol><p>下面是一个使用 <code>ReentrantLock</code> 的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Calculation &#123;</span><br><span class="line">    private static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int n = 10000000;</span><br><span class="line">        int[] nums = new int[n];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int finalSum = sum;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for (int i = 0; i &lt; n / 2; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                finalSum += sum;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for (int i = n / 2; i &lt; n; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                finalSum += sum;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;计算结果：&quot; + finalSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个 <code>ReentrantLock</code> 对象 <code>lock</code>。然后在两个子线程中分别使用 <code>lock</code> 对象来保证对共享变量 <code>finalSum</code> 的互斥访问。具体来说，在每个子线程中，我们首先调用 <code>lock</code> 方法获取锁，然后在 <code>try-finally</code> 代码块中执行计算任务，并在 <code>finally</code> 块中调用 <code>unlock</code> 方法释放锁，以确保在任何情况下都能释放锁。</p><p>需要注意的是，如果在加锁之后发生异常，必须在 <code>finally</code> 块中释放锁，否则会导致死锁。此外，如果没有正确释放锁，可能会导致其他线程无法获取锁而一直等待，从而出现死锁等问题。因此，在使用 <code>ReentrantLock</code> 时应该特别注意锁的释放。<br><code>ReentrantLock</code> 提供了许多方法，包括：</p><ol><li><code>lock()</code>：获取锁，如果锁已经被其他线程持有，则当前线程会被<strong>阻塞</strong>，直到获取到锁。</li><li>lockInterruptibly()：获取锁，如果锁已经被其他线程持有，则当前线程会被阻塞，直到获取到锁或者<strong>当前线程被中断</strong>。</li><li><code>unlock()</code>：释放锁。</li><li><code>tryLock()</code>：尝试获取锁，如果锁没有被其他线程持有，则获取锁并返回 <code>true</code>，否则立即返回 <code>false</code>，不会阻塞当前线程。</li><li><code>tryLock(long timeout, TimeUnit unit)</code>：尝试在指定的时间内获取锁，如果在超时时间内没有获取到锁，则返回 <code>false</code>，否则返回 <code>true</code>。</li><li><code>newCondition()</code>：创建一个与该锁绑定的条件变量，用于在某个条件满足时等待或唤醒线程。</li><li><code>getHoldCount()</code>：返回当前线程持有该锁的次数。</li><li><code>isHeldByCurrentThread()</code>：判断当前线程是否持有该锁。</li><li><code>isLocked()</code>：判断锁是否被任何线程持有。</li><li><code>getQueueLength()</code>：返回等待获取该锁的线程数的估计值。</li><li><code>hasQueuedThreads()</code>：判断是否有线程正在等待获取该锁。</li></ol><p>这些方法可以帮助我们更加灵活地使用 <code>ReentrantLock</code>，实现更加高效和安全的多线程编程。需要注意的是，使用锁操作时一定要注意锁的粒度和锁的释放，避免出现死锁等问题。</p><h3 id="synchronized与ReentrantLock的异同点"><a href="#synchronized与ReentrantLock的异同点" class="headerlink" title="synchronized与ReentrantLock的异同点"></a>synchronized与ReentrantLock的异同点</h3><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中用于实现线程同步的机制，它们的主要异同点如下：<br>共同点：</p><ol><li>都用于控制多线程对共享对象的访问</li><li>都是可重入锁</li><li>都保证了可见性和互斥性</li></ol><p>不同点：</p><ol><li>实现方式不同：<code>synchronized</code> 是 JVM 内置的关键字，通过对象锁来实现线程同步；而 <code>ReentrantLock</code> 是第三方库 <code>java.util.concurrent</code> 中的一个类，通过显式地获取和释放锁来实现线程同步。 </li><li>可重入性不同：<code>synchronized</code> 是可重入的，即同一个线程可以多次获得同一个对象的锁；而 <code>ReentrantLock</code> 也是可重入的，但需要注意的是，如果在同一个方法中获取了该锁并再次调用该方法，则会自动解锁上一次获取的锁，因此需要手动释放锁。 </li><li>性能差异：<code>synchronized</code> 是轻量级的锁，开销较小，适用于低并发量的场景；而 <code>ReentrantLock</code> 是重量级的锁，开销较大，适用于高并发量的场景。 </li><li>功能扩展性不同：<code>ReentrantLock</code> 支持公平锁、非公平锁、定时锁等多种锁类型，还可以通过 Condition 接口实现等待&#x2F;通知机制，提供了更加灵活的控制能力；而 <code>synchronized</code> 则相对简单，只支持可重入锁。 </li><li>代码风格不同：<code>synchronized</code> 直接使用对象作为锁，代码简洁易读；而 <code>ReentrantLock</code> 需要手动获取和释放锁，需要编写更多的代码。</li></ol><p>综上所述，<code>synchronized</code> 适用于低并发量的场景，代码简单易读；而 <code>ReentrantLock</code> 则适用于高并发量的场景，提供更加灵活的控制能力。</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>虽然通常每个子线程只需要完成自己的任务，但是有时我们希望多个线程一起工作来完成一个任务，这就涉及到线程间通信。</p><h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><ul><li>等待唤醒机制是多线程的一种<code>协作</code>机制</li><li>等待唤醒机制就是在一个线程不满足某个条件时，就进入等待转态<code>wait()</code>,等待其它线程执行完它们的代码之后再将其唤醒<code>notify</code>或者可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果有需要，可以使用<code>notifyAll</code>来唤醒所有的等待线程，<code>wait/notify</code>就是线程间的一种协作机制<ul><li>wait（）：另线程挂起并放弃cpu、同步资源并等待，而当前线程排队等待其它线程调用<code>notify/notifyAll</code>方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行</li><li>notify:唤醒正在排队等待同步资源的线程中<strong>优先级最高者</strong>结束等待</li><li>notifyAll：唤醒正在排队等待资源的<strong>所有</strong>线程结束等待<blockquote><p>注意：</p><ul><li>被通知线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步代码块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁，成功之后才能在当初调用wait方法之后的地方恢复执行</li><li>如果能获取锁，线程就从WAITING 状态变成 RUNNABLE（可运行） 状态；否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li></ul></blockquote></li></ul></li></ul><h2 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h2><p>隐含的问题：</p><ol><li>线程安全问题：生产者和消费者共享数据缓冲区（可以使用同步解决）</li><li>线程的协调工作问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 缓冲区大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 缓冲区锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">bufferNotEmpty</span> <span class="operator">=</span> lock.newCondition();  <span class="comment">// 缓冲区非空条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">bufferNotFull</span> <span class="operator">=</span> lock.newCondition();  <span class="comment">// 缓冲区未满条件变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(), <span class="string">&quot;Producer 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(), <span class="string">&quot;Producer 2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(), <span class="string">&quot;Consumer 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(), <span class="string">&quot;Consumer 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (buffer.size() == BUFFER_SIZE) &#123;  <span class="comment">// 缓冲区已满，等待消费者消费</span></span><br><span class="line">                        bufferNotFull.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> produceItem();</span><br><span class="line">                    buffer.offer(item);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;[%s] Produced item %d, buffer size = %d%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(), item, buffer.size());</span><br><span class="line">                    bufferNotEmpty.signalAll();  <span class="comment">// 唤醒等待的消费者</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">produceItem</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 生成一个随机整数作为生产的物品</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (buffer.isEmpty()) &#123;  <span class="comment">// 缓冲区为空，等待生产者生产</span></span><br><span class="line">                        bufferNotEmpty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> buffer.poll();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;[%s] Consumed item %d, buffer size = %d%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(), item, buffer.size());</span><br><span class="line">                    bufferNotFull.signalAll();  <span class="comment">// 唤醒等待的生产者</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    buffer.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="sleep和wait方法的区别"><a href="#sleep和wait方法的区别" class="headerlink" title="sleep和wait方法的区别"></a>sleep和wait方法的区别</h2><ol><li>sleep不释放锁，wait释放锁</li><li>sleep指定休眠时间，wait可以指定时间也可以无限等待直到<code>notify</code>或<code>notifyAll</code></li><li>sleep在<strong>Thread类</strong>中声明的静态方法，wait在<strong>Object</strong>类中声明</li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><ol><li>创建一个空池子</li><li>提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可</li><li>但是如果在提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li>创建线程池</li><li>提交任务</li><li>所有的任务全部执行完毕，关闭线程池（实际开发中并不需要关闭，服务器时24小时运行）</li></ol><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p><code>Executors</code>:线程池的工具类通过调用方法返回不同类型的线程池对象<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681870944310-5acf92a7-eaab-4b72-bb45-14537249bccb.png#averageHue=%23d8b6b1&clientId=u1c9ab09a-5537-4&from=paste&height=105&id=u4dadf50d&originHeight=158&originWidth=1279&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=102641&status=done&style=none&taskId=u1e1e5c23-1dad-429d-ab06-d4dbd121dc3&title=&width=852.6666666666666" alt="image.png"><br>第一种并发没有上限，是Inter类型的最大值，还没到最大值，程序就会报错</p><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool.submit(task);</span><br></pre></td></tr></table></figure><h2 id="创建自己的线程池对象"><a href="#创建自己的线程池对象" class="headerlink" title="创建自己的线程池对象"></a>创建自己的线程池对象</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871350548-ef5e207b-a1dc-49a0-bfea-f34d557ab8d4.png#averageHue=%23f1efef&clientId=u1c9ab09a-5537-4&from=paste&height=447&id=u58ae749b&originHeight=671&originWidth=1747&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=321587&status=done&style=none&taskId=u35751981-8bbb-4565-803c-01629d7e533&title=&width=1164.6666666666667" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871563483-fd9ca18a-b42e-4779-90d7-91e359217417.png#averageHue=%23f7f7ee&clientId=u1c9ab09a-5537-4&from=paste&height=288&id=ud5207367&originHeight=432&originWidth=1111&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=297688&status=done&style=none&taskId=u5aff1da6-6c13-4501-bd9a-1f7e999a78e&title=&width=740.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871668535-83d8df23-2d16-4609-9e60-e1e22cea740c.png#averageHue=%23f6f4e6&clientId=u1c9ab09a-5537-4&from=paste&height=214&id=uca8a5dec&originHeight=321&originWidth=983&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=273746&status=done&style=none&taskId=uc6f5e056-1b74-41c6-8522-180f93c345e&title=&width=655.3333333333334" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871497101-faa98790-58e5-4701-be24-3ca3bff2a5ca.png#averageHue=%23e6d4d2&clientId=u1c9ab09a-5537-4&from=paste&height=441&id=u9c1a2b05&originHeight=662&originWidth=2105&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=439782&status=done&style=none&taskId=ue245e4cc-ee28-4dde-b6ca-6469a3dfcd4&title=&width=1403.3333333333333" alt="image.png"></p><h3 id="查看可用处理器数目（最大并行数）"><a href="#查看可用处理器数目（最大并行数）" class="headerlink" title="查看可用处理器数目（最大并行数）"></a>查看可用处理器数目（最大并行数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure><h3 id="线程池多大合适？"><a href="#线程池多大合适？" class="headerlink" title="线程池多大合适？"></a>线程池多大合适？</h3><ul><li>CPU密集型运算：最大并行数+1</li><li>I&#x2F;O密集型运算（读取文件、数据库）：<img src="https://cdn.nlark.com/yuque/__latex/9b8980040e79b72511d5d9559f6d29bd.svg#card=math&code=%E6%9C%80%E5%A4%A7%E5%B9%B6%E8%A1%8C%E6%95%B0%20%2A%20%E6%9C%9F%E6%9C%9BCPU%E5%88%A9%E7%94%A8%E7%8E%87%20%2A%20%5Cfrac%7B%E6%80%BB%E6%97%B6%E9%97%B4%28CPU%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%2B%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%29%7D%7BCPU%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%7D%0A&id=CdyHr"></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681872353293-8cd9cd32-3765-4607-a1df-c571eab51c53.png#averageHue=%23fcf7f4&clientId=u1c9ab09a-5537-4&from=paste&height=245&id=ue299c14d&originHeight=367&originWidth=1836&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=199105&status=done&style=none&taskId=u28deaa81-4db3-4986-b182-1ada3da8c06&title=&width=1224" alt="image.png"></p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679706512475-c00a3ecc-ddf8-49b4-a254-2d05774d8df6.png#averageHue=%23f5e0de&clientId=u1c75dec8-961c-4&from=paste&height=278&id=u088e7159&originHeight=417&originWidth=1228&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=208087&status=done&style=none&taskId=u1fa0c57d-016d-4555-b1df-299771e4654&title=&width=818.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683633428068-3e129e6c-7d09-4cd4-a7b6-dcbed6eaf45c.png#averageHue=%23fafaf9&clientId=u8ead2036-f886-4&from=paste&height=407&id=u361703ad&originHeight=550&originWidth=1375&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=44023&status=done&style=none&taskId=ua5e769c9-22b6-44e7-a104-c74436c0f3b&title=&width=1018.5185904692607" alt="image.png"><br>Java中的线程生命周期可以分为以下6个状态：</p><ol><li>新建状态（New）：当一个Thread类或者其子类的实例被创建时，该线程就处于新建状态。此时，线程并没有开始运行，只是给线程分配了必要的资源。 </li><li>就绪状态（Runnable）：当线程处于就绪状态时，表示线程已经准备好了运行，只是还没有得到CPU的执行权。此时，线程处于等待CPU的状态。 </li><li>运行状态（Running）：当线程获得CPU的执行权时，进入运行状态。此时，线程真正开始运行，执行自己的任务。 </li><li>阻塞状态（Blocked）：当线程被阻塞时，表示线程暂时停止了执行。线程进入阻塞状态有多种原因，如等待某个资源（比如输入输出、网络连接等），或者等待另一个线程的操作完成等。 阻塞状态分为以下三种</li><li>等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（Waitting Queue）中，线程转为阻塞状态</li><li>同步阻塞：在运行的线程尝试获取正在被其它线程占用的对象同步锁时，JVM会把该线程放入锁池（Lock Pool）中，线程转为阻塞状态</li><li>其它阻塞：运行状态的线程在执行sleep、join或者发出I&#x2F;O请求时，线程变为阻塞状态。直到sleep状态超时、join等待线程终止或者超时，I&#x2F;O处理完毕，线程才重新转为可运行状态。</li><li>等待状态（Waiting）：当线程进入等待状态时，表示线程暂时停止了执行，但是并没有被阻塞。线程进入等待状态有多种原因，比如调用了wait()、join()或者park()等方法。 </li><li>终止状态（Terminated）：当线程执行完自己的任务后，进入终止状态。此时，线程释放了占用的资源，线程对象也被销毁。</li></ol><p>需要注意的是，线程的状态不是线性的，线程可以在各个状态之间切换，当线程被唤醒时，它会从等待状态转换为就绪状态，等待CPU的调度再次执行。</p><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code> 是 Java 中的一个关键字，用来修饰变量，表示该变量是“<strong>易变的</strong>”，也就是可能被<strong>多个线程同时访问和修改</strong>。在多线程编程中，使用 <code>volatile</code> 可以保证变量的<strong>可见性</strong>和<strong>一致性</strong>，从而避免出现线程安全问题。<br>具体来说，<code>volatile</code> 主要有以下两个作用：</p><ol><li>变量的可见性：当一个变量被声明为 <code>volatile</code> 时，任何对该变量的修改都会立即被其他线程所看到，即使这些线程没有显式地进行同步操作。这是因为 JVM 会保证 <code>volatile</code> 变量的读写操作都是原子的，并且会在修改后立即刷新到主内存中，以便其他线程可以及时读取到最新的值。 </li><li>变量的禁止重排序：在多线程环境下，为了提高执行效率，JVM 可能会对指令进行重排序。但是，这种重排序可能会导致某些线程看到的变量值不一致。如果一个变量被声明为 <code>volatile</code>，那么 JVM 就会禁止对该变量进行重排序，从而保证变量的值不会出现意外的变化。</li></ol><p>需要注意的是，<code>volatile</code> 变量并不能完全替代锁（synchronized）来保证线程安全。虽然 <code>volatile</code> 可以保证变量的可见性和一致性，但是它并不能保证复合操作的原子性，也不能保证线程之间的互斥访问。如果需要进行复杂的状态转换或者涉及到多个变量的操作，还是需要使用锁来保证线程安全。<br>另外，需要注意的是，<code>volatile</code> 变量对于基本类型（如 <code>int</code>、<code>long</code> 等）和引用类型（如 <code>Object</code>、<code>String</code> 等）有不同的语义。对于基本类型，<code>volatile</code> 变量保证原子性和可见性；对于引用类型，<code>volatile</code> 变量只保证可见性，而不保证引用对象的状态的一致性，这时需要使用锁来保证线程安全。<br>下面是一个使用 <code>volatile</code> 关键字的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Counter</code> 类，其中包含一个 <code>count</code> 变量，用来记录计数器的值。由于 <code>count</code> 可能被多个线程同时访问和修改，因此我们将其声明为 <code>volatile</code> 变量，以保证其可见性和一致性。<br>在 <code>increment()</code> 方法中，我们对 <code>count</code> 变量进行了简单的自增操作。由于自增操作不是原子性的，可能会被多个线程同时执行，因此我们需要使用 <code>volatile</code> 关键字来保证对 <code>count</code> 变量的修改是原子性的，并且能够被其他线程及时看到。<br>在 <code>getCount()</code> 方法中，我们返回了 <code>count</code> 变量的值，由于 <code>count</code> 是 <code>volatile</code> 变量，因此我们可以保证返回的值是最新的，即使在多线程环境下。<br>需要注意的是，尽管 <code>volatile</code> 变量可以保证可见性和一致性，但是在多线程环境下，如果需要对 <code>count</code> 变量进行复合操作，例如加锁或者判断后再修改，仍然需要使用锁来保证线程安全。<br>下面是一个不需要使用 <code>volatile</code> 关键字的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Singleton</code> 类，其中包含一个私有的构造方法和一个静态的 <code>getInstance()</code> 方法，用来获取 <code>Singleton</code> 类的唯一实例。为了保证 <code>Singleton</code> 类的唯一性，我们使用了双重检查锁（Double-Checked Locking）的方式来实现懒汉式单例模式。</p><p>在 <code>getInstance()</code> 方法中，我们首先检查 <code>instance</code> 变量是否为 <code>null</code>，如果为 <code>null</code>，则使用 <code>synchronized</code> 关键字锁定 <code>Singleton.class</code> 对象，再次检查 <code>instance</code> 是否为 <code>null</code>，如果仍然为 <code>null</code>，则创建一个新的 <code>Singleton</code> 实例，并赋值给 <code>instance</code> 变量。由于使用了双重检查锁的方式，可以保证在多线程环境下，只有一个线程可以创建 <code>Singleton</code> 实例，并且其他线程可以获取到已创建的实例。</p><p>需要注意的是，在这个例子中，我们并没有使用 <code>volatile</code> 关键字来修饰 <code>instance</code> 变量。这是因为使用了双重检查锁的方式，可以保证在多线程环境下，对 <code>instance</code> 变量的读写操作是同步的，并且能够保证可见性和一致性，因此不需要使用 <code>volatile</code> 关键字来修饰 <code>instance</code> 变量。</p><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性（Atomicity）是指一个操作是不可中断的整体，<strong>要么全部完成，要么全部不完成</strong>，不会出现执行一半的情况。在多线程环境下，原子性是保证线程安全的重要因素之一。<br><code>++i</code> 和 <code>i++</code> 操作不是原子性的，因为它们实际上包含了两个操作：读取变量的值和修改变量的值。在多线程环境下，如果多个线程同时对同一个变量进行 <code>++i</code> 或 <code>i++</code> 操作，就可能出现竞争条件，导致结果不一致。</p><p>例如，假设初始时变量 <code>i</code> 的值为 0，现在有两个线程 <code>A</code> 和 <code>B</code> 同时对 <code>i</code> 进行 <code>++i</code> 操作，那么可能会出现以下情况：</p><ol><li>线程 <code>A</code> 读取 <code>i</code> 的值为 0。</li><li>线程 <code>B</code> 读取 <code>i</code> 的值为 0。</li><li>线程 <code>A</code> 将 <code>i</code> 的值加 1，得到 1。</li><li>线程 <code>B</code> 将 <code>i</code> 的值加 1，得到 1。</li></ol><p>最终，变量 <code>i</code> 的值只增加了 1，而不是 2。这就是因为 <code>++i</code> 和 <code>i++</code> 操作不是原子性的，多个线程对同一个变量进行操作时，可能会相互干扰，导致结果不一致。</p><p>为了保证 <code>++i</code> 和 <code>i++</code> 操作的原子性，可以使用 <code>AtomicInteger</code> 类或者锁来保证线程安全。例如，可以将变量 <code>i</code> 声明为 <code>AtomicInteger</code> 类型，或者使用 <code>synchronized</code> 关键字保证对变量的操作是同步的。</p><p>Java 中提供了一些原子性操作的类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code> 等，它们提供了一些基本的原子性操作，如增加、减少、比较等，能够保证这些操作的原子性。</p><p>下面是一个使用 <code>AtomicInteger</code> 类的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Counter</code> 类，其中包含一个 <code>count</code> 变量，类型为 <code>AtomicInteger</code>。由于 <code>AtomicInteger</code> 类提供了原子性操作，因此我们可以保证对 <code>count</code> 变量的增加操作是原子性的，并且不会出现线程安全问题。</p><p>在 <code>increment()</code> 方法中，我们调用了 <code>count.incrementAndGet()</code> 方法，该方法能够原子性地将 <code>count</code> 变量的值增加 1，并返回增加后的值。</p><p>在 <code>getCount()</code> 方法中，我们调用了 <code>count.get()</code> 方法，该方法能够原子性地返回 <code>count</code> 变量的当前值，即使在多线程环境下，我们也可以保证返回的值是最新的。</p><p>需要注意的是，尽管使用了 <code>AtomicInteger</code> 类，仍然需要注意线程安全问题，例如如果需要对 <code>count</code> 变量进行复合操作，例如判断后再修改，仍然需要使用锁来保证线程安全。</p><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><p>Java 提供了许多并发工具类，可以帮助开发者更方便地实现多线程编程，这些工具类包括：</p><ol><li><code>java.util.concurrent.locks</code>：提供了一组锁和同步器的实现，例如 <code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等。 </li><li><code>java.util.concurrent.atomic</code>：提供了一组原子性操作的类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code> 等。 </li><li><code>java.util.concurrent</code>：提供了一些并发集合类，例如 <code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>、<code>CopyOnWriteArrayList</code> 等。 </li><li><code>java.util.concurrent.Executor</code>：提供了一组执行任务的框架，例如 <code>ExecutorService</code>、<code>ScheduledExecutorService</code> 等。 </li><li><code>java.util.concurrent.Future</code>：提供了一组表示异步计算结果的接口，例如 <code>Future</code>、<code>CompletableFuture</code> 等。 </li><li><code>java.util.concurrent.atomic</code>：提供了一组原子性操作的类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code> 等。</li></ol><p>使用这些并发工具类，可以方便地实现多线程编程，提高程序的并发性能和可靠性。但是在使用这些工具类时，需要注意线程安全问题，避免出现竞争条件、死锁等问题。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code> 是 Java 中的一个并发工具类，用来控制并发访问的数量。它可以用来限制同时访问某个资源的线程数量，或者限制同时执行某个操作的线程数量。<br><code>Semaphore</code> 可以被看做是一个<strong>计数器</strong>，初始值为给定的数量，每当一个线程访问这个资源，计数器就减 1，当计数器为 0 时，所有试图访问这个资源的线程都将被阻塞，直到计数器再次变为正数。<br><code>Semaphore</code> 主要有两个常用的方法：</p><ul><li><code>acquire()</code>：获取一个许可，如果当前没有许可可用，则阻塞。 </li><li><code>release()</code>：释放一个许可，增加计数器的值。</li></ul><p>下面是一个使用 <code>Semaphore</code> 的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintQueue</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">// 执行打印操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>PrintQueue</code> 类，其中包含一个 <code>semaphore</code> 变量，类型为 <code>Semaphore</code>。在 <code>PrintQueue</code> 类的构造函数中，我们传入一个整数值，表示可以同时打印的线程数量。<br>在 <code>print()</code> 方法中，我们首先调用了 <code>semaphore.acquire()</code> 方法获取一个许可，如果当前没有许可可用，则阻塞。然后执行打印操作，最后调用 <code>semaphore.release()</code> 方法释放一个许可，增加计数器的值。<br>这样，我们就可以通过 <code>Semaphore</code> 来控制同时打印的线程数量，避免线程过多导致系统资源的浪费，从而提高程序的并发性能和可靠性。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code> 是 Java 中的一个并发工具类，用于控制多个线程之间的同步。它的作用是<strong>让某一个线程等待其他线程执行完毕之后再执行</strong>。<br><code>CountDownLatch</code> 主要有两个常用的方法：</p><ul><li><code>await()</code>：等待计数器变为 0，如果计数器不为 0，则阻塞等待。 </li><li><code>countDown()</code>：计数器减 1，如果计数器减为 0，则释放所有等待的线程。</li></ul><p>当一个任务需要等待多个线程完成后才能执行，可以使用 <code>CountDownLatch</code> 实现线程之间的协作，例如下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(numThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(latch));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;All threads have finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟执行任务</span></span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 计数器减 1</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了 5 个线程，并将它们的任务委托给 <code>Worker</code> 类。在 <code>Worker</code> 类的构造函数中，我们传入了一个 <code>CountDownLatch</code> 对象，它的计数器被初始化为 5。<br>在 <code>run()</code> 方法中，我们模拟了执行任务的过程，并在最后调用了 <code>latch.countDown()</code> 方法减少计数器的值。<br>在 <code>main</code> 函数中，我们创建了一个 <code>CountDownLatch</code> 对象，计数器被初始化为 5。然后创建了 5 个 <code>Worker</code> 线程，并启动这些线程。最后调用 <code>latch.await()</code> 方法等待所有线程执行完毕。<br>当所有线程的任务都完成后，<code>CountDownLatch</code> 对象的计数器会变为 0，<code>await()</code> 方法会返回，然后程序会输出 “All threads have finished.”。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code> 是 Java 中一个线程安全的哈希表实现，它可以在高并发环境下提供更好的性能和可伸缩性。</p><p>与 <code>Hashtable</code> 不同，<code>ConcurrentHashMap</code> 使用了<strong>分段锁机制</strong>，即将整个哈希表分成多个小的哈希表段，每个段都有一个独立的锁。这样，在多线程环境下，不同线程可以同时对不同的段进行读写操作，从而提高了并发性能。</p><p>此外，<code>ConcurrentHashMap</code> 也支持并发的读操作，即多个线程可以同时读取表中的元素而不需要互斥锁的保护。这是通过使用 <code>volatile</code> 关键字和一些特殊的算法实现的。</p><p>下面是一个使用 <code>ConcurrentHashMap</code> 的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 10 个线程，每个线程对表中一个键进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span> + num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> num;</span><br><span class="line">                map.put(key, value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put &quot;</span> + key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get &quot;</span> + key + <span class="string">&quot;: &quot;</span> + map.get(key));</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个 <code>ConcurrentHashMap</code> 对象，并创建了 10 个线程。每个线程对表中一个键进行操作，包括插入键值对和获取键对应的值。由于 <code>ConcurrentHashMap</code> 是线程安全的，因此可以保证在多线程环境下程序的正确性和较好的性能。</p><p>需要注意的是，虽然 <code>ConcurrentHashMap</code> 的并发性能很好，但是在某些情况下，它可能会比 <code>HashMap</code> 或者 <code>Hashtable</code> 略微慢一些，因为在并发操作时需要进行一些额外的逻辑处理。因此，在单线程环境下，使用 <code>ConcurrentHashMap</code> 可能不如 <code>HashMap</code> 或者 <code>Hashtable</code> 快速。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>在多线程环境下，如果多个线程同时对同一个数据结构进行修改，就可能会出现线程安全问题。Java 中的 <code>Hashtable</code> 是一种线程安全的哈希表，它可以在多线程环境下安全地进行读写操作。</p><p>具体来说，<code>Hashtable</code> 在实现上使用了同步锁，即每个方法都是同步的。当一个线程在使用 <code>Hashtable</code> 进行读写操作时，其他线程需要等待该线程完成操作并释放锁之后才能进行操作，从而保证了线程安全。</p><p>下面是一个使用 <code>Hashtable</code> 的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hashtable&lt;String, Integer&gt; table = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 10 个线程，每个线程对表中一个键进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span> + num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> num;</span><br><span class="line">                table.put(key, value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put &quot;</span> + key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get &quot;</span> + key + <span class="string">&quot;: &quot;</span> + table.get(key));</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个 <code>Hashtable</code> 对象，并创建了 10 个线程。每个线程对表中一个键进行操作，包括插入键值对和获取键对应的值。由于 <code>Hashtable</code> 是线程安全的，因此可以保证在多线程环境下程序的正确性。</p><p>需要注意的是，由于 <code>Hashtable</code> 的每个方法都是同步的，因此在高并发环境下，使用 <code>Hashtable</code> 可能会导致性能问题。如果不需要强制要求线程安全，可以考虑使用 <code>HashMap</code> 或者 <code>ConcurrentHashMap</code> 等非线程安全的数据结构，它们在性能上更有优势。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
