<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/posts/dc87.html"/>
      <url>/posts/dc87.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是抽象工厂模式"><a href="#什么是抽象工厂模式" class="headerlink" title="什么是抽象工厂模式"></a>什么是抽象工厂模式</h1><h2 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h2><p>抽象工厂模式（Abstract Factory Pattern）是一种<strong>创建型设计模式</strong>，它提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</p><p>抽象工厂模式通过定义<strong>抽象工厂</strong>和<strong>抽象产品</strong>来实现，具体工厂和具体产品则根据抽象工厂和抽象产品来实现。抽象工厂定义了创建一系列产品的接口，每个具体工厂实现了该接口，以创建不同的产品族；抽象产品定义了产品的接口，每个具体产品实现了该接口，以提供不同的产品种类。<br>产品族：一个品牌下面的所有产品；例如华为下面的手机，路由器，电脑 称为华为的产品族；<br>产品等级：多个品牌下面的同种产品；例如华为和小米下面的手 称为一个产品等级；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684584350390-df0c9b8d-1754-43a6-bdce-719d00366673.png#averageHue=%23f7f7f7&clientId=u74b4f415-608b-4&from=paste&id=u71f6936d&originHeight=345&originWidth=545&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=12291&status=done&style=none&taskId=u1e6058b0-bd04-4327-97eb-9b0545fac3d&title=" alt="image.png"></p><blockquote><p>拓展一个产品族</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684584688058-d3eb0af5-0bb5-4f56-b09d-779d5158c882.png#averageHue=%23fcf7f2&clientId=u74b4f415-608b-4&from=paste&id=ueda099b1&originHeight=873&originWidth=1663&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=399529&status=done&style=none&taskId=udb7e40fc-134b-4175-b81a-76c1e66940e&title=" alt="image.png"></p><blockquote><p>拓展一个产品等级</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684584658431-ae897668-6fd2-4cee-85ca-347e3e39b09e.png#averageHue=%23fcf9f5&clientId=u74b4f415-608b-4&from=paste&id=u28dfd4e6&originHeight=871&originWidth=1920&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=397740&status=done&style=none&taskId=u06e9f722-0138-4ccb-aa9a-fb773bdeea8&title=" alt="image.png"></p><ul><li>图片来源:<a href="https://blog.csdn.net/qq_33732195/article/details/110101808?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168458428216800182772849%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168458428216800182772849&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-110101808-null-null.142%5Ev87%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187">抽象工厂模式（通俗易懂）</a></li></ul><p>抽象工厂模式的目的是提供一个接口，使得客户端可以使用这个接口创建一系列相关或相互依赖的对象，而不需要知道具体的实现细节。这样客户端就可以从具体产品的实现中解耦出来，从而更加灵活地对待不同的产品种类。</p><p>在抽象工厂模式中，每个具体工厂只能创建一种产品族，但是可以创建多个不同的产品种类。因此，抽象工厂模式适用于需要创建一系列相关或相互依赖的对象，且这些对象的种类是固定的，但是需要根据不同的产品族进行选择的场景。</p><h2 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h2><p>抽象工厂模式（Abstract Factory Pattern）具有以下优点：</p><ol><li><strong>分离接口和实现</strong>：抽象工厂模式将接口和实现分离开来，客户端只需要关注接口，而不需要知道具体的实现细节，从而实现解耦。 </li><li><strong>隐藏细节</strong>：抽象工厂模式隐藏了产品的创建细节，客户端只需要调用工厂方法就可以得到所需的产品，从而实现了更加简洁的代码。 </li><li><strong>提供多态性</strong>：抽象工厂模式提供了多态性，可以根据需要选择不同的具体工厂来创建不同的产品，从而实现了更加灵活的代码。 </li><li><strong>支持扩展性</strong>：抽象工厂模式支持扩展性，可以通过添加新的具体工厂和具体产品来扩展系统，而不需要修改现有的代码。 </li><li><strong>符合开闭原则</strong>：抽象工厂模式符合开闭原则，可以在不修改现有代码的情况下扩展系统功能，从而提高系统的可维护性、可扩展性和可重用性。 </li><li><strong>保证产品族内的一致性</strong>：抽象工厂模式可以保证产品族内的一致性，即同一个工厂生产的产品之间具有相关性，从而保证了系统的稳定性和可靠性。</li></ol><h2 id="抽象工厂模式的缺点"><a href="#抽象工厂模式的缺点" class="headerlink" title="抽象工厂模式的缺点"></a>抽象工厂模式的缺点</h2><p>抽象工厂模式（Abstract Factory Pattern）也存在一些缺点：</p><ol><li><strong>不易扩展产品等级结构</strong>：由于抽象工厂模式中每个具体工厂只能生产一族产品，且每个具体产品只能属于一个产品族，因此如果需要扩展产品等级结构，就需要修改抽象工厂接口和所有具体工厂的实现，从而影响系统的稳定性和维护性。 </li><li><strong>增加系统的复杂度</strong>：由于抽象工厂模式需要定义多个抽象类或接口，以及多个具体类或接口，因此会增加系统的复杂度和理解难度。 </li><li><strong>不够灵活</strong>：由于抽象工厂模式只能生产固定的产品族，因此不够灵活，无法在运行时动态切换产品族。 </li><li><strong>不适合单个产品的创建</strong>：由于抽象工厂模式主要用于生产产品族，因此不适合单个产品的创建，如果需要生产单个产品，可以使用工厂模式或创建者模式。</li></ol><h1 id="抽象工厂模式的实现方式"><a href="#抽象工厂模式的实现方式" class="headerlink" title="抽象工厂模式的实现方式"></a>抽象工厂模式的实现方式</h1><h2 id="抽象工厂模式的角色"><a href="#抽象工厂模式的角色" class="headerlink" title="抽象工厂模式的角色"></a>抽象工厂模式的角色</h2><p>抽象工厂模式（Abstract Factory Pattern）中包含以下角色：</p><ol><li>抽象工厂（Abstract Factory）：定义了创建一族产品的接口，包含多个创建产品的抽象方法。 </li><li>具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建一族具体产品。 </li><li>抽象产品（Abstract Product）：定义了产品的接口，包含多个抽象方法，不同的具体产品实现不同的抽象方法。 </li><li>具体产品（Concrete Product）：实现了抽象产品接口，由具体工厂负责创建。</li></ol><p>在抽象工厂模式中，抽象工厂定义了创建一族产品的接口，每个具体工厂实现了该接口，以创建不同的产品族；抽象产品定义了产品的接口，每个具体产品实现了该接口，以提供不同的产品种类。</p><h2 id="抽象工厂模式的实现"><a href="#抽象工厂模式的实现" class="headerlink" title="抽象工厂模式的实现"></a>抽象工厂模式的实现</h2><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂（Abstract Factory）是抽象工厂模式（Abstract Factory Pattern）中的一个关键角色，它定义了一个创建一族产品对象的接口，具体工厂类通过实现抽象工厂接口来创建不同的产品族。</p><p>抽象工厂中包含多个创建产品的抽象方法，每个抽象方法对应一种产品，具体工厂类通过实现这些抽象方法来创建不同的产品。抽象工厂类通常使用接口或抽象类来定义，具体工厂类则实现这些接口或抽象类。</p><p>抽象工厂模式中，每个具体工厂只能创建一族产品，但是可以创建多个不同的产品种类。抽象工厂模式适用于需要创建一系列相关或相互依赖的对象，且这些对象的种类是固定的，但是需要根据不同的产品族进行选择的场景。</p><p>总之，抽象工厂是抽象工厂模式中的一个重要角色，它定义了一个创建一族产品对象的接口，具体工厂类通过实现该接口来创建不同的产品族，从而实现了产品族的灵活选择。抽象工厂模式的优点在于提供了一种简单的方式来创建一系列相关或相互依赖的对象，同时也符合开闭原则，可以方便地添加新的产品族。</p><h3 id="具体工厂"><a href="#具体工厂" class="headerlink" title="具体工厂"></a>具体工厂</h3><p>具体工厂（Concrete Factory）是抽象工厂模式（Abstract Factory Pattern）中的一个角色，它实现了抽象工厂接口，负责创建一族具体产品。</p><p>具体工厂类通常使用工厂方法来创建具体产品对象，每个具体工厂只能创建一族产品，但是可以创建多个不同的产品种类。具体工厂类负责实现抽象工厂接口中定义的所有抽象方法，每个抽象方法对应一种产品，具体工厂类通过实现这些抽象方法来创建不同的产品。</p><p>具体工厂是抽象工厂的具体实现，它与具体产品紧密关联，每个具体工厂只能生产一族产品，但是可以在同一族产品中创建多个不同的产品种类。具体工厂类可以通过配置文件、反射等方式来实现动态创建，从而提高系统的灵活性和扩展性。</p><p>总之，具体工厂是抽象工厂模式中的一个重要角色，它实现了抽象工厂接口，负责创建一族具体产品。具体工厂类通过实现抽象工厂接口中定义的所有抽象方法来创建不同的产品，从而实现了产品族的灵活选择。具体工厂模式的优点在于提供了一种简单的方式来创建一系列相关或相互依赖的对象，同时也符合开闭原则，可以方便地添加新的产品族。</p><h3 id="抽象产品"><a href="#抽象产品" class="headerlink" title="抽象产品"></a>抽象产品</h3><p>抽象产品（Abstract Product）是抽象工厂模式（Abstract Factory Pattern）中的一个角色，它定义了产品的接口，包含多个抽象方法，不同的具体产品实现不同的抽象方法。</p><p>抽象产品是具体产品的基类，通过定义产品的公共接口，实现了产品的抽象化和标准化，使得客户端可以通过抽象接口来访问具体产品。抽象产品通常使用接口或抽象类来定义，具体产品则实现这些接口或抽象类。</p><p>抽象产品是抽象工厂模式中的一个重要角色，它定义了产品的接口和行为，具体工厂类通过实现抽象产品接口来创建不同的产品。抽象产品使得客户端可以使用抽象接口来访问具体产品，从而实现了产品的解耦和灵活性。</p><p>总之，抽象产品是抽象工厂模式中的一个重要角色，它定义了产品的接口和行为，具体产品则实现了该接口和行为，从而实现了产品的抽象化和标准化。抽象产品的优点在于提供了一种简单的方式来定义产品的接口和行为，使得客户端可以通过抽象接口来访问具体产品，从而实现了产品的解耦和灵活性。</p><h3 id="具体产品"><a href="#具体产品" class="headerlink" title="具体产品"></a>具体产品</h3><p>具体产品（Concrete Product）是抽象工厂模式（Abstract Factory Pattern）中的一个角色，它实现了抽象产品接口，并由具体工厂负责创建。</p><p>具体产品是具体工厂所创建的对象，它与具体工厂紧密关联，每个具体工厂只能生产一族产品，但是可以在同一族产品中创建多个不同的产品种类。具体产品通常包含产品的具体实现，实现产品的具体行为和功能。</p><p>具体产品是抽象产品的具体实现，通过实现抽象产品接口中定义的抽象方法来实现产品的具体行为和功能。具体产品的种类和实现方式可以根据具体业务需求来确定，在具体工厂中进行创建和初始化。</p><p>总之，具体产品是抽象工厂模式中的一个重要角色，它实现了抽象产品接口，并由具体工厂负责创建。具体产品的优点在于可以根据具体业务需求来确定产品的种类和实现方式，实现了产品的具体化和个性化。同时，具体产品也具有可扩展性，可以通过继承或实现抽象产品接口来添加新的产品种类和实现方式。</p><h1 id="抽象工厂模式的应用场景"><a href="#抽象工厂模式的应用场景" class="headerlink" title="抽象工厂模式的应用场景"></a>抽象工厂模式的应用场景</h1><h2 id="GUI工具包"><a href="#GUI工具包" class="headerlink" title="GUI工具包"></a>GUI工具包</h2><p>在GUI应用程序中，需要创建一系列相关的控件，例如文本框、按钮、标签等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些控件的抽象方法，具体工厂类实现这些抽象方法来创建不同的控件。这样可以在运行时选择不同的具体工厂来创建不同的GUI工具包，从而实现了GUI工具包的灵活选择。</p><h2 id="数据库访问层"><a href="#数据库访问层" class="headerlink" title="数据库访问层"></a>数据库访问层</h2><p>在数据库访问层中，需要创建一系列相关的对象，例如数据库连接、命令对象、数据适配器等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的数据库访问对象。这样可以在运行时选择不同的具体工厂来创建不同的数据库访问对象，从而实现了数据库访问层的灵活选择。</p><h2 id="加密算法库"><a href="#加密算法库" class="headerlink" title="加密算法库"></a>加密算法库</h2><p>在数据库访问层中，需要创建一系列相关的对象，例如数据库连接、命令对象、数据适配器等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的数据库访问对象。这样可以在运行时选择不同的具体工厂来创建不同的数据库访问对象，从而实现了数据库访问层的灵活选择。</p><h2 id="日志记录器"><a href="#日志记录器" class="headerlink" title="日志记录器"></a>日志记录器</h2><p>在数据库访问层中，需要创建一系列相关的对象，例如数据库连接、命令对象、数据适配器等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的数据库访问对象。这样可以在运行时选择不同的具体工厂来创建不同的数据库访问对象，从而实现了数据库访问层的灵活选择。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在缓存中，需要创建一系列相关的缓存对象，例如内存缓存、磁盘缓存、分布式缓存等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些缓存对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的缓存对象。这样可以在运行时选择不同的具体工厂来创建不同的缓存对象，从而实现了缓存的灵活选择。</p><h1 id="抽象工厂模式的实际应用举例"><a href="#抽象工厂模式的实际应用举例" class="headerlink" title="抽象工厂模式的实际应用举例"></a>抽象工厂模式的实际应用举例</h1><h2 id="Java中的抽象工厂模式实现"><a href="#Java中的抽象工厂模式实现" class="headerlink" title="Java中的抽象工厂模式实现"></a>Java中的抽象工厂模式实现</h2><p>在Java中，抽象工厂模式可以通过定义抽象工厂接口和具体工厂类来实现。同时，每个具体工厂类负责创建一组相关的产品对象，这些产品对象通常也会定义为抽象类或接口，并由具体产品类实现。</p><p>下面是一个简单的Java代码示例，用于演示如何使用抽象工厂模式：</p><p>首先，定义一个抽象工厂接口，用于声明创建产品对象的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，定义具体工厂类，实现抽象工厂接口，并负责创建一组相关的产品对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ConcreteFactory1和ConcreteFactory2分别实现了AbstractFactory接口，并分别负责创建一组相关的产品对象，即ConcreteProductA1和ConcreteProductB1，以及ConcreteProductA2和ConcreteProductB2。</p><p>接下来，定义抽象产品类或接口，用于声明具体产品对象的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，定义具体产品类，实现抽象产品类或接口，以提供具体的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductA1.operationA()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductB1.operationB()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductA2.operationA()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductB2.operationB()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，可以创建一个客户端代码，用于使用抽象工厂模式创建产品对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> staticvoid <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA1</span> <span class="operator">=</span> factory1.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB1</span> <span class="operator">=</span> factory1.createProductB();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA2</span> <span class="operator">=</span> factory2.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB2</span> <span class="operator">=</span> factory2.createProductB();</span><br><span class="line"></span><br><span class="line">        productA1.operationA();</span><br><span class="line">        productB1.operationB();</span><br><span class="line">        productA2.operationA();</span><br><span class="line">        productB2.operationB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，首先创建了两个具体工厂对象，分别是ConcreteFactory1和ConcreteFactory2。然后，使用这些工厂对象创建一组相关的产品对象，即ProductA和ProductB。最后，调用每个产品对象的操作方法，以演示它们的具体实现。</p><p>总的来说，通过定义抽象工厂接口和具体工厂类，以及抽象产品类或接口和具体产品类，Java程序可以使用抽象工厂模式轻松创建一组相关的产品对象，并在需要时轻松替换具体工厂和产品对象的实现。</p><h2 id="Spring框架中的抽象工厂模式应用"><a href="#Spring框架中的抽象工厂模式应用" class="headerlink" title="Spring框架中的抽象工厂模式应用"></a>Spring框架中的抽象工厂模式应用</h2><p>在Spring框架中，抽象工厂模式被广泛地应用于创建和管理对象。具体来说，Spring框架中的BeanFactory就是一个抽象工厂接口，它声明了一组用于创建和管理对象的方法。而XmlBeanFactory、DefaultListableBeanFactory和ApplicationContext等具体工厂类则实现了BeanFactory接口，并负责创建和管理一组相关的对象。</p><p>在Spring框架中，BeanFactory接口定义了一组用于获取和管理对象的方法，包括：</p><ul><li>getBean(String name): 根据给定的Bean名称获取一个对象实例。</li><li>getBean(Class requiredType): 根据指定的对象类型获取一个对象实例。</li><li>containsBean(String name): 判断指定名称的Bean是否存在。</li><li>isSingleton(String name): 判断指定名称的Bean是否为单例。</li><li>isPrototype(String name): 判断指定名称的Bean是否为原型。</li><li>getAliases(String name): 获取指定名称的Bean的所有别名。</li></ul><p>其中，getBean()方法是最常用的方法，它根据给定的Bean名称或对象类型获取一个对象实例。具体工厂类则实现了BeanFactory接口，并负责创建和管理一组相关的对象。</p><p>例如，XmlBeanFactory是一个具体工厂类，它实现了BeanFactory接口，并使用XML配置文件来创建和管理对象。XmlBeanFactory可以读取XML配置文件，并根据文件中定义的Bean定义来创建和管理对象。它还可以自动解析Bean之间的依赖关系，以确保正确地创建和管理对象。</p><p>类似地，DefaultListableBeanFactory也是一个具体工厂类，它实现了BeanFactory接口，并使用Java代码来创建和管理对象。DefaultListableBeanFactory可以通过Java代码定义Bean定义，并使用依赖注入来管理Bean之间的依赖关系。</p><p>另外，ApplicationContext也是一个具体工厂类，它是Spring框架中最常用的工厂类之一。与XmlBeanFactory和DefaultListableBeanFactory不同，ApplicationContext不仅可以读取XML配置文件或Java代码，还可以读取其他类型的配置文件，如注解等。此外，ApplicationContext还提供了其他功能，如Bean生命周期管理、事件处理、AOP、事务管理等。</p><p>总之，在Spring框架中，抽象工厂模式被广泛地应用于创建和管理对象。BeanFactory接口作为抽象工厂接口，定义了一组用于获取和管理对象的方法，具体工厂类则实现了BeanFactory接口，并负责创建和管理一组相关的对象。XmlBeanFactory、DefaultListableBeanFactory和ApplicationContext等具体工厂类则是Spring框架中最常用的工厂类之一，它们使用不同的方式来创建和管理对象，如XML配置文件、Java代码、注解等，并提供了其他功能，如Bean生命周期管理、事件处理、AOP、事务管理等。</p><h1 id="抽象工厂模式与其他设计模式的关系"><a href="#抽象工厂模式与其他设计模式的关系" class="headerlink" title="抽象工厂模式与其他设计模式的关系"></a>抽象工厂模式与其他设计模式的关系</h1><h2 id="抽象工厂模式与工厂模式的区别"><a href="#抽象工厂模式与工厂模式的区别" class="headerlink" title="抽象工厂模式与工厂模式的区别"></a>抽象工厂模式与工厂模式的区别</h2><p>抽象工厂模式和工厂模式都是常见的对象创建型模式，它们都通过一个工厂来创建对象，但是它们之间还是存在一定的区别。</p><p>工厂模式是一种简单工厂模式，它定义了一个工厂接口或类，用于创建一个具体的产品对象。工厂模式只关心如何创建对象，而不关心对象所属的具体类别。具体的产品对象通常都实现了共同的接口或基类，以便于在客户端代码中使用。工厂模式最大的优点是可以将客户端代码与具体产品类的实现分离开来，从而实现了更好的解耦。</p><p>抽象工厂模式是一种更加高级的工厂模式，它定义了一个工厂接口或类，用于创建一组相关或者相互依赖的产品对象。抽象工厂模式与工厂模式的最大区别在于，抽象工厂模式可以创建多个不同类型的产品对象，而工厂模式只能创建一种类型的产品对象。在抽象工厂模式中，每个具体工厂类负责创建一整个产品族的产品对象，而不是单个产品对象。因此，抽象工厂模式通常用于创建一组相关的产品对象，例如UI控件的颜色和样式等。</p><p>总的来说，工厂模式和抽象工厂模式都是用于创建对象的模式，二者的区别在于工厂模式只能创建单个类型的产品对象，而抽象工厂模式可以创建多个不同类型的产品对象，且每个具体工厂类负责创建一整个产品族的产品对象。因此，在使用这两种模式时，需要根据具体的需求来选择适合的模式。</p><h2 id="抽象工厂模式与建造者模式的关系"><a href="#抽象工厂模式与建造者模式的关系" class="headerlink" title="抽象工厂模式与建造者模式的关系"></a>抽象工厂模式与建造者模式的关系</h2><p>抽象工厂模式和建造者模式都是对象创建型模式，它们都关注如何创建复杂的对象。虽然它们的目的相同，但是它们的实现方式和应用场景有所不同。</p><p>抽象工厂模式是一种创建型模式，它提供了一个接口来创建一系列相关的产品对象，而无需指定它们的具体类。抽象工厂模式通常用于创建一组相关或相互依赖的对象，例如UI控件的颜色和样式等。</p><p>建造者模式是一种创建型模式，它将一个复杂对象的构建过程分解成多个简单的步骤，并将这些步骤封装到一个Builder接口中。建造者模式可以按照不同的顺序创建不同的对象，以满足不同的需求。建造者模式通常用于创建复杂的对象，例如汽车、电脑等。</p><p>虽然抽象工厂模式和建造者模式都是用于创建对象的模式，但是它们之间还是存在一定的区别。主要区别如下：</p><ol><li>目的不同：抽象工厂模式的目的是创建一系列相关的产品对象，而建造者模式的目的是创建一个复杂对象。 </li><li>实现方式不同：抽象工厂模式通过定义一个工厂接口来创建产品对象，而建造者模式通过将构建过程分解成多个简单的步骤，并将这些步骤封装到一个Builder接口中来创建复杂对象。 </li><li>应用场景不同：抽象工厂模式通常用于创建一组相关或相互依赖的对象，例如UI控件的颜色和样式等。而建造者模式通常用于创建复杂的对象，例如汽车、电脑等。</li></ol><p>总的来说，抽象工厂模式和建造者模式都是用于创建对象的模式，它们的实现方式和应用场景有所不同。在选择使用哪种模式时，需要根据具体的需求来选择适合的模式。如果需要创建一组相关或相互依赖的对象，可以考虑使用抽象工厂模式；如果需要创建复杂的对象，并且需要按照不同的顺序创建不同的对象，可以考虑使用建造者模式。</p><h2 id="抽象工厂模式与单例模式的关系"><a href="#抽象工厂模式与单例模式的关系" class="headerlink" title="抽象工厂模式与单例模式的关系"></a>抽象工厂模式与单例模式的关系</h2><p>抽象工厂模式和单例模式都是常见的设计模式，它们都可以用于创建对象，但是它们的主要目的和应用场景有所不同。</p><p>抽象工厂模式是一种对象创建型模式，它提供了一个接口用于创建一组相关的产品对象，而无需指定它们的具体类。抽象工厂模式通常用于创建一组相关或相互依赖的对象，例如UI控件的颜色和样式等。抽象工厂模式的主要目的是将对象的创建与使用分离，从而实现了更好的解耦。</p><p>单例模式是一种对象创建型模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。单例模式通常用于需要共享资源或状态的对象，例如数据库连接池、线程池等。单例模式的主要目的是确保一个类只有一个实例，以避免资源浪费和状态不一致的问题。</p><p>虽然抽象工厂模式和单例模式都是用于创建对象的模式，但是它们的主要目的和应用场景有所不同，因此它们之间并没有直接的关系。抽象工厂模式主要用于创建一组相关的产品对象，而单例模式主要用于确保一个类只有一个实例。在实际应用中，抽象工厂模式和单例模式可以同时使用，例如在一个应用程序中，可以使用抽象工厂模式来创建一组相关的对象，并使用单例模式确保每个对象只有一个实例。这样可以充分利用抽象工厂模式和单例模式的优点，提高应用程序的性能和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/posts/bb83.html"/>
      <url>/posts/bb83.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p><a href="https://juejin.cn/post/6844904098580398088">https://juejin.cn/post/6844904098580398088</a><br><a href="https://juejin.cn/post/6844903517648322574">https://juejin.cn/post/6844903517648322574</a><br><a href="https://juejin.cn/post/6844903978342301709">https://juejin.cn/post/6844903978342301709</a><br><a href="https://juejin.cn/post/7066031623296253966">https://juejin.cn/post/7066031623296253966</a><br><a href="https://juejin.cn/post/6865807207229816845">https://juejin.cn/post/6865807207229816845</a></p></blockquote><p>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。<br><strong>代理模式</strong> （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。<br>通过代理模式，我们可以做到两点：</p><ol><li>隐藏委托类的具体实现</li><li>实现客户与委托类的解耦，在不改变类代码的情况下添加一些额外的功能（日志、权限等）</li></ol><h1 id="代理模式角色定义"><a href="#代理模式角色定义" class="headerlink" title="代理模式角色定义"></a>代理模式角色定义</h1><p>在编程的过程中我们可以定义为三类对象：</p><ul><li>Subject（抽象主题角色）：一般为接口（也可以是抽象类），定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法。比如：出售商品等。</li><li>RealSubject（真实主题角色）：真正实现业务逻辑的类。该类可以被称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了Subject接口，而Client端通过代理类间接的调用的真实主题类中的方法，由其执行真正的业务逻辑。。比如实现了广告、出售等方法的厂家（Factoryer）。</li><li>ProxySubject（代理主题角色）：该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了Subject接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。用来代理和封装真实主题。比如，同样实现了广告、出售等方法的超时（Shop）。 </li><li>Client 客户端的，使用代理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32620241/1667383829047-83b898fc-be35-493c-916d-d2ee2264b131.png#averageHue=%23f5f5f5&clientId=uc3d53cf3-3fab-4&from=paste&height=321&id=u4ac9b2c7&originHeight=482&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65035&status=done&style=none&taskId=u5603d1cc-5e19-4a14-90f1-443faad46ed&title=&width=518.6666666666666" alt="image.png"><br>Subject &#x3D; 公共接口；<br>ProxySubject &#x3D; 代理对象 &#x3D; 代理类 &#x3D; 委托类 &#x3D; 代理人；<br>RealSubject &#x3D; 真实对象 &#x3D; 被代理类 &#x3D; 被委托类 &#x3D; 被代理人；</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1、定义代理对象和真实对象的公共接口；<br>2、真实对象实现公共接口中的方法；<br>3、代理对象实现公共接口中的方法，并把方法的逻辑转发给真实对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123; <span class="comment">// 代理对象和目标对象的公共接口。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改订单信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看订单详情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123; <span class="comment">// 目标对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123; <span class="comment">// 目标方法</span></span><br><span class="line">        <span class="comment">// 模拟生成订单的耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1234</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已生成.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123; <span class="comment">// 目标方法</span></span><br><span class="line">        <span class="comment">// 模拟修改订单的耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">456</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已修改.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span> &#123; <span class="comment">// 目标方法</span></span><br><span class="line">        <span class="comment">// 模拟查询订单的耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">111</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请看订单详情.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理对象（代理对象和目标对象要具有相同的行为，就要实现同一个或同一些接口。）</span></span><br><span class="line"><span class="comment">// 客户端在使用代理对象的时候就像在使用目标对象一样。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将目标对象作为代理对象的一个属性。这种关系叫做关联关系。比继承关系的耦合度低。</span></span><br><span class="line">    <span class="comment">// 代理对象中含有目标对象的引用。关联关系。has a</span></span><br><span class="line">    <span class="comment">// 注意：这里要写一个公共接口类型。因为公共接口耦合度低。</span></span><br><span class="line">    <span class="keyword">private</span> OrderService target; <span class="comment">// 这就是目标对象。目标对象一定是实现了OrderService接口的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象的时候，传一个目标对象给代理对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderServiceProxy</span><span class="params">(OrderService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123; <span class="comment">// 代理方法</span></span><br><span class="line">        <span class="comment">// 增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        target.generate();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123; <span class="comment">// 代理方法</span></span><br><span class="line">        <span class="comment">// 增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        target.modify();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span> &#123; <span class="comment">// 代理方法</span></span><br><span class="line">        <span class="comment">// 增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        target.detail();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建目标对象</span></span><br><span class="line"><span class="type">OrderService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceImpl</span>();</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="type">OrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceProxy</span>(target);</span><br><span class="line"><span class="comment">// 调用代理对象的代理方法</span></span><br><span class="line">proxy.generate();</span><br><span class="line">proxy.modify();</span><br><span class="line">proxy.detail();</span><br></pre></td></tr></table></figure><h1 id="动态代理📌"><a href="#动态代理📌" class="headerlink" title="动态代理📌"></a>动态代理📌</h1><p>在程序运行阶段，在内存中动态生成代理类，被称为动态代理，目的是为了减少代理类的数量。解决代码复用的问题。<br>在内存当中动态生成类的技术常见的包括：</p><ul><li>JDK动态代理技术：只能代理接口。</li><li>CGLIB动态代理技术：CGLIB(Code Generation Library)是一个开源项目。是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它既可以代理接口，又可以代理类，<strong>底层是通过继承的方式实现的</strong>。性能比JDK动态代理要好。<strong>（底层有一个小而快的字节码处理框架ASM。）</strong></li><li>Javassist动态代理技术：Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态”AOP”框架。</li></ul><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看订单详情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1234</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已生成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2541</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单信息如下：******&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1010</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">orderServiceProxy</span> <span class="operator">=</span> (OrderService) Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                                                                                target.getClass().getInterfaces(),</span><br><span class="line">                                                                                <span class="keyword">new</span> <span class="title class_">TimerInvocationHandler</span>(target));</span><br><span class="line">        <span class="comment">// 调用代理对象的代理方法</span></span><br><span class="line">        orderServiceProxy.detail();</span><br><span class="line">        orderServiceProxy.modify();</span><br><span class="line">        orderServiceProxy.generate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上第二步创建代理对象是需要大家理解的：</p><p>OrderService orderServiceProxy &#x3D; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), 调用处理器对象);<br>这行代码做了两件事：</p><ul><li>第一件事：在内存中生成了代理类的字节码</li><li>第二件事：创建代理对象</li></ul><p>Proxy类全名：java.lang.reflect.Proxy。这是JDK提供的一个类（所以称为JDK动态代理）。主要是通过这个类在内存中生成代理类的字节码。<br>其中newProxyInstance()方法有三个参数：</p><ul><li>第一个参数：类加载器。在内存中生成了字节码，要想执行这个字节码，也是需要先把这个字节码加载到内存当中的。所以要指定使用哪个类加载器加载。</li><li>第二个参数：接口类型。代理类和目标类实现相同的接口，所以要通过这个参数告诉JDK动态代理生成的类要实现哪些接口。</li><li>第三个参数：调用处理器。这是一个JDK动态代理规定的接口，接口全名：java.lang.reflect.InvocationHandler。显然这是一个回调接口，也就是说调用这个接口中方法的程序已经写好了，就差这个接口的实现类了。</li></ul><p>所以接下来我们要写一下java.lang.reflect.InvocationHandler接口的实现类，并且实现接口中的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InvocationHandler接口中有一个方法invoke，这个invoke方法上有三个参数：</p><ul><li>第一个参数：Object proxy。代理对象。设计这个参数只是为了后期的方便，如果想在invoke方法中使用代理对象的话，尽管通过这个参数来使用。</li><li>第二个参数：Method method。目标方法。</li><li>第三个参数：Object[] args。目标方法调用时要传的参数。</li></ul><p>我们将来肯定是要调用“目标方法”的，但要调用目标方法的话，需要“目标对象”的存在，“目标对象”从哪儿来呢？我们可以给TimerInvocationHandler提供一个构造方法，可以通过这个构造方法传过来“目标对象”，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造方法来传目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了目标对象我们就可以在invoke()方法中调用目标方法了。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造方法来传目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 目标执行之前增强。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">retValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 目标执行之后增强。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 一定要记得返回哦。</span></span><br><span class="line">        <span class="keyword">return</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                target.getClass().getInterfaces(), </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TimerInvocationHandler</span>(target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">orderServiceProxy</span> <span class="operator">=</span> (OrderService) ProxyUtil.newProxyInstance(target);</span><br><span class="line">        <span class="comment">// 调用代理对象的代理方法</span></span><br><span class="line">        orderServiceProxy.detail();</span><br><span class="line">        orderServiceProxy.modify();</span><br><span class="line">        orderServiceProxy.generate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>CGLIB既可以代理接口，又可以代理类。底层采用继承的方式实现。所以被代理的目标类不能使用final修饰。<br>使用CGLIB，需要引入它的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户正在登录系统....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户正在退出系统....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CGLIB在内存中为UserService类生成代理类，并创建对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字节码增强器</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 告诉cglib要继承哪个类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">// 设置回调接口</span></span><br><span class="line">        enhancer.setCallback(方法拦截器对象);</span><br><span class="line">        <span class="comment">// 生成源码，编译class，加载到JVM，并创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line"></span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">        userServiceProxy.logout();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和JDK动态代理原理差不多，在CGLIB中需要提供的不是InvocationHandler，而是：net.sf.cglib.proxy.MethodInterceptor<br>编写MethodInterceptor接口实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object target, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodInterceptor接口中有一个方法intercept()，该方法有4个参数：<br>第一个参数：目标对象<br>第二个参数：目标方法<br>第三个参数：目标方法调用时的实参<br>第四个参数：代理方法<br>在MethodInterceptor的intercept()方法中调用目标以及添加增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object target, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 前增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">retValue</span> <span class="operator">=</span> methodProxy.invokeSuper(target, objects);</span><br><span class="line">        <span class="comment">// 后增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span> + (end - begin) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 一定要返回</span></span><br><span class="line">        <span class="keyword">return</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调已经写完了，可以修改客户端程序了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字节码增强器</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 告诉cglib要继承哪个类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">// 设置回调接口</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">TimerMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 生成源码，编译class，加载到JVM，并创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line"></span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">        userServiceProxy.logout();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于高版本的JDK，如果使用CGLIB，需要在启动项中添加两个启动参数：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32620241/1667388850691-93ef6826-514d-4de1-aa43-3581987a5191.png#averageHue=%23f3efef&clientId=uc3d53cf3-3fab-4&from=paste&height=435&id=uc7a2865a&originHeight=652&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137241&status=done&style=none&taskId=u4fa667b0-cad0-4bb6-821a-6e1b6155557&title=&width=639.3333333333334" alt="image.png"></p><ul><li>–add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li><li>–add-opens java.base&#x2F;sun.net.util&#x3D;ALL-UNNAMED</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/b434.html"/>
      <url>/posts/b434.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>单例模式（Singleton Pattern）是一种常见的创建型设计模式，用于确保一个类只有一个实例，并提供全局访问点。在实际应用中，单例模式经常被用来管理全局变量、配置信息等。</p><p>单例模式的核心思想是通过限制类的实例化次数来确保一个类只有一个实例。具体来说，单例模式通常通过以下方式来实现：</p><ol><li>私有化构造函数：将类的构造函数私有化，防止外部代码通过构造函数来创建类的实例。 </li><li>提供静态方法获取单例实例：提供一个静态方法来获取类的实例。该方法会判断类的实例是否已经存在，如果存在则直接返回该实例，否则创建一个新的实例并返回。 </li><li>保证线程安全性：在多线程环境下，需要保证单例实例的线程安全性。可以通过加锁、双重检查锁等方式来实现。</li></ol><p>单例模式的优点包括：</p><ol><li>确保一个类只有一个实例，避免了多次创建相同对象的开销，节省了系统资源。 </li><li>提供全局访问点，方便代码中的其他对象访问该实例，降低了代码的耦合性。 </li><li>可以控制实例化的过程，保证实例的唯一性和一致性。</li></ol><p>但是，单例模式也有一些缺点，包括：</p><ol><li>单例模式可能会导致代码的可测试性降低，因为它们创建了一个全局状态，可能会影响测试用例的正确性。 </li><li>单例模式可能会使代码的可维护性降低，因为它们隐藏了依赖关系，使得代码更难以理解和修改。 </li><li>单例模式可能会使代码的扩展性降低，因为它们往往是硬编码的，并且难以在运行时动态地添加或删除实例。</li></ol><p>总之，单例模式是一种常见的创建型设计模式，用于确保一个类只有一个实例，并提供全局访问点。它可以提高代码的性能和可维护性，但同时也需要注意其缺点，如可能降低代码的可测试性、可维护性和扩展性等问题。在实际应用中，需要根据具体场景来判断是否使用单例模式，并在实现时注意线程安全性、防止反射、序列化等问题。</p><h2 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h2><p>单例模式（Singleton Pattern）的结构包括以下几个元素：</p><ol><li>Singleton类：这是一个单例类，负责管理唯一的实例，并提供全局访问点。通常，该类会将其构造函数私有化，以防止外部代码直接创建实例，同时提供一个静态方法来获取单例实例。 </li><li>Instance变量：这是Singleton类中的一个静态变量，用于存储唯一的实例对象。在第一次调用静态方法获取单例实例时，该变量会被初始化。 </li><li>getInstance()方法：这是Singleton类中的一个静态方法，用于获取单例实例。在该方法中，会先判断Instance变量是否已经被初始化，如果已经被初始化，则直接返回实例对象。否则，会创建一个新的实例对象，并将其赋给Instance变量。 </li><li>Private Constructor：Singleton类的构造函数是私有化的，防止外部代码直接创建实例。通常，构造函数是空的或者仅用于完成一些初始化工作。</li></ol><p>下面是一个简单的单例模式的结构示意图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------------+</span><br><span class="line">|        Singleton Class          |</span><br><span class="line">+---------------------------------+</span><br><span class="line">| - instance: Singleton           |</span><br><span class="line">|---------------------------------|</span><br><span class="line">| + getInstance(): Singleton      |</span><br><span class="line">| - Singleton()                   |</span><br><span class="line">+---------------------------------+</span><br></pre></td></tr></table></figure><p>在上面的示意图中，Singleton类表示单例类，它包含一个私有的instance变量和一个公共的getInstance()方法。在getInstance()方法中，会先判断instance变量是否已经被初始化，如果已经被初始化，则直接返回instance变量；否则，会创建一个新的Singleton实例，并将其赋给instance变量。注意，Singleton类的构造函数是私有的，以防止外部代码直接创建实例。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式（Eager Initialization）是一种常见的单例模式实现方式，它在<strong>类加载时就创建单例对象</strong>，保证了<strong>线程安全性</strong>。在实际应用中，饿汉式适用于单例对象的创建和<strong>初始化时间较短的场景</strong>。<br>饿汉式的核心思想是在类加载时就创建单例对象，具体实现方式是在类的定义中直接创建单例对象，并将其声明为静态变量。在使用单例对象时，直接通过类名来访问静态变量即可。<br>以下是一个简单的饿汉式单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的instance静态变量和一个公共的getInstance()方法。在Singleton类被加载时，instance静态变量就会被初始化为Singleton的唯一实例。在getInstance()方法中，直接返回instance变量即可。<br>饿汉式的优点是<strong>线程安全性高</strong>，因为单例对象在类加载时就被创建，避免了多线程环境下的实例化多次的问题。同时，饿汉式<strong>实现简单，使用方便</strong>，可以直接通过类名来访问单例对象。<br>饿汉式的缺点是<strong>可能会浪费系统资源</strong>，因为即使不需要使用单例对象也会被创建。此外，饿汉式也不支持延迟加载，因为单例对象在类加载时就被创建，无法根据需要动态地创建单例对象。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式（Lazy Initialization）是一种常见的单例模式实现方式，它在<strong>第一次使用时才创建单例对象</strong>，避免了不必要的资源浪费。在实际应用中，懒汉式适用于单例对象的创建和<strong>初始化时间较长的场景</strong>。<br>懒汉式的核心思想是在第一次使用时才创建单例对象，具体实现方式是在getInstance()方法中判断单例对象是否已经被创建，如果已经被创建则直接返回单例对象，否则创建一个新的单例对象并返回。由于懒汉式可能会出现多线程竞争导致的线程安全问题，因此需要考虑线程安全性。<br>以下是一个简单的线程不安全的懒汉式单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的instance变量和一个公共的getInstance()方法。在getInstance()方法中，如果instance变量为null，则创建一个新的Singleton实例并赋值给instance变量，否则直接返回instance变量。由于这种实现方式没有考虑线程安全性，可能会出现多线程环境下的实例化多次的问题。<br>为了避免多线程环境下的线程安全问题，可以使用<strong>synchronized</strong>关键字来加锁，保证getInstance()方法的同步性。以下是一个简单的线程安全的懒汉式单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，getInstance()方法被加上了synchronized关键字，保证了线程安全性。虽然这种实现方式解决了线程安全问题，但是每次调用getInstance()方法都需要获取锁，可能会影响性能。</p><h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><p>双重检查锁（Double-Checked Locking）是一种常见的单例模式实现方式，它<strong>在懒汉式的基础上，使用synchronized关键字来保证线程安全性，同时使用双重检查来避免多线程竞争导致的实例化多次的问题</strong>。在实际应用中，双重检查锁适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性和性能问题。</p><p>双重检查锁的核心思想是在getInstance()方法中，首先检查单例对象是否已经被创建，如果已经被创建，则直接返回单例对象。否则，加锁创建单例对象并赋值给静态变量，然后再次检查静态变量是否为空，如果为空，则创建一个新的单例对象并赋值给静态变量。由于双重检查锁需要考虑线程安全性和可见性，实现比较复杂。</p><p>以下是一个简单的双重检查锁单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicclass Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的instance变量和一个公共的getInstance()方法。在getInstance()方法中，首先检查instance变量是否已经被创建，如果instance变量为null，则加锁并再次检查instance变量是否为null，如果为null，则创建一个新的Singleton实例并赋值给instance变量。在加锁时，可以使用synchronized关键字或者Lock接口等方式来实现锁的同步性。</p><p>需要注意的是，为了避免由于指令重排带来的可见性问题，需要将instance变量声明为volatile类型。volatile关键字可以保证多线程环境下变量的可见性，避免出现线程安全问题。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类（Static Inner Class）是一种常见的单例模式实现方式，它利用Java的类加载机制，当外部类被加载时，静态内部类不会被加载，只有在第一次使用时才会被加载。静态内部类可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。在实际应用中，静态内部类适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性和性能问题。</p><p>静态内部类的核心思想是定义一个静态内部类，该内部类包含一个静态的单例对象，在getInstance()方法中，直接返回静态内部类中的单例对象即可。由于静态内部类只在第一次使用时才被加载，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。</p><p>以下是一个简单的静态内部类单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的构造方法和一个公共的getInstance()方法。在Singleton类中定义了一个静态内部类SingletonHolder，该内部类包含一个静态的Singleton实例。在getInstance()方法中，直接返回SingletonHolder中的INSTANCE变量即可。</p><p>需要注意的是，静态内部类SingletonHolder是一个单例类，它只在第一次使用时才会被加载，且只会被加载一次。由于静态内部类中的INSTANCE变量是静态的，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类（Enum Class）是一种常见的单例模式实现方式，它利用Java中的枚举类型，在定义枚举类型时，可以直接指定枚举值，枚举值本身就是单例对象。枚举类可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。在实际应用中，枚举类适用于单例对象的创建和初始化时间较短的场景，且需要考虑线程安全性和性能问题。</p><p>枚举类的核心思想是定义一个枚举类型，枚举类型中的枚举值就是单例对象。在枚举类型中定义一个公共的访问方法，直接返回枚举值即可。由于枚举类型中的枚举值是静态的，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。</p><p>以下是一个简单的枚举类单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton是一个枚举类型，它只有一个枚举值INSTANCE。在INSTANCE枚举值中定义了一个公共的doSomething()方法，表示单例对象的行为。在使用单例对象时，直接通过Singleton.INSTANCE来访问单例对象即可。</p><p>需要注意的是，枚举类中的枚举值是静态的，因此可以保证线程安全性和实例化的唯一性。同时，枚举类型中的枚举值是在类加载时就被创建的，因此可以避免延迟加载带来的性能问题。此外，枚举类型还提供了序列化和反序列化的支持，可以避免反序列化时创建新的实例。</p><h2 id="如何选择❓"><a href="#如何选择❓" class="headerlink" title="如何选择❓"></a>如何选择❓</h2><p>不同的单例模式实现方式适用于不同的应用场景，下面是每种方式的应用场景：</p><ol><li>饿汉式（Eager Initialization）：适用于单例对象的创建和初始化时间较短的场景。由于在类加载时就创建了单例对象，因此可以避免多线程竞争导致的线程安全问题。 </li><li>懒汉式（Lazy Initialization）：适用于单例对象的创建和初始化时间较长的场景。由于只有在第一次使用时才创建单例对象，因此可以避免不必要的资源浪费。 </li><li>双重检查锁（Double-Checked Locking）：适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性。由于使用了双重检查来避免多线程竞争导致的实例化多次的问题，因此可以提高性能。 </li><li>静态内部类（Static Inner Class）：适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性。由于静态内部类只在第一次使用时才被加载，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。这种方式是比较常用的单例模式实现方式之一。 </li><li>枚举类（Enum）：适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性和防止反射攻击。由于枚举类是单例的，因此可以保证实例化的唯一性和线程安全性，同时避免了序列化和反射攻击。这种方式是比较简单和安全的单例模式实现方式之一。</li></ol><p>在选择实现方式时，需要考虑单例对象的创建和初始化时间、线程安全性、资源浪费等因素，并根据具体情况来选择最合适的实现方式。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>单例模式虽然有很多优点，但是也存在一些问题，主要包括以下几点：</p><ol><li>破坏代码的可测试性：由于单例模式的实例化方式是固定的，因此在单元测试时，很难对单例对象进行模拟和替换，可能会导致测试的不稳定性和可靠性下降。</li></ol><p>解决方法：可以使用依赖注入（Dependency Injection）等技术来解决这个问题，将单例对象作为参数传递给依赖的对象，从而实现单例对象和依赖对象的解耦。另外，也可以使用模拟框架（Mock Framework）来模拟单例对象，从而方便进行单元测试。</p><ol start="2"><li>可能引起内存泄漏：由于单例对象的生命周期与整个应用程序的生命周期相同，在某些情况下，单例对象可能不会被及时回收，从而导致内存泄漏的问题。</li></ol><p>解决方法：可以使用弱引用（Weak Reference）等方式来避免内存泄漏的问题，当单例对象不再被引用时，及时将其回收。另外，也可以使用懒加载（Lazy Loading）等方式来延迟单例对象的实例化，从而减少不必要的内存占用。</p><ol start="3"><li>可能引起多线程竞争：在多线程环境下，单例对象的实例化可能会引起多线程竞争问题，需要考虑线程安全性和可见性的问题。</li></ol><p>解决方法：可以使用同步锁（Synchronized）等技术来保证线程安全性和可见性，从而避免多线程竞争的问题。另外，也可以使用双重检查锁（Double-Checked Locking）等方式来提高单例对象的实例化效率。</p><ol start="4"><li>可能引起单点故障：由于单例对象的唯一性，一旦单例对象出现问题，整个应用程序都会受到影响，可能引起单点故障的问题。</li></ol><p>解决方法：可以使用集群部署等方式来避免单点故障的问题，将单例对象分布在多个节点上，从而提高系统的可用性和稳定性。</p><ol start="5"><li>可能降低代码的可维护性：由于单例模式的实现方式较为复杂，可能会导致代码的可维护性和可读性下降。</li></ol><p>解决方法：可以使用注释、命名规范等方式来提高代码的可读性和可维护性，同时也可以使用设计模式等技术来简化单例模式的实现方式，从而降低代码的复杂度和难度。</p><ol start="6"><li>可能违反单一职责原则：由于单例对象的作用范围比较广泛，可能会违反单一职责原则，使得单例对象承担过多的职责，导致代码的复杂度增加。</li></ol><p>解决方法：可以使用分层架构、模块化设计等方式来分离单例对象的职责，从而避免单例对象承担过多的职责，提高代码的可读性和可维护性。同时也可以使用其他设计模式，如工厂模式、代理模式等来分离职责，避免单例对象承担过多的职责，从而提高代码的可读性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射机制</title>
      <link href="/posts/9dad.html"/>
      <url>/posts/9dad.html</url>
      
        <content type="html"><![CDATA[<h1 id="反射⭐️"><a href="#反射⭐️" class="headerlink" title="反射⭐️"></a>反射⭐️</h1><h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><p><strong>何为反射</strong></p><p>Java的 <strong>反射机制</strong> 是在运行状态中，对于任意一个类，都能够 <strong>知道这个类的所有属性和方法</strong> ；对于任意一个对象，都能够 <strong>调用它的任意一个方法和属性</strong> ；这种 <strong>动态获取的信息以及动态调用对象的方法的功能</strong> 称为 Java 语言的<code>反射机制</code>。</p><p>简而言之，只要你给我一个 <code>.class</code> ——类的名字，我就能通过反射获取到类的属性和方法。<br>反射是很多高级技术的基础，Java 中的注解、动态代理，各种框架注入 Spring 、 MyBatis 等都用到了反射技术。</p><ul><li>Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于 <code>Reflection API</code> 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</li><li>加载完类之后，在堆内存的方法区中就产生了一个 <code>Class</code> 类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li></ul><p>通常的方式：引入需要的“包类”名称—-&gt;通过 <code>new</code> 实例化—-&gt;获得实例化对象</p><p>反射的方式：实例化对象—-&gt; <code>getClass()</code> 方法—-&gt;得到完整的“包类”名称</p><p>框架 &#x3D; 注解 + 反射 + 设计模式</p><h2 id="反射机制⭐️"><a href="#反射机制⭐️" class="headerlink" title="反射机制⭐️"></a>反射机制⭐️</h2><p>Java 的反射机制是指在运行时动态地获取一个类的信息，包括类的方法、属性、构造函数等，并且可以在运行时调用这些方法、访问这些属性。Java 的反射机制提供了一种机制，可以在运行时查看和修改类的属性，调用类的方法，获取类的构造函数等。这种机制使得程序可以实现更高的动态性和灵活性。</p><p>在 Java 中，反射机制的核心类是 <code>Class</code>，它代表了一个类的类型。我们可以通过以下方式获取一个类的 <code>Class</code> 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;  <span class="comment">// 通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 通过对象获取</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>); <span class="comment">// 通过类的全限定名获取</span></span><br></pre></td></tr></table></figure><p>通过 <code>Class</code> 对象，我们可以获取类的各种信息，比如类的方法、属性、构造函数等。以下是一些常用的反射方法：</p><ul><li><code>getMethods()</code>：获取类的所有公共方法。</li><li><code>getDeclaredMethods()</code>：获取类的所有方法，包括私有方法。</li><li><code>getFields()</code>：获取类的所有公共属性。</li><li><code>getDeclaredFields()</code>：获取类的所有属性，包括私有属性。</li><li><code>getConstructors()</code>：获取类的所有公共构造函数。</li><li><code>getDeclaredConstructors()</code>：获取类的所有构造函数，包括私有构造函数。</li><li><code>newInstance()</code>：创建类的一个新实例。</li></ul><p>除了上述方法外，还有许多其他的反射方法可以使用，这些方法提供了对类的各种信息的访问和操作。</p><p>需要注意的是，虽然反射机制可以提供更高的灵活性和动态性，但是在性能方面可能会有些损失。因此，在实际应用中，应该谨慎使用反射机制，避免过度使用导致性能问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366322167-db8450a5-1c34-4063-a983-f6631f60b48d.png#averageHue=%23bbc3b7&clientId=u20550a6b-f5bb-4&from=paste&height=472&id=u954badaf&originHeight=637&originWidth=1412&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=469492&status=done&style=none&taskId=u9b01cd10-e1a8-42b2-b418-88a71dc4f27&title=&width=1045.9259998127973" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366332763-8461ecb9-f2ce-46d8-b750-bd7c30ee73d2.png#averageHue=%238d8f8d&clientId=u20550a6b-f5bb-4&from=paste&height=244&id=u79296ad3&originHeight=330&originWidth=966&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=383622&status=done&style=none&taskId=uf6a7d6d7-9e03-4f76-8b46-eee7daf0581&title=&width=715.5556061042225" alt="image.png"></p><p>Class:代表一个类，Class对象表示某个类加载后在堆中的对象</p><p>Method：代表类的方法</p><p>Field：代表类的成员变量</p><p>Constructor：代表类的构造方法<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366342981-ca08276e-f53a-48bb-85d1-dd5d11083baf.png#averageHue=%23eddfc7&clientId=u20550a6b-f5bb-4&from=paste&height=316&id=u573aa184&originHeight=427&originWidth=801&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=72199&status=done&style=none&taskId=ue18f66ca-269a-4043-b647-21739ef7046&title=&width=593.3333752479111" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//根据配置文件指定信息。创建Cat对象并调用</span></span><br><span class="line">        <span class="comment">// 传统方法</span></span><br><span class="line"><span class="comment">//        Cat cat = new Cat();</span></span><br><span class="line"><span class="comment">//        cat.hi();</span></span><br><span class="line">        <span class="comment">//使用Properties类,</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">proerties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        proerties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> proerties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> proerties.get(<span class="string">&quot;method&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//使用反射类</span></span><br><span class="line">        <span class="comment">//1加载类,返回Class类型的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//通过cls对象得到你加载的类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//通过getMethod</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(method);</span><br><span class="line">        <span class="comment">//通过方法对象来实现方法调用</span></span><br><span class="line">        method1.invoke(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="反射调用性能优化"><a href="#反射调用性能优化" class="headerlink" title="反射调用性能优化"></a>反射调用性能优化</h2><h3 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h3><p>优点：以实现运行时动态创建对象，增加程序的灵活性</p><p>缺点：反射操作的效率要比正常操作效率低很多</p><h3 id="反射调用优化-关闭访问检查"><a href="#反射调用优化-关闭访问检查" class="headerlink" title="反射调用优化-关闭访问检查"></a>反射调用优化-关闭访问检查</h3><ol><li>Method和Filed、Constructor对象都有setAccessible()方法</li><li>setAccessible作用是启动和禁用访问安全检查的开关</li><li>参数为true表示反射的对象在使用时取消访问检查，提高反射的效率。为false则表示反射的对象执行访问检查</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field</span></span><br><span class="line">        <span class="comment">//Method</span></span><br><span class="line">        <span class="comment">//Constructor</span></span><br><span class="line">        m1();</span><br><span class="line">        m2();</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法来调用hi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">90</span>; i++) &#123;</span><br><span class="line">            cat.hi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1() 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射机制调用方法hi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            hi.invoke(o);<span class="comment">//反射调用方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2() 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射调用优化 + 关闭访问检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        hi.setAccessible(<span class="literal">true</span>);<span class="comment">//在反射调用方法时，取消访问检查</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            hi.invoke(o);<span class="comment">//反射调用方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m3() 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Class类⭐️"><a href="#Class类⭐️" class="headerlink" title="Class类⭐️"></a>Class类⭐️</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366360339-d404cce6-83a1-46b2-8865-e5bc2a0543fd.png#averageHue=%236f7168&clientId=u20550a6b-f5bb-4&from=paste&height=476&id=u5c74c831&originHeight=643&originWidth=1136&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=701662&status=done&style=none&taskId=ub5e4de68-9404-4d8a-9871-b42e649bbf8&title=&width=841.4815409258765" alt="image.png"></p><h3 id="获得Class对象的6种方式"><a href="#获得Class对象的6种方式" class="headerlink" title="获得Class对象的6种方式"></a>获得Class对象的6种方式</h3><ol><li>前提：已知一个类的全类名，且该类在类路径下，可以通过Class类的静态方法forName()获取</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName()</span><br></pre></td></tr></table></figure><ol><li>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类.class</span><br></pre></td></tr></table></figure><ol><li>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象.getClass();</span><br></pre></td></tr></table></figure><ol><li>其他方式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> 对象.getClass().getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">class4</span> <span class="operator">=</span> cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure><ol start="5"><li>基本数据类型(int char boolean float double byte long short)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> 基本数据类型.class</span><br></pre></td></tr></table></figure><ol start="6"><li>基本数据类型对应的包装类，可以通过.TYPE得到Class对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> 包装类.TYPE</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. Class.forName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.hspedu.Car&quot;</span>; <span class="comment">//通过读取配置文件获取</span></span><br><span class="line">        Class&lt;?&gt; cls1 = Class.forName(classAllPath);</span><br><span class="line">        System.out.println(cls1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 类名.class , 应用场景: 用于参数传递</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Car.class;</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 对象.getClass(), 应用场景，有对象实例</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> car.getClass();</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 通过类加载器【4种】来获取到类的Class对象</span></span><br><span class="line">        <span class="comment">//(1)先得到类加载器 car</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//(2)通过类加载器得到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls4</span> <span class="operator">=</span> classLoader.loadClass(classAllPath);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cls1 , cls2 , cls3 , cls4 其实是同一个对象</span></span><br><span class="line">        System.out.println(cls1.hashCode());</span><br><span class="line">        System.out.println(cls2.hashCode());</span><br><span class="line">        System.out.println(cls3.hashCode());</span><br><span class="line">        System.out.println(cls4.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class类对象</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">        Class&lt;Character&gt; characterClass = <span class="type">char</span>.class;</span><br><span class="line">        Class&lt;Boolean&gt; booleanClass = <span class="type">boolean</span>.class;</span><br><span class="line">        System.out.println(integerClass);<span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 基本数据类型对应的包装类，可以通过 .TYPE 得到Class类对象</span></span><br><span class="line">        Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">        Class&lt;Character&gt; type2 = Character.TYPE; <span class="comment">//其它包装类BOOLEAN, DOUBLE, LONG,BYTE等待</span></span><br><span class="line">        System.out.println(type1);</span><br><span class="line"></span><br><span class="line">        System.out.println(integerClass.hashCode());<span class="comment">//?</span></span><br><span class="line">        System.out.println(type1.hashCode());<span class="comment">//?</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="哪些类型有Class对象"><a href="#哪些类型有Class对象" class="headerlink" title="哪些类型有Class对象"></a>哪些类型有Class对象</h3><ol><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;String&gt; cls1 = String.class;<span class="comment">//外部类</span></span><br><span class="line">        Class&lt;Serializable&gt; cls2 = Serializable.class;<span class="comment">//接口</span></span><br><span class="line">        Class&lt;Integer[]&gt; cls3 = Integer[].class;<span class="comment">//数组</span></span><br><span class="line">        Class&lt;<span class="type">float</span>[][]&gt; cls4 = <span class="type">float</span>[][].class;<span class="comment">//二维数组</span></span><br><span class="line">        Class&lt;Deprecated&gt; cls5 = Deprecated.class;<span class="comment">//注解</span></span><br><span class="line">        <span class="comment">//枚举</span></span><br><span class="line">        Class&lt;Thread.State&gt; cls6 = Thread.State.class;</span><br><span class="line">        Class&lt;Long&gt; cls7 = <span class="type">long</span>.class;<span class="comment">//基本数据类型</span></span><br><span class="line">        Class&lt;Void&gt; cls8 = <span class="keyword">void</span>.class;<span class="comment">//void数据类型</span></span><br><span class="line">        Class&lt;Class&gt; cls9 = Class.class;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line">        System.out.println(cls5);</span><br><span class="line">        System.out.println(cls6);</span><br><span class="line">        System.out.println(cls7);</span><br><span class="line">        System.out.println(cls8);</span><br><span class="line">        System.out.println(cls9);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.hspedu.Car&quot;</span>;</span><br><span class="line">    <span class="comment">//1 . 获取到Car类 对应的 Class对象</span></span><br><span class="line">    <span class="comment">//&lt;?&gt; 表示不确定的Java类型</span></span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">    <span class="comment">//2. 输出cls</span></span><br><span class="line">    System.out.println(cls); <span class="comment">//显示cls对象, 是哪个类的Class对象 com.hspedu.Car</span></span><br><span class="line">    System.out.println(cls.getClass());<span class="comment">//输出cls运行类型 java.lang.Class</span></span><br><span class="line">    <span class="comment">//3. 得到包名</span></span><br><span class="line">    System.out.println(cls.getPackage().getName());<span class="comment">//包名</span></span><br><span class="line">    <span class="comment">//4. 得到全类名</span></span><br><span class="line">    System.out.println(cls.getName());</span><br><span class="line">    <span class="comment">//5. 通过cls创建对象实例</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) cls.newInstance();</span><br><span class="line">    System.out.println(car);<span class="comment">//car.toString()</span></span><br><span class="line">    <span class="comment">//6. 通过反射获取属性 brand</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">    System.out.println(brand.get(car));<span class="comment">//宝马</span></span><br><span class="line">    <span class="comment">//7. 通过反射给属性赋值</span></span><br><span class="line">    brand.set(car, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">    System.out.println(brand.get(car));<span class="comment">//奔驰</span></span><br><span class="line">    <span class="comment">//8 我希望大家可以得到所有的属性(字段)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;=======所有的字段属性====&quot;</span>);</span><br><span class="line">    Field[] fields = cls.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        System.out.println(f.getName());<span class="comment">//名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对Class类特点的梳理"><a href="#对Class类特点的梳理" class="headerlink" title="对Class类特点的梳理"></a>对Class类特点的梳理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="comment">//看看Class类图</span></span><br><span class="line">       <span class="comment">//1. Class也是类，因此也继承Object类</span></span><br><span class="line">       <span class="comment">//Class</span></span><br><span class="line">       <span class="comment">//2. Class类对象不是new出来的，而是系统创建的</span></span><br><span class="line">       <span class="comment">//(1) 传统new对象</span></span><br><span class="line">       <span class="comment">/*  ClassLoader类</span></span><br><span class="line"><span class="comment">           public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">               return loadClass(name, false);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//Cat cat = new Cat();</span></span><br><span class="line">       <span class="comment">//(2) 反射方式, 刚才老师没有debug到 ClassLoader类的 loadClass, 原因是，我没有注销Cat cat = new Cat();</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           ClassLoader类, 仍然是通过 ClassLoader类加载Cat类的 Class对象</span></span><br><span class="line"><span class="comment">           public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">               return loadClass(name, false);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3. 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line">       System.out.println(cls1.hashCode());</span><br><span class="line">       System.out.println(cls2.hashCode());</span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Dog&quot;</span>);</span><br><span class="line">       System.out.println(cls3.hashCode());</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="类加载⭐️"><a href="#类加载⭐️" class="headerlink" title="类加载⭐️"></a>类加载⭐️</h2><h3 id="创建类的对象的方式"><a href="#创建类的对象的方式" class="headerlink" title="创建类的对象的方式"></a>创建类的对象的方式</h3><p>方式一：new + 构造器</p><p>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。</p><p>方式三：通过反射</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态类加载</p><ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不使用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><ul><li>类加载时机</li></ul><ol><li>当创建对象时（new）   静态加载</li><li>当子类被加载时，父类也加载   静态加载</li><li>调用类中的静态成员    静态加载</li><li>通过反射     动态加载</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366371294-99b52e60-372d-4e96-8692-2ff527f39e3d.png#averageHue=%232b2b25&clientId=u20550a6b-f5bb-4&from=paste&height=424&id=u1ba7e44b&originHeight=572&originWidth=1094&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=269677&status=done&style=none&taskId=u08f18424-0437-4c80-a749-f657c9fe766&title=&width=810.3704276169973" alt="image.png"></p><ul><li>类加载过程图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366383058-9af2d949-3f2f-4904-b6d4-873518b4478d.png#averageHue=%23a2b0ab&clientId=u20550a6b-f5bb-4&from=paste&height=654&id=u0219af9a&originHeight=883&originWidth=1700&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=771910&status=done&style=none&taskId=ud3351cbb-e8f8-46e4-b73c-4b9e230a45d&title=&width=1259.2593482165405" alt="image.png"></p><ul><li>类加载各阶段完成任务</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366399092-7a3648d2-6d95-4504-8e91-44544e1e1691.png#averageHue=%238f9494&clientId=u20550a6b-f5bb-4&from=paste&height=753&id=uab37c558&originHeight=1016&originWidth=1959&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=1520729&status=done&style=none&taskId=ue1d70466-0cdc-447d-9341-ebc2f517765&title=&width=1451.111213621296" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366407886-d62f9e50-0c23-4f75-9a98-7e7f753cc938.png#averageHue=%23e5e8b7&clientId=u20550a6b-f5bb-4&from=paste&height=254&id=uc6d52e51&originHeight=343&originWidth=1348&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=156451&status=done&style=none&taskId=u381126aa-d602-4593-a1df-d9b753b650c&title=&width=998.5185890564098" alt="image.png"></p><h3 id="加载阶段Loading"><a href="#加载阶段Loading" class="headerlink" title="加载阶段Loading"></a>加载阶段<strong>Loading</strong></h3><blockquote><p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p></blockquote><p><code>Loading</code> 就是把一个class文件装到内存中，它本来是class文件上一个个的二进制，一个个字节，通过Loading把它放到内存。<br>在加载阶段，Java 虚拟机需要完成以下工作：</p><p>通过类的全限定名获取类的二进制字节流。<br>将字节流转化为内部数据结构，并在内存中创建一个 java.lang.Class 对象来代表这个类。<br>在内存中为该类创建一个 java.lang.ClassLoader 对象，用于在后续的连接和初始化阶段使用。</p><h3 id="连接阶段—验证verification"><a href="#连接阶段—验证verification" class="headerlink" title="连接阶段—验证verification"></a>连接阶段—验证verification</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证（是否以魔数 oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</li><li>可以考虑使用 -Xverify：none 参数来关闭绝大部分的验证措施，缩短虚拟机类加载的时间</li></ol><h3 id="连接阶段—准备preparation"><a href="#连接阶段—准备preparation" class="headerlink" title="连接阶段—准备preparation"></a>连接阶段—准备preparation</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化(对应数据类型的默认初始化值如0 0L null false等)。这些变量所使用的内存都将在方法区中进行分配</p><p>把class文件静态变量赋默认值，不是赋初始值。比如 <code>static int i = 8</code> ，在该步骤只是把i赋了默认值0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//属性-成员变量-字段</span></span><br><span class="line">    <span class="comment">//老韩分析类加载的链接阶段-准备 属性是如何处理</span></span><br><span class="line">    <span class="comment">//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line">    <span class="comment">//2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是20</span></span><br><span class="line">    <span class="comment">//3. n3 是static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接阶段—解析resolution"><a href="#连接阶段—解析resolution" class="headerlink" title="连接阶段—解析resolution"></a>连接阶段—解析resolution</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>把class文件常量池里面用到的符号引用，把它转成直接内存地址，可以访问到的内容。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这一步就是将静态变量赋初始值，比如上面的 <code>static int i = 8</code> ，在这一步才赋初始值8。</p><ol><li>到初始化阶段，才真正开始执行类中定义的java程序代码，此阶段是执行()方法的过程</li><li>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值待做和静态代码块中的语句，并进行合并</li><li>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，知道活动线程执行()方法完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoad03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//老韩分析</span></span><br><span class="line">        <span class="comment">//1. 加载B类，并生成 B的class对象</span></span><br><span class="line">        <span class="comment">//2. 链接 num = 0</span></span><br><span class="line">        <span class="comment">//3. 初始化阶段</span></span><br><span class="line">        <span class="comment">//    依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句,并合并</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                clinit() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;B 静态代码块被执行&quot;);</span></span><br><span class="line"><span class="comment">                    //num = 300;</span></span><br><span class="line"><span class="comment">                    num = 100;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                合并: num = 100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new B();//类加载</span></span><br><span class="line">        <span class="comment">//System.out.println(B.num);//100, 如果直接使用类的静态属性，也会导致类的加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//看看加载类的时候，是有同步机制控制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span></span><br><span class="line"><span class="comment">        throws ClassNotFoundException</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //正因为有这个机制，才能保证某个类在内存中, 只有一份Class对象</span></span><br><span class="line"><span class="comment">            synchronized (getClassLoadingLock(name)) &#123;</span></span><br><span class="line"><span class="comment">            //....</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 静态代码块被执行&quot;</span>);</span><br><span class="line">        num = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B() 构造器被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，类的初始化是由 Java 虚拟机负责的，并且只会在以下情况下进行：</p><ul><li>创建类的实例。</li><li>访问类的静态变量。</li><li>调用类的静态方法。</li><li>使用反射方式对类进行操作。</li><li>初始化类的子类。</li><li>执行 Java 应用程序的 main 方法。</li></ul><h2 id="反射获取类的结构信息⭐️"><a href="#反射获取类的结构信息⭐️" class="headerlink" title="反射获取类的结构信息⭐️"></a>反射获取类的结构信息⭐️</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ol><li>getName:获取全类名</li><li>getSimpleName:获取简单类名</li><li>getFields:获取所有public修饰的属性，包含本类以及父类的(只能得到public)</li><li>getDeclaredFields:获取本类中所有属性</li><li>getMethods:获取所有public修饰的方法，包含本类以及父类的</li><li>getDeclaredMethods:获取本类中所有方法</li><li>getConstructors: 获取所有public修饰的构造器，包含本类</li><li>getDeclaredConstructors:获取本类中所有构造器</li><li>getPackage:以Package形式返回包信息</li><li>getSuperClass:以Class形式返回父类信息</li><li>getInterfaces:以Class[]形式返回接口信息</li><li>getAnnotations:以Annotation[] 形式返回注解信息</li></ol><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Field[] getFields()</span><br></pre></td></tr></table></figure><p>返回此 <code>Class</code> 对象所表示的类或接口的 <code>public</code> 的 <code>Field</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Field[] getDeclaredFields()</span><br></pre></td></tr></table></figure><p>返回此 <code>Class</code> 对象所表示的类或接口的全部 <code>Field</code></p><ol><li>getModifiers：以int形式返回修饰符</li></ol><p>[说明：默认修饰符是0 public：1 private：2 protected：4 static：8 final：16</p><p>public + static &#x3D; 9</p><p>]</p><ol start="2"><li>getType：以Class形式返回类型</li><li>getName：返回属性名</li></ol><p><strong>[获取属性Field]</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiledTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//获取属性结构</span></span><br><span class="line">        <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             fields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限修饰符  数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifiers)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = f.getType();</span><br><span class="line">            System.out.print(type.getName()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">            System.out.print(fName);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ol><li>getModifiers：以int形式返回修饰符</li></ol><p>[说明：默认修饰符是0 public：1 private：2 protected：4 static：8 final：16</p><p>public + static &#x3D; 9</p><p>]</p><ol start="2"><li>geReturntType：以Class形式获取 返回类型</li><li>getName：返回方法名</li><li>getParameterTypes：以Class[]返回参数类型数组</li></ol><p><strong>获取方法 Method</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getMethods():获取当前运行时类及其所有父类中声明为public权限的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             methods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</span></span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Xxxx</span></span><br><span class="line"><span class="comment">    权限修饰符  返回值类型  方法名(参数类型1 形参名1,...) throws XxxException&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            <span class="comment">//1.获取方法声明的注解</span></span><br><span class="line">            Annotation[] annos = m.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation a :</span><br><span class="line">                 annos) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.权限修饰符</span></span><br><span class="line">            System.out.print(Modifier.toString(m.getModifiers())+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.返回值类型</span></span><br><span class="line">            System.out.print(m.getReturnType().getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.方法名</span></span><br><span class="line">            System.out.print(m.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.形参列表</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (!(parameterTypes == <span class="literal">null</span> &amp;&amp; parameterTypes.length == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == parameterTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(parameterTypes[i].getName() + <span class="string">&quot;args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.抛出的异常</span></span><br><span class="line">            Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span> (exceptionTypes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;throws &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exceptionTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==exceptionTypes.length -<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(exceptionTypes[i].getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><ol><li>getModifiers:以int形式返回修饰符</li><li>getName：返回方法名(全类名)</li><li>getParameterTypes：以Class[]返回参数类型数组</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//得到Class对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.hspedu.reflection.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        <span class="comment">//规定 说明: 默认修饰符 是0 ， public  是1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                    + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                    + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一组方法API</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到Class对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.hspedu.reflection.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//getName:获取全类名</span></span><br><span class="line">        System.out.println(personCls.getName());<span class="comment">//com.hspedu.reflection.Person</span></span><br><span class="line">        <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">        System.out.println(personCls.getSimpleName());<span class="comment">//Person</span></span><br><span class="line">        <span class="comment">//getFields:获取所有public修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = personCls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getMethods:获取所有public修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getConstructors: 获取所有public修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getPackage:以Package形式返回 包信息</span></span><br><span class="line">        System.out.println(personCls.getPackage());<span class="comment">//com.hspedu.reflection</span></span><br><span class="line">        <span class="comment">//getSuperClass:以Class形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的class对象=&quot;</span> + superclass);<span class="comment">//</span></span><br><span class="line">        <span class="comment">//getInterfaces:以Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getAnnotations:以Annotation[] 形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span>, IB &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> age; <span class="comment">// 4 + 8 = 12</span></span><br><span class="line">    String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h3><ol><li>调用类中的public修饰的无参构造器</li><li>调用类中的指定构造器</li><li>Class类相关方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* newInstance：调用类中的无参构造器，获取对应类的对象</span><br><span class="line">* getConstructor(Class…clazz):根据参数列表，获取对应的<span class="keyword">public</span>构造器对象</span><br><span class="line">* getDecalaredConstructor(Class…clazz):根据参数列表，获取对应的所有构造器对象</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.javasm.practise.Student&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> aClass.newInstance();</span><br></pre></td></tr></table></figure><ol start="4"><li>Constructor类相关方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* setAccessible:爆破</span><br><span class="line">* newInstance(Object…obj):调用构造器</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤1 取得.class文件</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.java.practise.Student&quot;</span>);</span><br><span class="line"><span class="comment">//步骤2 取得当前文件的带参数的构造函数</span></span><br><span class="line">Constructor&lt;?&gt; declaredConstructor1 = aClass.getDeclaredConstructor(Car.class,String.class);</span><br><span class="line"><span class="comment">//步骤3 实例化 此处应注意用构造函数进行实例化而不是.class文件，因为.class文件进行实例只是利用无参构造。并且需要在此处进行初始化赋值，而不是在前一步初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">newInstance</span> <span class="operator">=</span> declaredConstructor1.newInstance(o1, <span class="string">&quot;小明&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h2><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>在反射机制中，可以直接通过 <code>Field</code> 类操作类中的属性，通过 <code>Field</code> 类提供的 <code>set()</code> 和<code>get()</code> 方法就可以完成设置和取得属性内容的操作。</p><ul><li><code>public Field getField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>public</code> 的 <code>Field</code>。 </li><li><code>public Field getDeclaredField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>Field</code>。<br>在 <code>Field</code> 中: </li><li><code>public Object get(object obj)</code> 取得指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容 </li><li><code>public void set(Object obj,Object value)</code> 设置指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容</li></ul><ol><li>根据属性名获取Field对相关</li></ol><p>Field f &#x3D; clazz对象.getDeclaredField(属性名);</p><ol start="2"><li>爆破：f.setAccessible(true); &#x2F;&#x2F;f是Field</li><li>访问</li></ol><p>f.set(o,值)；&#x2F;&#x2F;o是对象</p><p>syso(f.get(o));</p><ol start="4"><li>注意：如果是静态属性，则set和get中的参数o，可以写成null</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>通过反射，调用类中的方法，通过 <code>Method</code> 类完成。步骤:</p><ol><li>通过 <code>Class</code> 类的 <code>getMethod(String name,Class… parameterTypes)</code> 方法取得一个 <code>Method</code> 对象，并设置此方法操作时所需要的参数类型。 </li><li>之后使用 <code>Object invoke(Object obj， Object[] args)</code> 进行调用，并向方法中传递要设置的 <code>obj</code> 对象的参数信息。 </li><li>根据方法名和参数列表获取Method方法对象：Method m &#x3D; clazz.getDeclaredMethod(方法名,xx.class);&#x2F;&#x2F;得到本类的所有方法 </li><li>获取对象：Object o &#x3D; clazz.newInstance(); </li><li>爆破：m.setAccessible(true);</li></ol><blockquote><p><strong>关于 setAccessible 方法的使用：</strong></p><ul><li><code>Method</code> 和 <code>Field</code>、<code>Constructor</code> 对象都有 <code>setAccessible()</code> 方法。</li><li><code>setAccessible</code> 是启动和禁用访问安全检查的开关</li><li>参数值为 <code>true</code> 则指示反射的对象在使用时应该取消 Java 语言访问检査。</li><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true. 使得原本无法访问的私有成员也可以访问</li><li>参数值为 <code>false</code> 则指示反射的对象应该实施 Java 语言访问检査。</li></ul></blockquote><ol start="4"><li>访问：Object retutnValue &#x3D; m.invoke(o,实参列表)；</li></ol><blockquote><p><strong>Object invoke(object obj,Object… args)方法：</strong></p><ol><li><code>Object</code> 对应原方法的返回值，若原方法无返回值，此时返回 <code>null</code></li><li>若原方法若为静态方法，此时形参 <code>Object obj</code> 可为 <code>null</code></li><li>若原方法形参列表为空，则 <code>Object[] args</code> 为 <code>null</code></li><li>若原方法声明为 <code>private</code>，则需要在调用此 <code>invoke()</code> 方法前，显式调用方法对象的 <code>setAccessible(true)</code> 方法，将可访问 <code>private</code> 的方法。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(person, <span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的构造器</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式简介</title>
      <link href="/posts/c44e.html"/>
      <url>/posts/c44e.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="设计模式的产生背景"><a href="#设计模式的产生背景" class="headerlink" title="设计模式的产生背景"></a>设计模式的产生背景</h2><p>软件设计模式的产生背景可以追溯到20世纪60年代和70年代，当时计算机软件行业开始迅速发展。随着软件规模的不断扩大，软件开发人员发现传统的软件设计方法已经无法满足需求，因为它们缺乏可重用性、可维护性和可扩展性。<br>在这种情况下，一些软件开发专家开始研究如何通过规范化软件开发过程来解决这些问题。他们提出了一些通用的设计思想和解决方案，这些思想和方案被称为“设计模式”。<br>设计模式是指在软件开发中经常遇到的⼀些重复性问题，通过对这些问题的总结、抽象、归纳和提炼，得到的⼀些<br>解决问题的通⽤⽅案。<br>学习和使⽤设计模式可以帮助开发⼈员提⾼代码的可重⽤性、可维护性、可扩展性和可读性，从⽽提⾼开发效率和<br>代码质量。<br>设计模式分为三⼤类：</p><ul><li>创建型模式：共5种：⼯⼚⽅法模式、抽象⼯⼚模式、单例模式、建造者模式、原型模式</li><li>结构型模式：共7种：适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式</li><li>⾏为型模式：共11种：策略模式、模板⽅法模式、观察者模式、责任链模式、访问者模式、中介者模式、迭代器模式、命令模式、状态模式、备忘录模式、解释器模式</li></ul><h2 id="学习设计模式的必要性"><a href="#学习设计模式的必要性" class="headerlink" title="学习设计模式的必要性"></a>学习设计模式的必要性</h2><p>学习设计模式对于软件开发人员来说是非常必要的，因为：</p><ol><li>提高代码质量：设计模式可以提高代码的可重用性、可维护性和可扩展性，从而提高代码的质量。 </li><li>减少开发时间：通过使用设计模式，开发人员可以更快地开发出高质量的软件，因为他们不需要从头开始编写每个功能。 </li><li>降低错误率：设计模式可以帮助开发人员避免一些常见的编程错误，例如类的继承关系不清晰、代码重复等。 </li><li>提高团队协作效率：设计模式可以使团队成员更容易地理解和共享代码，从而提高团队的协作效率。 </li><li>增强软件的可读性和可维护性：设计模式可以使代码更易于阅读和维护，因为它们提供了一种通用的方法来解决特定的问题。</li></ol><p>总之，学习设计模式可以帮助开发人员更好地理解软件开发的本质和原理，提高他们的技能水平和工作效率，从而更好地应对日益复杂的软件开发挑战。</p><h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><p>设计模式有几个原则，其中比较著名的有 SOLID 原则、GRASP 原则、KISS 原则和 DRY 原则等。以下是这些原则的简要介绍：</p><ol><li>SOLID原则：SOLID 原则是一组面向对象设计的基本原则，包括单一职责原则、开放封闭原则、里氏替换原则、接口隔离原则和依赖倒置原则等。这些原则可以帮助开发人员编写更加灵活、可扩展和可维护的代码。 </li><li>GRASP原则：GRASP 原则是一组面向对象设计的准则，包括高内聚、低耦合、专注点、创造者、信息专家、纯粹制造者、多态性和保持简单等。这些原则可以帮助开发人员更好地理解和设计系统架构。 </li><li>KISS原则：KISS 原则是一种简单性原则，即“保持简单和直接”。这个原则的核心思想是，设计应该保持简单和直接，避免过度复杂化和过度设计。这样可以提高代码的可读性、可维护性和可重用性。 </li><li>DRY原则：DRY 原则是一种“不要重复自己”的原则，即相同的代码不应该重复出现在不同的地方。这个原则可以提高代码的可维护性和可重用性，避免重复的劳动和错误。</li></ol><p>这些原则都是在面向对象编程中非常重要的指导原则，可以帮助开发人员编写更加高质量、可维护和可重用的代码。它们不仅适用于设计模式的使用，也适用于其他编程范式和技术的开发过程中。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>单一职责原则</strong>（Single Responsibility Principle，SRP）是SOLID原则中的一条，指一个类或模块应该只有一个责任。具体来说，就是<strong>一个类或模块只负责一项功能或职责，不承担过多的职责</strong>，以提高其内聚性和可维护性。<br>单一职责原则的核心思想是将不同的职责分离开来，避免一个类或模块承担过多的职责，导致代码混乱、难以维护和扩展。如果一个类或模块承担了过多的职责，那么它就会变得臃肿、复杂、难以测试和修改。相反，如果每个类或模块只负责一项职责，那么它就会变得简单、清晰、易于理解和修改。<br>在实践中，如何判断一个类或模块是否遵循单一职责原则呢？可以通过以下几点来判断：</p><ol><li><strong>类或模块的职责是否明确</strong>：一个类或模块应该有一个明确的职责，而不是承担多个职责。如果一个类或模块有多个职责，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的方法数量是否合理</strong>：一个类或模块的方法数量应该与其职责相匹配。如果一个类或模块有大量的方法，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的复杂度是否合理</strong>：一个类或模块的复杂度应该与其职责相匹配。如果一个类或模块过于复杂，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的修改频率是否合理</strong>：一个类或模块的修改频率应该与其职责相匹配。如果一个类或模块经常需要修改，那么就需要考虑将其分解成多个类或模块。</li></ol><p>单一职责原则是面向对象编程中非常重要的原则之一，它可以提高代码的内聚性、可维护性和可扩展性。一个类或模块只负责一项职责，可以使它的职责更加明确、方法数量更加合理、复杂度更加合理、修改频率更加合理，从而使代码更加简单、清晰、易于理解和修改。在实践中，开发人员应该尽可能遵循单一职责原则，将不同的职责分离开来，避免一个类或模块承担过多的职责，导致代码难以维护和扩展。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>开闭原则</strong>(<strong>Open Closed Principle</strong>,<strong>OCP</strong>)是面向对象设计中的一项基本原则，它的核心思想是：对于一个软件实体(类、模块、函数等),应该<strong>对扩展开放，对修改关闭</strong>。<br>具体来说，开闭原则包括以下两点：</p><ol><li><strong>对扩展开放</strong>(Open for Extension):一个软件实体应该对新的功能或需求开放，也就是说，如果需要增加新的功能，应该通过添加新的方法、属性或者类来实现，而不是修改原有代码。这样可以保证代码的可扩展性和灵活性，同时也方便了维护和升级。 </li><li><strong>对修改封闭</strong>(Closed for Modification):一个软件实体不应该被修改，也就是说，如果需要修改已有的功能或需求，应该通过创建新的类、方法或者属性来实现，而不是修改原有代码。这样可以避免代码的不一致性和耦合性，提高了代码的可维护性和稳定性。</li></ol><p>开闭原则可以帮助开发人员编写出易于扩展和维护的高质量代码，同时也符合面向对象编程的基本原则之一——封装。通过遵循开闭原则，开发人员可以更好地管理软件实体的变化，使得系统更加健壮、可靠和可维护。</p><h2 id="里式替换原则📍"><a href="#里式替换原则📍" class="headerlink" title="里式替换原则📍"></a>里式替换原则📍</h2><p><strong>里式替换原则</strong>(Liskov Substitution Principle,LSP)是面向对象设计中的一项基本原则。<br><strong>通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</strong><br>由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h2 id="依赖倒装原则"><a href="#依赖倒装原则" class="headerlink" title="依赖倒装原则"></a>依赖倒装原则</h2><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节，细节应该依赖抽象；</li><li>依赖倒装的中心思想就是：面向接口编程；<blockquote><p><a href="https://blog.csdn.net/weixin_39327556/article/details/125250988?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BE%9D%E8%B5%96%E5%80%92%E8%A3%85%E5%8E%9F%E5%88%99&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-125250988.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">引用例子原文</a></p></blockquote></li></ul><p>场景：人们之间的沟通方式（电话、微信）</p><ul><li>错误设计（新增要修改代码，不好维护）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684569254312-87c9fd29-c94c-431c-ba35-9ccf4b39adc7.png#averageHue=%23fcfcfc&clientId=u03d49c43-b92a-4&from=paste&height=293&id=ue8eb6ba7&originHeight=396&originWidth=617&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=25308&status=done&style=none&taskId=u390229fd-9f33-45ac-b535-2270251f042&title=&width=457.0370693232974" alt="image.png"></p><ul><li>正确设计</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684569296519-f7c9e6dc-77aa-42f8-b91c-9c15fcc58d2f.png#averageHue=%23fcfbf9&clientId=u03d49c43-b92a-4&from=paste&id=ue276833a&originHeight=633&originWidth=782&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=35508&status=done&style=none&taskId=uf459a998-33df-4aa9-9f4c-04e60d61b70&title=" alt="image.png"></p><ul><li>peison类属于高层模块，不应该依赖于低层模块，而是要依赖于抽象。</li><li>细节（Email、Weixin）依赖抽象（IReciver）。</li></ul><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。<br><strong>每一个接口应该承担一种相对独立的角色，不干不该干的事情，干该干的事请。</strong><br><strong>在使用接口隔离原则时我们要控制接口的颗粒度，颗粒度不能太大，也不能太小。如果太小就会造成接口泛滥，不利于维护；接口入如果太大就会违背接口隔离原则，灵活性较差，使用起来不方便</strong>。一般来说接口中仅包含某业务模块的方法即可，不应该有其他业务模块的方法。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote><p><a href="https://blog.csdn.net/qq_34222160/article/details/123539464?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168456952816782425178194%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168456952816782425178194&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123539464-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99&spm=1018.2226.3001.4187">原文</a></p></blockquote><p>迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少的与其他实体发生相互作用。<br>如果一个系统满足迪米特法则，那么当其中一个软件实体发生变化时，就会尽量少的影响其他软件实体，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可以降低系统的耦合度，使类与类之间保持松耦合状态</strong>。<br>迪米特法则还有几种定义形式，包括：不要和”陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><ul><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。</li><li>当前对象创建的对象</li></ul><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则（Composition Over Inheritance，COI）是面向对象编程中的一个原则，它强调使用组合（Composition）而不是继承（Inheritance）来实现代码的复用。<br><strong>合成&#x2F;聚合复用原则是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的</strong>。<br>简述为：<strong>要尽量使用合成&#x2F;聚合，尽量不要使用继承</strong>。</p><ul><li>聚合has-A</li><li>组合contains-A</li><li>继承is-A</li></ul><p>具体来说，合成复用原则可以通过以下几点来实现：</p><ol><li>将类的<strong>功能分解</strong>为较小的粒度：将类的功能分解为较小的粒度，每个类只负责一项职责，这样可以提高代码的内聚性和可维护性。 </li><li>使用<strong>组合</strong>来实现代码复用：根据需要，将现有类的实例组合起来创建新的功能。这样可以使代码更加灵活、可扩展和可维护，同时避免了继承带来的一些问题。 </li><li><strong>优先使用接口</strong>而不是实现类：在使用组合时，优先使用接口而不是实现类。这样可以使代码更加灵活、可扩展和可维护，同时避免了依赖具体实现类带来的一些问题（如紧耦合、难以替换等）。 </li><li><strong>避免过度设计</strong>：在使用组合时，避免过度设计。只有当需要复用的功能足够复杂时才使用组合，否则可以直接在当前类中实现。过度设计会增加代码的复杂性和维护成本。</li></ol><p>合成复用原则是面向对象编程中非常重要的原则之一，它可以提高代码的灵活性、可扩展性和可维护性。使用组合而不是继承来实现代码的复用，可以避免继承带来的一些问题，如紧耦合、派生类的脆弱性等。在实践中，开发人员应该尽可能遵循合成复用原则，将现有的类组合起来创建新的功能，同时避免过度设计和依赖具体实现类，从而使代码更加灵活、可扩展和可维护。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/43de.html"/>
      <url>/posts/43de.html</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。<br>JDK1.8和之前的版本略有不同，我们这里以JDK1.7和JDK1.8这两个版本为例介绍。<br>JDK1.7<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549410036-90c7236d-8a09-496b-8c48-d7a6adea79ab.png?x-oss-process=image/resize,w_1068,limit_0#averageHue=%23cfe7de&from=url&id=dVixk&originHeight=1121&originWidth=1068&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>JDK1.8<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549564819-26518ebd-f88c-4093-ba31-fea1211758e9.png#averageHue=%23c4e3da&from=url&id=mgiKA&originHeight=905&originWidth=701&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>程私有的</strong>：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的</strong>：</p><ul><li>堆</li><li>方法区</li><li>直接内存（非运行时数据的一部分）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683550157412-b0e7c7e8-13df-4cf1-ae46-6393d80d39b8.png#averageHue=%23f8e6b1&from=url&id=JJ8cx&originHeight=882&originWidth=569&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。无内存溢出问题<br>作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -verbose  xx.class    打印堆栈大小，局部变量的数量和方法的参数。</span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685362513499-e524c1c6-8e59-4676-b91c-346cd9752be2.png#averageHue=%23faf9f9&clientId=ufdf2cef5-e05b-4&from=paste&height=558&id=u96396e65&originHeight=753&originWidth=1393&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=270328&status=done&style=none&taskId=ua9ab6d6a-a6c2-46b1-adba-b483d866982&title=&width=1031.8519247444947" alt="image.png"><br>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。<br>那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。<br>程序计数器是JVM规范中唯一一个没有规定出现OOM（<code>OutOfMemoryError</code>）的区域，所以这个空间也不会进行GC。</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>线程私有，描述Java方法的执行过程<br>Java Virtual machine Stacks (java 虚拟机栈)</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈，先进后出 </li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存 </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685363455154-0bfc17d8-1f56-487a-9982-56a8ad338bba.png#averageHue=%23f3fcf5&clientId=ucd8db9d2-4e00-4&from=paste&id=u174eb4db&originHeight=551&originWidth=451&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=31578&status=done&style=none&taskId=uc7a35740-62cf-4b91-b08a-5cd6f1061ec&title=" alt="image.png"><br><strong>局部变量表</strong>：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。<br><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685363640509-2f4a82de-adae-4e5f-82ab-89ac3beaed6d.png#averageHue=%23d5d5d5&clientId=ucd8db9d2-4e00-4&from=paste&id=u7c60c1b5&originHeight=569&originWidth=699&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=52599&status=done&style=none&taskId=uf758cbec-6565-4f37-90e0-d0b8ae129b9&title=" alt="image.png"><br>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说，** 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束**。<br>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><code>StackOverFlowError</code>： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError </code>错误。</li><li><code>OutOfMemoryError</code>： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><ol><li>垃圾回收是否涉及栈内存？<br>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放 </li><li>栈内存分配越大越好吗？<br>未必，默认的栈内存通常为1024k<br>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半 </li><li>方法内的局部变量是否线程安全？</li></ol><ul><li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的 </li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全 </li><li>比如以下代码：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685363914612-e32f0740-2ccd-4672-89c6-83640a6d28f1.png#averageHue=%23e9efdb&clientId=ucd8db9d2-4e00-4&from=paste&height=585&id=u8629f588&originHeight=790&originWidth=696&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=216489&status=done&style=none&taskId=u0cef7c22-2f5c-4aee-9dbb-ac8f184519b&title=&width=515.5555919757131" alt="image.png"></p><ol start="4"><li>堆栈的区别是什么？</li></ol><ul><li>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会 </li><li>栈内存是线程私有的，而堆内存是线程共有的 </li><li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常 <ul><li>栈空间不足：<code>java.lang.StackOverFlowError</code></li><li>堆空间不足：<code>java.lang.OutOfMemoryError</code></li></ul></li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。<br>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code>和 <code>OutOfMemoryError</code> 两种错误</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在JVM运行过程中创建的对象和产生的数据都被存储在堆中，堆是被线程共享的内存区域，也是垃圾收集器进行垃圾回收的最主要的内存区域。由于现代JVM采用<strong>分代收集算法</strong>，因此Java堆从GC（Garbage Collection，垃圾回收）的角度还以细分为：<strong>新生代、老年代和永久代</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630793404-9b3b6bee-23d1-4cdb-a2f3-d8df84d58540.png#averageHue=%23fafaf9&from=url&id=accKy&originHeight=541&originWidth=992&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>JVM的新生代是垃圾回收器的主要关注区域之一，也是Java程序中最常用的内存区域之一。新生代被分为三个不同的区域：Eden区、Survivor区和Old区。JVM创建的对象（除了大对象）会被放在新生代</p><ol><li>Eden区：是新生代中最大的一个区域，主要用于存放新创建的对象。当一个对象被创建时，它会被分配到Eden区中，经过一段时间后，如果该对象没有被任何其他引用指向，就会被移动到Survivor区中。 </li><li>Survivor From区：</li><li>Survivor To区：</li></ol><p>JVM的新生代采用复制算法进行垃圾回收，即将存活的对象复制到另一个空闲的区域中，以便减少垃圾回收器的扫描范围。这种算法的优点是可以减少扫描的范围，但缺点是需要更多的内存来存储复制后的对象。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代是Java虚拟机(JVM)中的一个重要的内存区域，用于存放生命周期较长、存活时间较长的对象。当一个对象被创建时，它会被分配到新生代中的Eden区或Survivor区中，如果经过多次垃圾回收后仍然存活，那么它就会被晋升到老年代中。</p><p>在老年代中，垃圾回收器不会进行复制算法，而是采用标记清除、标记整理、分代收集等方式进行垃圾回收。因为老年代中的对象生命周期较长，所以它们占用的内存也较大，如果使用复制算法，会浪费更多的内存空间。</p><p>老年代中的对象通常包含一些重要的信息，比如类元数据、常量池等，因此在进行垃圾回收时需要特别小心，以免误删重要对象导致程序出错。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>永久代是Java虚拟机(JVM)中的一个特殊的内存区域，主要用于存放类的信息、常量池、静态变量等。在JDK1.8及之前的版本中，永久代是JVM的一部分，而在JDK1.8中，永久代被移除并取代为元空间(Metaspace),但是一些老的应用程序仍然在使用永久代。</p><p>在永久代中，所有的类信息和常量池都被存储在一个叫做“类定义”的表格中，每个类都有一个唯一的标识符作为键值。当一个类被加载时，它的类定义会被复制到永久代中，并且在运行时可以通过类名来访问。</p><p>由于永久代的特殊作用，它在垃圾回收中具有重要的地位。在垃圾回收过程中，如果永久代中存在未被引用的对象，那么这些对象就会被认为已经死亡，并且可以被回收。但是由于永久代的特殊性质，垃圾回收器需要特别小心，以免误删重要对象导致程序出错。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>方法区(Method Area)是各个线程共享的内存区域 </li><li>主要存储类的信息、运行时常量池 </li><li>虚拟机启动的时候创建，关闭虚拟机时释放 </li><li>如果方法区域中的内存无法满足分配请求，则会抛出<code>OutOfMemoryError: Metaspace </code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364137295-8b0a9048-bea8-49a2-8263-abd32b8aaf5b.png#averageHue=%23f8eae7&clientId=ucd8db9d2-4e00-4&from=paste&height=360&id=ucca0aca8&originHeight=486&originWidth=949&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=66948&status=done&style=none&taskId=u367f811b-cb68-4b64-9e2a-17f83fbee9d&title=&width=702.963012622057" alt="image.png"><br><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364212135-ae69c7ef-a96b-4e79-85bd-2d8e7ceed0e0.png#averageHue=%23f4fdf6&clientId=ucd8db9d2-4e00-4&from=paste&id=ufe0ece25&originHeight=241&originWidth=522&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22102&status=done&style=none&taskId=ub2917c9f-244a-439e-8b5f-4e3ca9c0f9a&title=" alt="image.png"></p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><blockquote><p>常量池：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息<br>查看字节码结构（类的基本信息、常量池、方法定义）<code>javap -v xx.class</code></p></blockquote><p><a href="https://blog.csdn.net/fengyuyeguirenenen/article/details/123150212">https://blog.csdn.net/fengyuyeguirenenen/article/details/123150212</a></p><blockquote><p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</p></blockquote><p>方法区的Class文件信息，Class常量池和运行时常量池的三者关系<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364415226-94df4d89-5068-4bc6-b7ef-c87ee298d058.png#averageHue=%23d2e6d0&clientId=ucd8db9d2-4e00-4&from=paste&id=u356e219b&originHeight=330&originWidth=486&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=20298&status=done&style=none&taskId=u76fbc400-889b-4685-8e93-546ae1c48b7&title=" alt="image.png"></p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><blockquote><p>字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool。 在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p></blockquote><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364475664-44b26899-99c6-46be-98b3-41681f02fb7a.png#averageHue=%23f3fcf5&clientId=ucd8db9d2-4e00-4&from=paste&id=u3ab2eb43&originHeight=491&originWidth=751&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=45629&status=done&style=none&taskId=u40bf6134-513c-49e5-854e-42f9844f66e&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364483113-3e883c2c-f02e-4efa-8d28-e4cb8bb5d6d1.png#averageHue=%23f2fcf4&clientId=ucd8db9d2-4e00-4&from=paste&id=u8c2eb0ed&originHeight=411&originWidth=751&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=43086&status=done&style=none&taskId=u501c3be6-7d8a-4339-b39d-19aab4ffbed&title=" alt="image.png"></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>类加载器</strong></p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是<code>java.lang.ClassLoader</code>的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源<br><strong>类加载器种类</strong><br>类加载器根据各自加载范围的不同，划分为四种类加载器：</p><ul><li><strong>启动类加载器(BootStrap ClassLoader)：</strong><br>该类并不继承<code>ClassLoader</code>类，其是由C++编写实现。用于加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib</strong>目录下的类库。 </li><li><strong>扩展类加载器(ExtClassLoader)：</strong><br>该类是<code>ClassLoader</code>的子类，主要加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</strong>目录中的类库。 </li><li><strong>应用类加载器(AppClassLoader)：</strong><br>该类是<code>ClassLoader</code>的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。 </li><li><strong>自定义类加载器：</strong><br>开发者自定义类继承<code>ClassLoade</code>r，实现自定义类加载规则。</li></ul><p>上述三种类加载器的层次结构如下如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364829032-bd33e79e-baa9-45e5-9143-a11358536e8f.png#averageHue=%23f1ddd4&clientId=ucd8db9d2-4e00-4&from=paste&height=629&id=u0de07e8b&originHeight=849&originWidth=957&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=163553&status=done&style=none&taskId=u60e6cd93-9745-48f2-b5ac-1a161cde2dd&title=&width=708.8889389666055" alt="image.png"></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 </p><p>为什么采用双亲委派机制</p><ol><li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</li><li>为了安全，保证类库API不会被修改。</li></ol><h2 id="类装载执行过程"><a href="#类装载执行过程" class="headerlink" title="类装载执行过程"></a>类装载执行过程</h2><ul><li>类加载过程图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366046084-c9497261-65f8-4d0d-99cf-93be87698841.png#averageHue=%23a2b0ab&clientId=ucd8db9d2-4e00-4&from=paste&height=341&id=uf398b8ae&originHeight=461&originWidth=873&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=288440&status=done&style=none&taskId=ub3ff8247-7398-495e-831d-95e26d878d7&title=&width=646.666712348847" alt="image.png"></p><ul><li>类加载各阶段完成任务</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366095080-cc9f6d28-01f4-4ddf-8cac-3dad382e1b4f.png#averageHue=%23767a79&clientId=ucd8db9d2-4e00-4&from=paste&height=410&id=ub84f2255&originHeight=553&originWidth=870&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=550625&status=done&style=none&taskId=u04595ae2-2811-4bb8-a01c-5edcbc400b4&title=&width=644.4444899696414" alt="image.png"><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/10854/image-20220924201722195.png#clientId=ucd8db9d2-4e00-4&id=lK8Qb&originHeight=250&originWidth=1009&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u42662092-4996-4feb-add3-2cd46903186&title="></p><h3 id="加载阶段Loading"><a href="#加载阶段Loading" class="headerlink" title="加载阶段Loading"></a>加载阶段<strong>Loading</strong></h3><blockquote><p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p></blockquote><p><code>Loading</code> 就是把一个class文件装到内存中，它本来是class文件上一个个的二进制，一个个字节，通过Loading把它放到内存。<br>在加载阶段，Java 虚拟机需要完成以下工作：</p><p>通过类的全限定名获取类的二进制字节流。<br>将字节流转化为内部数据结构，并在内存中创建一个 java.lang.Class 对象来代表这个类。<br>在内存中为该类创建一个 java.lang.ClassLoader 对象，用于在后续的连接和初始化阶段使用。</p><h3 id="连接阶段—验证verification"><a href="#连接阶段—验证verification" class="headerlink" title="连接阶段—验证verification"></a>连接阶段—验证verification</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证（是否以魔数 oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</li><li>可以考虑使用 -Xverify：none 参数来关闭绝大部分的验证措施，缩短虚拟机类加载的时间</li></ol><h3 id="连接阶段—准备preparation"><a href="#连接阶段—准备preparation" class="headerlink" title="连接阶段—准备preparation"></a>连接阶段—准备preparation</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化(对应数据类型的默认初始化值如0 0L null false等)。这些变量所使用的内存都将在方法区中进行分配</p><p>把class文件静态变量赋默认值，不是赋初始值。比如 <code>static int i = 8</code> ，在该步骤只是把i赋了默认值0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//属性-成员变量-字段</span></span><br><span class="line">    <span class="comment">//老韩分析类加载的链接阶段-准备 属性是如何处理</span></span><br><span class="line">    <span class="comment">//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line">    <span class="comment">//2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是20</span></span><br><span class="line">    <span class="comment">//3. n3 是static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接阶段—解析resolution"><a href="#连接阶段—解析resolution" class="headerlink" title="连接阶段—解析resolution"></a>连接阶段—解析resolution</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>把class文件常量池里面用到的符号引用，把它转成直接内存地址，可以访问到的内容。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这一步就是将静态变量赋初始值，比如上面的 <code>static int i = 8</code> ，在这一步才赋初始值8。</p><ol><li>到初始化阶段，才真正开始执行类中定义的java程序代码，此阶段是执行()方法的过程</li><li>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值待做和静态代码块中的语句，并进行合并</li><li>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，知道活动线程执行()方法完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoad03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//老韩分析</span></span><br><span class="line">        <span class="comment">//1. 加载B类，并生成 B的class对象</span></span><br><span class="line">        <span class="comment">//2. 链接 num = 0</span></span><br><span class="line">        <span class="comment">//3. 初始化阶段</span></span><br><span class="line">        <span class="comment">//    依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句,并合并</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                clinit() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;B 静态代码块被执行&quot;);</span></span><br><span class="line"><span class="comment">                    //num = 300;</span></span><br><span class="line"><span class="comment">                    num = 100;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                合并: num = 100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new B();//类加载</span></span><br><span class="line">        <span class="comment">//System.out.println(B.num);//100, 如果直接使用类的静态属性，也会导致类的加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//看看加载类的时候，是有同步机制控制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span></span><br><span class="line"><span class="comment">        throws ClassNotFoundException</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //正因为有这个机制，才能保证某个类在内存中, 只有一份Class对象</span></span><br><span class="line"><span class="comment">            synchronized (getClassLoadingLock(name)) &#123;</span></span><br><span class="line"><span class="comment">            //....</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 静态代码块被执行&quot;</span>);</span><br><span class="line">        num = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B() 构造器被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，类的初始化是由 Java 虚拟机负责的，并且只会在以下情况下进行：</p><ul><li>创建类的实例。</li><li>访问类的静态变量。</li><li>调用类的静态方法。</li><li>使用反射方式对类进行操作。</li><li>初始化类的子类。</li><li>执行 Java 应用程序的 main 方法。</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。<br>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629182248-e3c2609d-1dd2-491a-9304-cdc7f1a188aa.png#averageHue=%23f2fbf4&from=url&id=nkKE7&originHeight=177&originWidth=361&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<br>下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629305757-0545fc81-98da-4b24-8a6e-ec79be5733b8.png#averageHue=%23f5fef7&from=url&id=JQHl1&originHeight=541&originWidth=721&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="哪些对象可以作为GC-Roots"><a href="#哪些对象可以作为GC-Roots" class="headerlink" title="哪些对象可以作为GC Roots"></a>哪些对象可以作为GC Roots</h3><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="对象可以被回收，就代表一定会被回收吗？"><a href="#对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="对象可以被回收，就代表一定会被回收吗？"></a>对象可以被回收，就代表一定会被回收吗？</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 <code>finalize </code>方法，或 <code>finalize </code>方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h2 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。<br>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629511889-7f16b482-7a56-4001-9053-293de927737e.png#averageHue=%23a5d5d4&from=url&id=w2dXv&originHeight=451&originWidth=651&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p> 为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629545584-086144bd-459b-486c-b312-bcf37e57c101.png#averageHue=%23f4fdf6&from=url&id=iUB5C&originHeight=451&originWidth=741&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>改进了标记-清除算法，但依然存在下面的问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能就会变得很差</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p> 标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629673024-50bb9a34-5cc5-41dd-b5b9-039c7c94d94c.png#averageHue=%2391cbcc&from=url&id=EAutu&originHeight=451&originWidth=661&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，针对不同类型的对象类型，JVM采用了不同的垃圾回收算法。将 Java 堆分为新生代和老年代，新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，每次进行垃圾回收都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，可回收的对象相对较少<br>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“<strong>标记-清除</strong>”或“标记-整理”算法进行垃圾收集。<br>JVM将新生代进一步划分。JVM在运行过程中主要使用Eden区和Survivor From区，进行垃圾回收时会将Eden区和Survivor From区中存活的对象复制到Survivor To区，然后清理两个区的内存空间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630382838-fc023dfe-bf13-4a03-bd1e-11f81db51cf2.png#averageHue=%23f9f6ee&from=url&id=kY734&originHeight=324&originWidth=845&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。<br>Java中的四种引用类型包括：</p><ol><li>强引用(Strong Reference):是最常见的引用类型，如果一个对象被强引用指向，垃圾回收器就不会回收它。 </li><li>软引用(Soft Reference):用来描述一些还有用但并非必需的对象。只有当内存不足时，垃圾回收器才会回收被软引用指向的对象。 </li><li>弱引用(Weak Reference):用来描述非必需对象，但是比软引用更弱。如果一个对象只被弱引用所指向，那么垃圾回收器在下一次回收时就会回收它。 </li><li>虚引用(Phantom Reference):是最弱的引用类型，用来描述不可能存活的对象。如果一个对象只被虚引用所指向，那么垃圾回收器在任何时候都有可能回收它。</li></ol><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>Java堆内存分为新生代和老年代：新生代主要存储短期生命周期对象，适合使用复制算法进行垃圾回收；老年代主要存储长生命周期的对象，适合使用标记整理算法进行垃圾回收.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631816626-8133fe52-fd39-4b9f-ab52-26a570234e07.png#averageHue=%23fbf2eb&from=url&id=yMAHS&originHeight=581&originWidth=1468&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>JVM(Java虚拟机)垃圾收集器是用于自动管理堆内存的一组工具。它们的主要目标是尽可能地减少应用程序暂停时间，以提高应用程序的性能和响应能力。</p><p>以下是一些常见的JVM垃圾收集器：</p><ol><li>Serial收集器：这是默认的收集器，它使用单线程来标记和清除存活的对象。它适用于小型应用程序，因为它的缺点是垃圾回收时间较长，可能会导致应用程序暂停。 </li><li>Parallel收集器：这是一种多线程收集器，它可以利用多个CPU核心并行执行标记和清除操作，从而缩短垃圾回收时间。它适用于大型应用程序，但需要更多的系统资源。 </li><li>CMS收集器：这是一种低延迟收集器，它可以在应用程序运行时进行垃圾回收，而不会影响应用程序的性能。它适用于对响应时间要求较高的应用程序。 </li><li>G1收集器：这是一种基于区域的收集器，它将堆划分为多个大小相等的区域，并在这些区域内进行垃圾回收。它可以减少GC暂停时间并提高吞吐量。它适用于大型应用程序和高负载环境。</li></ol><p>JVM垃圾收集器的选择取决于应用程序的需求和环境。在选择垃圾收集器时，需要考虑应用程序的性质、硬件配置、可用内存等因素。</p><h2 id="新生代-1"><a href="#新生代-1" class="headerlink" title="新生代"></a>新生代</h2><h3 id="Serial收集器：单线程，复制算法"><a href="#Serial收集器：单线程，复制算法" class="headerlink" title="Serial收集器：单线程，复制算法"></a>Serial收集器：单线程，复制算法</h3><p>Serial垃圾收集器基于复制算法实现，它是一个单线程收集器，在它正在进行垃圾收集时，必须暂停其它工作线程，直到垃圾收集完毕<br>特点：简单、高效<br>是Java虚拟机运行在Client模式下的新生代的默认垃圾处理器<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631968047-9ae37729-acbd-4099-8c4e-5766fa6c7bbf.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=ueda4f2cf&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=u43d8d21c-2fae-4754-b613-adde849c645&title=" alt="image.png"></p><h3 id="ParNew收集器：多线程，复制算法"><a href="#ParNew收集器：多线程，复制算法" class="headerlink" title="ParNew收集器：多线程，复制算法"></a>ParNew收集器：多线程，复制算法</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632203749-aa4e1baa-dc1f-40e9-8bcd-043597efb590.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u722ab4f7&originHeight=245&originWidth=853&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=23095&status=done&style=none&taskId=uedad3fd7-98d4-457a-9f86-55dad756f63&title=" alt="image.png"></p><h3 id="Parallel-Scavenge收集器：多线程，复制算法"><a href="#Parallel-Scavenge收集器：多线程，复制算法" class="headerlink" title="Parallel Scavenge收集器：多线程，复制算法"></a>Parallel Scavenge收集器：多线程，复制算法</h3><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632308217-b9c5b923-2fb8-401f-ba88-d9678cd79d5b.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=uceece797&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u978058f2-2415-4553-b2f3-b99efd0682c&title=" alt="image.png"><br><strong>这是 JDK1.8 默认收集器</strong></p><h2 id="老年代-1"><a href="#老年代-1" class="headerlink" title="老年代"></a>老年代</h2><h3 id="Serial-Old收集器：单线程，标记整理算法"><a href="#Serial-Old收集器：单线程，标记整理算法" class="headerlink" title="Serial Old收集器：单线程，标记整理算法"></a>Serial Old收集器：单线程，标记整理算法</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632429864-a623c075-fe2e-40c3-8ed4-f09c84941d19.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=u3fc3b7df&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=uda15cb43-7ea0-4939-b27b-79c006bbacc&title=" alt="image.png"></p><h3 id="Parallel-Old收集器：多线程，标记整理算法"><a href="#Parallel-Old收集器：多线程，标记整理算法" class="headerlink" title="Parallel Old收集器：多线程，标记整理算法"></a>Parallel Old收集器：多线程，标记整理算法</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632442127-02a1b005-0e75-48b1-97f8-696544f00177.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=u28ac7316&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u873b20f7-d26a-497c-9c7a-9669df7fb71&title=" alt="image.png"></p><h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong><br><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong><br>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632462911-869d143d-c390-4310-a541-ea3cdb9cebff.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=ubcf34b5e&originHeight=259&originWidth=1070&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27060&status=done&style=none&taskId=ucca971d1-af12-4c5d-8a6d-eebad040f40&title=" alt="image.png"><br>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong><br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632495542-8ffb84e3-2063-4feb-8814-4d10007c4fab.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u196f3523&originHeight=262&originWidth=999&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27690&status=done&style=none&taskId=u3fd59542-6ed5-48fa-8f17-62d4d92655b&title=" alt="image.png"><br><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h1 id="JVM实践"><a href="#JVM实践" class="headerlink" title="JVM实践"></a>JVM实践</h1><h2 id="JVM-调优的参数可以在哪里设置参数值？"><a href="#JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="JVM 调优的参数可以在哪里设置参数值？"></a>JVM 调优的参数可以在哪里设置参数值？</h2><h3 id="tomcat的设置vm参数"><a href="#tomcat的设置vm参数" class="headerlink" title="tomcat的设置vm参数"></a>tomcat的设置vm参数</h3><p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件，如下图</p><p><code>JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; </code><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685365312898-eb078aed-6d50-401c-bebd-239052d5ca6a.png#averageHue=%23fbfaf9&clientId=ucd8db9d2-4e00-4&from=paste&height=229&id=u5c273d4d&originHeight=309&originWidth=970&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=102855&status=done&style=none&taskId=u819bf20f-bbb6-4ede-8249-7f58f943609&title=&width=718.5185692764967" alt="image.png"></p><h3 id="jar文件启动"><a href="#jar文件启动" class="headerlink" title="jar文件启动"></a>jar文件启动</h3><p>通常在linux系统下直接加参数启动springboot项目</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</span><br></pre></td></tr></table></figure><blockquote><p>nohup  :  用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行<br>参数 <strong>&amp;</strong>  ：让命令在后台执行，终端退出后命令仍旧执行。</p></blockquote><h2 id="用的JVM调优的参数"><a href="#用的JVM调优的参数" class="headerlink" title="用的JVM调优的参数"></a>用的JVM调优的参数</h2><pre><code>对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</code></pre><p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p><p>1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小</span><br><span class="line"></span><br><span class="line">-Xmx：设置堆的最大大小</span><br></pre></td></tr></table></figure><p>2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p><p>的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3</span><br></pre></td></tr></table></figure><p>3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:newSize   设置年轻代的初始大小</span><br><span class="line">-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</span><br></pre></td></tr></table></figure><p>4）线程堆栈的设置：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xss   对每个线程stack大小的调整,-Xss128k</span><br></pre></td></tr></table></figure><p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小</p><p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p><p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold&#x3D;1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p><p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。</span><br><span class="line"></span><br><span class="line">（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。</span><br></pre></td></tr></table></figure><p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+LargePageSizeInBytes 设置内存页的大小</span><br></pre></td></tr></table></figure><p>10）使用非占用的垃圾收集器。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。</span><br></pre></td></tr></table></figure><h2 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h2><h3 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h3><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685365432677-493fab04-7a4f-46fb-9309-6e0b18340e8e.png#averageHue=%23161412&clientId=ucd8db9d2-4e00-4&from=paste&height=141&id=u6252eaeb&originHeight=191&originWidth=411&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=40794&status=done&style=none&taskId=udc822087-02c3-4fab-863b-abb68e0ef3e&title=&width=304.4444659511754" alt="image.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>查看java进程内<strong>线程的堆栈</strong>信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstack [option] &lt;pid&gt;  </span><br></pre></td></tr></table></figure><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>用于生成堆转存快照</p><blockquote><p>jmap [options] pid  内存映像信息<br>jmap -heap pid   显示Java堆的信息<br>jmap -dump:format&#x3D;b,file&#x3D;heap.hprof pid<br>        format&#x3D;b表示以hprof二进制格式转储Java堆的内存<br>        file&#x3D;用于指定快照dump文件的文件名。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\yuhon&gt;jmap -heap <span class="number">53280</span></span><br><span class="line">Attaching to process ID <span class="number">53280</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.321</span>-b07</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">8</span> thread(s)   <span class="comment">//并行的垃圾回收器</span></span><br><span class="line"></span><br><span class="line">Heap Configuration:  <span class="comment">//堆配置</span></span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span>   <span class="comment">//空闲堆空间的最小百分比</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span>  <span class="comment">//空闲堆空间的最大百分比</span></span><br><span class="line">   MaxHeapSize              = <span class="number">8524922880</span> (<span class="number">8130.</span>0MB) <span class="comment">//堆空间允许的最大值</span></span><br><span class="line">   NewSize                  = <span class="number">178257920</span> (<span class="number">170.</span>0MB) <span class="comment">//新生代堆空间的默认值</span></span><br><span class="line">   MaxNewSize               = <span class="number">2841640960</span> (<span class="number">2710.</span>0MB) <span class="comment">//新生代堆空间允许的最大值</span></span><br><span class="line">   OldSize                  = <span class="number">356515840</span> (<span class="number">340.</span>0MB) <span class="comment">//老年代堆空间的默认值</span></span><br><span class="line">   NewRatio                 = <span class="number">2</span> <span class="comment">//新生代与老年代的堆空间比值，表示新生代：老年代=1：2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span> <span class="comment">//两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB) <span class="comment">//元空间的默认值</span></span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB) <span class="comment">//压缩类使用空间大小</span></span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB <span class="comment">//元空间允许的最大值</span></span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.</span>0MB)<span class="comment">//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</span></span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space: <span class="comment">//Eden使用情况</span></span><br><span class="line">   capacity = <span class="number">134217728</span> (<span class="number">128.</span>0MB)</span><br><span class="line">   used     = <span class="number">10737496</span> (<span class="number">10.</span>240074157714844MB)</span><br><span class="line">   free     = <span class="number">123480232</span> (<span class="number">117.</span>75992584228516MB)</span><br><span class="line">   <span class="number">8.000057935714722</span>% used</span><br><span class="line">From Space: <span class="comment">//Survivor-From 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space: <span class="comment">//Survivor-To 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation  <span class="comment">//老年代 使用情况</span></span><br><span class="line">   capacity = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">3185</span> interned Strings occupying <span class="number">261264</span> bytes.</span><br></pre></td></tr></table></figure><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。<br><strong>常见参数</strong>：<br>①总结垃圾回收统计</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstat -gcutil pid</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存1区当前使用比例</td></tr><tr><td>S1</td><td>幸存2区当前使用比例</td></tr><tr><td>E</td><td>伊甸园区使用比例</td></tr><tr><td>O</td><td>老年代使用比例</td></tr><tr><td>M</td><td>元数据区使用比例</td></tr><tr><td>CCS</td><td>压缩使用比例</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table><p>②垃圾回收统计</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstat -gc pid</span><br></pre></td></tr></table></figure><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><h5 id="VisualVM：故障处理工具"><a href="#VisualVM：故障处理工具" class="headerlink" title="VisualVM：故障处理工具"></a>VisualVM：故障处理工具</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/posts/5ea3.html"/>
      <url>/posts/5ea3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://juejin.cn/post/6844903919781412877">https://juejin.cn/post/6844903919781412877</a></p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li><code>并行</code>：指两个以上事件在<code>同一时刻</code>发生</li><li><code>并发</code>：指两个以上事件在<code>同一个时间段内</code>发生</li></ul><h1 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h1><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口⭐"><a href="#实现Runnable接口⭐" class="headerlink" title="实现Runnable接口⭐"></a>实现Runnable接口⭐</h3><p>将<code>线程</code>和<code>任务</code>分开</p><ul><li>Thread代表线程</li><li>Runnabl代表可运行的任务（线程要执行的代码） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>例如<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>java8以后可以使用·lambda精简代码·<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></li></ul><h3 id="FutureTask配合Thread（了解）"><a href="#FutureTask配合Thread（了解）" class="headerlink" title="FutureTask配合Thread（了解）"></a>FutureTask配合Thread（了解）</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><h3 id="继承方式和实现方式的区别"><a href="#继承方式和实现方式的区别" class="headerlink" title="继承方式和实现方式的区别"></a>继承方式和实现方式的区别</h3><p>区别：</p><ul><li>继承Thread类：线程代码存放在Thread子类的run（）方法中</li><li>实现Runnable接口：线程代码存放在接口的子类的run（）方法中</li></ul><p>实现方法的好处：</p><ul><li>避免了单继承的局限性</li><li>多个线程可以共享同一个接口实现类对象，非常适合多个相同线程来处理同一份资源</li></ul><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;Thread-&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> factory.newThread(runnable);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> factory.newThread(runnable);</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure><h3 id="Executor线程池-最推荐）"><a href="#Executor线程池-最推荐）" class="headerlink" title="Executor线程池(最推荐）"></a>Executor线程池(最推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread with Runnable started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">executor.execute(runnable);</span><br><span class="line">executor.execute(runnable);</span><br><span class="line">executor.execute(runnable);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="设置线程名称"><a href="#设置线程名称" class="headerlink" title="设置线程名称"></a>设置线程名称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(String name)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target, String name)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure><h3 id="获取当前线程"><a href="#获取当前线程" class="headerlink" title="获取当前线程"></a>获取当前线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="获取线程的名称"><a href="#获取线程的名称" class="headerlink" title="获取线程的名称"></a>获取线程的名称</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul><li><p>设置线程的优先级</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setPriority(<span class="type">int</span> newPriority)</span><br></pre></td></tr></table></figure></li><li><p>获取线程的优先级</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getPriority()</span><br></pre></td></tr></table></figure><blockquote><p>其中 setPriority 方法需要一个整数，并且范围在 [1,10] 之间，通常推荐设置 Thread 类的三个优先级常量：<br>public final static int MIN_PRIORITY &#x3D; 1;<br>public final static int NORM_PRIORITY &#x3D; 5;<br>public final static int MAX_PRIORITY &#x3D; 10;</p></blockquote></li></ul><p><strong>注意</strong></p><ul><li>线程创建时继承的是父线程的优先级</li><li>优先级低只是获得调度的概率低，并非一定是在高优先级线程之后才会被调用</li></ul><h3 id="插入线程（了解）"><a href="#插入线程（了解）" class="headerlink" title="插入线程（了解）"></a>插入线程（了解）</h3><p>在Java中，<code>join</code> 方法是<code>Thread</code>类提供的一个方法，用于等待一个线程结束。当一个线程调用另一个线程的 <code>join</code> 方法时，当前线程会被阻塞，直到另一个线程执行完毕，或者等待指定的时间结束。<br><code>join</code> 方法有两种重载形式：</p><ul><li><code>join()</code>：等待该线程执行完成。</li><li><code>join(long millis)</code> 或 <code>join(long millis, int nanos)</code>：等待该线程指定的时间内执行完成。</li></ul><p>例如，下面的代码示例展示了如何使用 <code>join</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">    // 线程 t1 执行的代码</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">    // 线程 t2 执行的代码</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    t1.join(); // 等待 t1 线程执行完成</span><br><span class="line">    t2.join(1000); // 等待 t2 线程执行 1 秒钟</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    // 处理InterruptedException异常</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主线程继续执行</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们创建了两个线程 <code>t1</code> 和 <code>t2</code>，并分别启动它们。然后，我们在主线程中调用了 <code>t1.join()</code> 和 <code>t2.join(1000)</code> 方法，分别等待 <code>t1</code> 线程和 <code>t2</code> 线程执行完成。如果等待时间超时，那么当前线程会继续执行。<br><code>join</code> 方法的作用是让多个线程之间协调工作，等待其他线程完成后再继续执行。这种协作方式可以有效地避免多线程并发执行带来的竞态条件和数据不一致的问题。但是需要注意的是，如果一个线程的 <code>join</code> 方法被调用过多次，那么就会抛出 <code>InterruptedException</code> 异常。因此，需要在异常处理中处理这种情况。<br><code>join</code> 方法主要用于协调多个线程之间的执行顺序，通常用于以下场景：</p><ol><li>等待其他线程完成后再继续执行：在多线程程序中，如果一个线程依赖于另一个线程的执行结果，那么可以使用 <code>join</code> 方法等待其他线程完成后再继续执行。例如，在主线程中启动了多个子线程，需要等待所有子线程执行完成后再进行下一步操作，可以在主线程中使用 <code>join</code> 方法等待所有子线程执行完成。 </li><li>控制多个线程的执行顺序：在多线程程序中，有时需要控制多个线程的执行顺序，例如按照某个规定的顺序依次执行多个任务。可以通过在每个线程中调用其他线程的 <code>join</code> 方法来实现控制执行顺序的目的。 </li><li>等待资源的释放：在多线程程序中，如果多个线程需要访问共享资源，可能会出现竞态条件和数据不一致的问题。可以使用 <code>join</code> 方法等待其他线程释放资源后再进行操作，从而避免竞态条件和数据不一致的问题。</li></ol><p>需要注意的是，<code>join</code> 方法可能会导致线程的阻塞，因此在使用时需要根据具体的场景进行灵活的设计和调整。同时，如果使用不当， <code>join</code> 方法可能会导致死锁或线程饥饿等问题，因此需要谨慎使用。</p><h3 id="线程礼让（了解）"><a href="#线程礼让（了解）" class="headerlink" title="线程礼让（了解）"></a>线程礼让（了解）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">yield</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>暂停当前正在执行的线程，把执行机会让给优先级相同或者更高的线程</li><li>若队列中没有同优先级的线程，忽略此方法</li></ul><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ul><li>调用sleep会让当前线程从Running进入Timed Waiting转态（阻塞）</li><li>其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException </li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全的原因"><a href="#线程安全的原因" class="headerlink" title="线程安全的原因"></a>线程安全的原因</h2><p>多线程环境下操作同一资源（成员变量）</p><h2 id="线程安全的解决方法"><a href="#线程安全的解决方法" class="headerlink" title="线程安全的解决方法"></a>线程安全的解决方法</h2><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行</p><h3 id="旧的版本"><a href="#旧的版本" class="headerlink" title="旧的版本"></a>旧的版本</h3><p><code>同步机制</code></p><ul><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁对象)&#123; </span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁对象必须是唯一的</p></blockquote></li><li><p>同步方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">权限修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特点：</p><ul><li>同步方法是锁住方法里面所有的代码</li><li>锁对象不能自己指定<ul><li>非静态：this</li><li>静态：当前类的字节码文件对象</li></ul></li></ul></blockquote></li><li><p>示例：同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;出售第&quot;</span> + <span class="built_in">this</span>.tickets-- + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例：同步方法、</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;出售第&quot;</span> + <span class="built_in">this</span>.tickets-- + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>synchronized 的锁是什么？ </p><ul><li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。</li><li>同步方法的锁：静态方法（ 类名.class ）、非静态方法（ this ）。</li><li>同步代码块：自己指定，很多时候也是指定为 this 或 类名.class 。<br>注意事项：<br>必须确保使用同一个资源的 多个线程共用一把锁 ，这个非常重要，否则就无法保证共享资源的安全。<br>一个线程类中的所有静态方法共用同一把锁（ 类名.class ），所有非静态方 法共用同一把锁（ this ），同步代码块（指定需谨慎）。</li></ul><h3 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h3><ul><li>从 JDK 5.0 开始，Java 提供了更强大的线程同步机制——通过显式定义同 步锁对象来实现同步</li><li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Loc k对象加锁，线程开始访问共享资源之前应先获得 Lock 对象。 </li><li><code>ReentrantLock</code> 类实现了 <code>Lock</code> ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock ，可以显式加锁、释放锁</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁： </p><ul><li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</li><li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。</li></ul><p>解决方法：</p><ul><li>专门的算法、原则。</li><li>尽量减少同步资源的定义。</li><li>尽量避免嵌套同步。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;线程A&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程A获取A锁，等待B锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A获取B锁&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;...线程A结束&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;线程B&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B获取B锁，等待A锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程B获取A锁&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;...线程B结束&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679708229503-70f4b5f5-e958-4998-83cd-bed2ae440eb8.png#averageHue=%23fbf9f7&clientId=u1c75dec8-961c-4&from=paste&height=346&id=u28797d69&originHeight=519&originWidth=384&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=47746&status=done&style=none&taskId=u95bc8cd5-ada1-4388-baa7-517c08b42a9&title=&width=256" alt="image.png"></li></ul><h3 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h3><ul><li>Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码锁和方法锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（体统更多子类）</li></ul><h2 id="ReentrantLock⭐"><a href="#ReentrantLock⭐" class="headerlink" title="ReentrantLock⭐"></a>ReentrantLock⭐</h2><p><code>ReentrantLock</code> 是 Java 提供的一种<strong>可重入</strong>的互斥锁，它与 <code>synchronized</code> 相比，具有更高的灵活性和扩展性。<code>ReentrantLock</code> 提供了以下特性：</p><ol><li>可重入：同一个线程可以对一个 <code>ReentrantLock</code> 对象多次加锁而不会发生死锁。</li><li>公平性：可以选择指定公平锁或非公平锁。公平锁能够保证线程获得锁的顺序与线程等待的顺序一致，而非公平锁则允许插队，可能会导致某些线程一直无法获得锁。</li><li>中断响应：支持线程中断，即当一个线程在等待锁的过程中，可以通过中断响应来退出等待。</li><li>条件变量支持：可以通过 <code>ReentrantLock</code> 创建一个或多个 <code>Condition</code> 对象，使线程能够在条件变量满足时等待或唤醒。</li></ol><p>下面是一个使用 <code>ReentrantLock</code> 的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Calculation &#123;</span><br><span class="line">    private static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int n = 10000000;</span><br><span class="line">        int[] nums = new int[n];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int finalSum = sum;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for (int i = 0; i &lt; n / 2; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                finalSum += sum;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for (int i = n / 2; i &lt; n; i++) &#123;</span><br><span class="line">                    sum += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                finalSum += sum;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;计算结果：&quot; + finalSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个 <code>ReentrantLock</code> 对象 <code>lock</code>。然后在两个子线程中分别使用 <code>lock</code> 对象来保证对共享变量 <code>finalSum</code> 的互斥访问。具体来说，在每个子线程中，我们首先调用 <code>lock</code> 方法获取锁，然后在 <code>try-finally</code> 代码块中执行计算任务，并在 <code>finally</code> 块中调用 <code>unlock</code> 方法释放锁，以确保在任何情况下都能释放锁。</p><p>需要注意的是，如果在加锁之后发生异常，必须在 <code>finally</code> 块中释放锁，否则会导致死锁。此外，如果没有正确释放锁，可能会导致其他线程无法获取锁而一直等待，从而出现死锁等问题。因此，在使用 <code>ReentrantLock</code> 时应该特别注意锁的释放。<br><code>ReentrantLock</code> 提供了许多方法，包括：</p><ol><li><code>lock()</code>：获取锁，如果锁已经被其他线程持有，则当前线程会被<strong>阻塞</strong>，直到获取到锁。</li><li>lockInterruptibly()：获取锁，如果锁已经被其他线程持有，则当前线程会被阻塞，直到获取到锁或者<strong>当前线程被中断</strong>。</li><li><code>unlock()</code>：释放锁。</li><li><code>tryLock()</code>：尝试获取锁，如果锁没有被其他线程持有，则获取锁并返回 <code>true</code>，否则立即返回 <code>false</code>，不会阻塞当前线程。</li><li><code>tryLock(long timeout, TimeUnit unit)</code>：尝试在指定的时间内获取锁，如果在超时时间内没有获取到锁，则返回 <code>false</code>，否则返回 <code>true</code>。</li><li><code>newCondition()</code>：创建一个与该锁绑定的条件变量，用于在某个条件满足时等待或唤醒线程。</li><li><code>getHoldCount()</code>：返回当前线程持有该锁的次数。</li><li><code>isHeldByCurrentThread()</code>：判断当前线程是否持有该锁。</li><li><code>isLocked()</code>：判断锁是否被任何线程持有。</li><li><code>getQueueLength()</code>：返回等待获取该锁的线程数的估计值。</li><li><code>hasQueuedThreads()</code>：判断是否有线程正在等待获取该锁。</li></ol><p>这些方法可以帮助我们更加灵活地使用 <code>ReentrantLock</code>，实现更加高效和安全的多线程编程。需要注意的是，使用锁操作时一定要注意锁的粒度和锁的释放，避免出现死锁等问题。</p><h3 id="synchronized与ReentrantLock的异同点"><a href="#synchronized与ReentrantLock的异同点" class="headerlink" title="synchronized与ReentrantLock的异同点"></a>synchronized与ReentrantLock的异同点</h3><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中用于实现线程同步的机制，它们的主要异同点如下：<br>共同点：</p><ol><li>都用于控制多线程对共享对象的访问</li><li>都是可重入锁</li><li>都保证了可见性和互斥性</li></ol><p>不同点：</p><ol><li>实现方式不同：<code>synchronized</code> 是 JVM 内置的关键字，通过对象锁来实现线程同步；而 <code>ReentrantLock</code> 是第三方库 <code>java.util.concurrent</code> 中的一个类，通过显式地获取和释放锁来实现线程同步。 </li><li>可重入性不同：<code>synchronized</code> 是可重入的，即同一个线程可以多次获得同一个对象的锁；而 <code>ReentrantLock</code> 也是可重入的，但需要注意的是，如果在同一个方法中获取了该锁并再次调用该方法，则会自动解锁上一次获取的锁，因此需要手动释放锁。 </li><li>性能差异：<code>synchronized</code> 是轻量级的锁，开销较小，适用于低并发量的场景；而 <code>ReentrantLock</code> 是重量级的锁，开销较大，适用于高并发量的场景。 </li><li>功能扩展性不同：<code>ReentrantLock</code> 支持公平锁、非公平锁、定时锁等多种锁类型，还可以通过 Condition 接口实现等待&#x2F;通知机制，提供了更加灵活的控制能力；而 <code>synchronized</code> 则相对简单，只支持可重入锁。 </li><li>代码风格不同：<code>synchronized</code> 直接使用对象作为锁，代码简洁易读；而 <code>ReentrantLock</code> 需要手动获取和释放锁，需要编写更多的代码。</li></ol><p>综上所述，<code>synchronized</code> 适用于低并发量的场景，代码简单易读；而 <code>ReentrantLock</code> 则适用于高并发量的场景，提供更加灵活的控制能力。</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>虽然通常每个子线程只需要完成自己的任务，但是有时我们希望多个线程一起工作来完成一个任务，这就涉及到线程间通信。</p><h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><ul><li>等待唤醒机制是多线程的一种<code>协作</code>机制</li><li>等待唤醒机制就是在一个线程不满足某个条件时，就进入等待转态<code>wait()</code>,等待其它线程执行完它们的代码之后再将其唤醒<code>notify</code>或者可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果有需要，可以使用<code>notifyAll</code>来唤醒所有的等待线程，<code>wait/notify</code>就是线程间的一种协作机制<ul><li>wait（）：另线程挂起并放弃cpu、同步资源并等待，而当前线程排队等待其它线程调用<code>notify/notifyAll</code>方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行</li><li>notify:唤醒正在排队等待同步资源的线程中<strong>优先级最高者</strong>结束等待</li><li>notifyAll：唤醒正在排队等待资源的<strong>所有</strong>线程结束等待<blockquote><p>注意：</p><ul><li>被通知线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步代码块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁，成功之后才能在当初调用wait方法之后的地方恢复执行</li><li>如果能获取锁，线程就从WAITING 状态变成 RUNNABLE（可运行） 状态；否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li></ul></blockquote></li></ul></li></ul><h2 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h2><p>隐含的问题：</p><ol><li>线程安全问题：生产者和消费者共享数据缓冲区（可以使用同步解决）</li><li>线程的协调工作问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 缓冲区大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 缓冲区锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">bufferNotEmpty</span> <span class="operator">=</span> lock.newCondition();  <span class="comment">// 缓冲区非空条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">bufferNotFull</span> <span class="operator">=</span> lock.newCondition();  <span class="comment">// 缓冲区未满条件变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(), <span class="string">&quot;Producer 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(), <span class="string">&quot;Producer 2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(), <span class="string">&quot;Consumer 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(), <span class="string">&quot;Consumer 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (buffer.size() == BUFFER_SIZE) &#123;  <span class="comment">// 缓冲区已满，等待消费者消费</span></span><br><span class="line">                        bufferNotFull.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> produceItem();</span><br><span class="line">                    buffer.offer(item);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;[%s] Produced item %d, buffer size = %d%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(), item, buffer.size());</span><br><span class="line">                    bufferNotEmpty.signalAll();  <span class="comment">// 唤醒等待的消费者</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">produceItem</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 生成一个随机整数作为生产的物品</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (buffer.isEmpty()) &#123;  <span class="comment">// 缓冲区为空，等待生产者生产</span></span><br><span class="line">                        bufferNotEmpty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> buffer.poll();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;[%s] Consumed item %d, buffer size = %d%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(), item, buffer.size());</span><br><span class="line">                    bufferNotFull.signalAll();  <span class="comment">// 唤醒等待的生产者</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    buffer.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="sleep和wait方法的区别"><a href="#sleep和wait方法的区别" class="headerlink" title="sleep和wait方法的区别"></a>sleep和wait方法的区别</h2><ol><li>sleep不释放锁，wait释放锁</li><li>sleep指定休眠时间，wait可以指定时间也可以无限等待直到<code>notify</code>或<code>notifyAll</code></li><li>sleep在<strong>Thread类</strong>中声明的静态方法，wait在<strong>Object</strong>类中声明</li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><ol><li>创建一个空池子</li><li>提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可</li><li>但是如果在提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li>创建线程池</li><li>提交任务</li><li>所有的任务全部执行完毕，关闭线程池（实际开发中并不需要关闭，服务器时24小时运行）</li></ol><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p><code>Executors</code>:线程池的工具类通过调用方法返回不同类型的线程池对象<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681870944310-5acf92a7-eaab-4b72-bb45-14537249bccb.png#averageHue=%23d8b6b1&clientId=u1c9ab09a-5537-4&from=paste&height=105&id=u4dadf50d&originHeight=158&originWidth=1279&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=102641&status=done&style=none&taskId=u1e1e5c23-1dad-429d-ab06-d4dbd121dc3&title=&width=852.6666666666666" alt="image.png"><br>第一种并发没有上限，是Inter类型的最大值，还没到最大值，程序就会报错</p><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool.submit(task);</span><br></pre></td></tr></table></figure><h2 id="创建自己的线程池对象"><a href="#创建自己的线程池对象" class="headerlink" title="创建自己的线程池对象"></a>创建自己的线程池对象</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871350548-ef5e207b-a1dc-49a0-bfea-f34d557ab8d4.png#averageHue=%23f1efef&clientId=u1c9ab09a-5537-4&from=paste&height=447&id=u58ae749b&originHeight=671&originWidth=1747&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=321587&status=done&style=none&taskId=u35751981-8bbb-4565-803c-01629d7e533&title=&width=1164.6666666666667" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871563483-fd9ca18a-b42e-4779-90d7-91e359217417.png#averageHue=%23f7f7ee&clientId=u1c9ab09a-5537-4&from=paste&height=288&id=ud5207367&originHeight=432&originWidth=1111&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=297688&status=done&style=none&taskId=u5aff1da6-6c13-4501-bd9a-1f7e999a78e&title=&width=740.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871668535-83d8df23-2d16-4609-9e60-e1e22cea740c.png#averageHue=%23f6f4e6&clientId=u1c9ab09a-5537-4&from=paste&height=214&id=uca8a5dec&originHeight=321&originWidth=983&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=273746&status=done&style=none&taskId=uc6f5e056-1b74-41c6-8522-180f93c345e&title=&width=655.3333333333334" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681871497101-faa98790-58e5-4701-be24-3ca3bff2a5ca.png#averageHue=%23e6d4d2&clientId=u1c9ab09a-5537-4&from=paste&height=441&id=u9c1a2b05&originHeight=662&originWidth=2105&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=439782&status=done&style=none&taskId=ue245e4cc-ee28-4dde-b6ca-6469a3dfcd4&title=&width=1403.3333333333333" alt="image.png"></p><h3 id="查看可用处理器数目（最大并行数）"><a href="#查看可用处理器数目（最大并行数）" class="headerlink" title="查看可用处理器数目（最大并行数）"></a>查看可用处理器数目（最大并行数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure><h3 id="线程池多大合适？"><a href="#线程池多大合适？" class="headerlink" title="线程池多大合适？"></a>线程池多大合适？</h3><ul><li>CPU密集型运算：最大并行数+1</li><li>I&#x2F;O密集型运算（读取文件、数据库）：<img src="https://cdn.nlark.com/yuque/__latex/9b8980040e79b72511d5d9559f6d29bd.svg#card=math&code=%E6%9C%80%E5%A4%A7%E5%B9%B6%E8%A1%8C%E6%95%B0%20%2A%20%E6%9C%9F%E6%9C%9BCPU%E5%88%A9%E7%94%A8%E7%8E%87%20%2A%20%5Cfrac%7B%E6%80%BB%E6%97%B6%E9%97%B4%28CPU%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%2B%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%29%7D%7BCPU%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%7D%0A&id=CdyHr"></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681872353293-8cd9cd32-3765-4607-a1df-c571eab51c53.png#averageHue=%23fcf7f4&clientId=u1c9ab09a-5537-4&from=paste&height=245&id=ue299c14d&originHeight=367&originWidth=1836&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=199105&status=done&style=none&taskId=u28deaa81-4db3-4986-b182-1ada3da8c06&title=&width=1224" alt="image.png"></p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679706512475-c00a3ecc-ddf8-49b4-a254-2d05774d8df6.png#averageHue=%23f5e0de&clientId=u1c75dec8-961c-4&from=paste&height=278&id=u088e7159&originHeight=417&originWidth=1228&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=208087&status=done&style=none&taskId=u1fa0c57d-016d-4555-b1df-299771e4654&title=&width=818.6666666666666" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683633428068-3e129e6c-7d09-4cd4-a7b6-dcbed6eaf45c.png#averageHue=%23fafaf9&clientId=u8ead2036-f886-4&from=paste&height=407&id=u361703ad&originHeight=550&originWidth=1375&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=44023&status=done&style=none&taskId=ua5e769c9-22b6-44e7-a104-c74436c0f3b&title=&width=1018.5185904692607" alt="image.png"><br>Java中的线程生命周期可以分为以下6个状态：</p><ol><li>新建状态（New）：当一个Thread类或者其子类的实例被创建时，该线程就处于新建状态。此时，线程并没有开始运行，只是给线程分配了必要的资源。 </li><li>就绪状态（Runnable）：当线程处于就绪状态时，表示线程已经准备好了运行，只是还没有得到CPU的执行权。此时，线程处于等待CPU的状态。 </li><li>运行状态（Running）：当线程获得CPU的执行权时，进入运行状态。此时，线程真正开始运行，执行自己的任务。 </li><li>阻塞状态（Blocked）：当线程被阻塞时，表示线程暂时停止了执行。线程进入阻塞状态有多种原因，如等待某个资源（比如输入输出、网络连接等），或者等待另一个线程的操作完成等。 阻塞状态分为以下三种</li><li>等待阻塞：在运行状态的线程调用o.wait方法时，JVM会把该线程放入等待队列（Waitting Queue）中，线程转为阻塞状态</li><li>同步阻塞：在运行的线程尝试获取正在被其它线程占用的对象同步锁时，JVM会把该线程放入锁池（Lock Pool）中，线程转为阻塞状态</li><li>其它阻塞：运行状态的线程在执行sleep、join或者发出I&#x2F;O请求时，线程变为阻塞状态。直到sleep状态超时、join等待线程终止或者超时，I&#x2F;O处理完毕，线程才重新转为可运行状态。</li><li>等待状态（Waiting）：当线程进入等待状态时，表示线程暂时停止了执行，但是并没有被阻塞。线程进入等待状态有多种原因，比如调用了wait()、join()或者park()等方法。 </li><li>终止状态（Terminated）：当线程执行完自己的任务后，进入终止状态。此时，线程释放了占用的资源，线程对象也被销毁。</li></ol><p>需要注意的是，线程的状态不是线性的，线程可以在各个状态之间切换，当线程被唤醒时，它会从等待状态转换为就绪状态，等待CPU的调度再次执行。</p><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code> 是 Java 中的一个关键字，用来修饰变量，表示该变量是“<strong>易变的</strong>”，也就是可能被<strong>多个线程同时访问和修改</strong>。在多线程编程中，使用 <code>volatile</code> 可以保证变量的<strong>可见性</strong>和<strong>一致性</strong>，从而避免出现线程安全问题。<br>具体来说，<code>volatile</code> 主要有以下两个作用：</p><ol><li>变量的可见性：当一个变量被声明为 <code>volatile</code> 时，任何对该变量的修改都会立即被其他线程所看到，即使这些线程没有显式地进行同步操作。这是因为 JVM 会保证 <code>volatile</code> 变量的读写操作都是原子的，并且会在修改后立即刷新到主内存中，以便其他线程可以及时读取到最新的值。 </li><li>变量的禁止重排序：在多线程环境下，为了提高执行效率，JVM 可能会对指令进行重排序。但是，这种重排序可能会导致某些线程看到的变量值不一致。如果一个变量被声明为 <code>volatile</code>，那么 JVM 就会禁止对该变量进行重排序，从而保证变量的值不会出现意外的变化。</li></ol><p>需要注意的是，<code>volatile</code> 变量并不能完全替代锁（synchronized）来保证线程安全。虽然 <code>volatile</code> 可以保证变量的可见性和一致性，但是它并不能保证复合操作的原子性，也不能保证线程之间的互斥访问。如果需要进行复杂的状态转换或者涉及到多个变量的操作，还是需要使用锁来保证线程安全。<br>另外，需要注意的是，<code>volatile</code> 变量对于基本类型（如 <code>int</code>、<code>long</code> 等）和引用类型（如 <code>Object</code>、<code>String</code> 等）有不同的语义。对于基本类型，<code>volatile</code> 变量保证原子性和可见性；对于引用类型，<code>volatile</code> 变量只保证可见性，而不保证引用对象的状态的一致性，这时需要使用锁来保证线程安全。<br>下面是一个使用 <code>volatile</code> 关键字的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Counter</code> 类，其中包含一个 <code>count</code> 变量，用来记录计数器的值。由于 <code>count</code> 可能被多个线程同时访问和修改，因此我们将其声明为 <code>volatile</code> 变量，以保证其可见性和一致性。<br>在 <code>increment()</code> 方法中，我们对 <code>count</code> 变量进行了简单的自增操作。由于自增操作不是原子性的，可能会被多个线程同时执行，因此我们需要使用 <code>volatile</code> 关键字来保证对 <code>count</code> 变量的修改是原子性的，并且能够被其他线程及时看到。<br>在 <code>getCount()</code> 方法中，我们返回了 <code>count</code> 变量的值，由于 <code>count</code> 是 <code>volatile</code> 变量，因此我们可以保证返回的值是最新的，即使在多线程环境下。<br>需要注意的是，尽管 <code>volatile</code> 变量可以保证可见性和一致性，但是在多线程环境下，如果需要对 <code>count</code> 变量进行复合操作，例如加锁或者判断后再修改，仍然需要使用锁来保证线程安全。<br>下面是一个不需要使用 <code>volatile</code> 关键字的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Singleton</code> 类，其中包含一个私有的构造方法和一个静态的 <code>getInstance()</code> 方法，用来获取 <code>Singleton</code> 类的唯一实例。为了保证 <code>Singleton</code> 类的唯一性，我们使用了双重检查锁（Double-Checked Locking）的方式来实现懒汉式单例模式。</p><p>在 <code>getInstance()</code> 方法中，我们首先检查 <code>instance</code> 变量是否为 <code>null</code>，如果为 <code>null</code>，则使用 <code>synchronized</code> 关键字锁定 <code>Singleton.class</code> 对象，再次检查 <code>instance</code> 是否为 <code>null</code>，如果仍然为 <code>null</code>，则创建一个新的 <code>Singleton</code> 实例，并赋值给 <code>instance</code> 变量。由于使用了双重检查锁的方式，可以保证在多线程环境下，只有一个线程可以创建 <code>Singleton</code> 实例，并且其他线程可以获取到已创建的实例。</p><p>需要注意的是，在这个例子中，我们并没有使用 <code>volatile</code> 关键字来修饰 <code>instance</code> 变量。这是因为使用了双重检查锁的方式，可以保证在多线程环境下，对 <code>instance</code> 变量的读写操作是同步的，并且能够保证可见性和一致性，因此不需要使用 <code>volatile</code> 关键字来修饰 <code>instance</code> 变量。</p><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性（Atomicity）是指一个操作是不可中断的整体，<strong>要么全部完成，要么全部不完成</strong>，不会出现执行一半的情况。在多线程环境下，原子性是保证线程安全的重要因素之一。<br><code>++i</code> 和 <code>i++</code> 操作不是原子性的，因为它们实际上包含了两个操作：读取变量的值和修改变量的值。在多线程环境下，如果多个线程同时对同一个变量进行 <code>++i</code> 或 <code>i++</code> 操作，就可能出现竞争条件，导致结果不一致。</p><p>例如，假设初始时变量 <code>i</code> 的值为 0，现在有两个线程 <code>A</code> 和 <code>B</code> 同时对 <code>i</code> 进行 <code>++i</code> 操作，那么可能会出现以下情况：</p><ol><li>线程 <code>A</code> 读取 <code>i</code> 的值为 0。</li><li>线程 <code>B</code> 读取 <code>i</code> 的值为 0。</li><li>线程 <code>A</code> 将 <code>i</code> 的值加 1，得到 1。</li><li>线程 <code>B</code> 将 <code>i</code> 的值加 1，得到 1。</li></ol><p>最终，变量 <code>i</code> 的值只增加了 1，而不是 2。这就是因为 <code>++i</code> 和 <code>i++</code> 操作不是原子性的，多个线程对同一个变量进行操作时，可能会相互干扰，导致结果不一致。</p><p>为了保证 <code>++i</code> 和 <code>i++</code> 操作的原子性，可以使用 <code>AtomicInteger</code> 类或者锁来保证线程安全。例如，可以将变量 <code>i</code> 声明为 <code>AtomicInteger</code> 类型，或者使用 <code>synchronized</code> 关键字保证对变量的操作是同步的。</p><p>Java 中提供了一些原子性操作的类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code> 等，它们提供了一些基本的原子性操作，如增加、减少、比较等，能够保证这些操作的原子性。</p><p>下面是一个使用 <code>AtomicInteger</code> 类的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Counter</code> 类，其中包含一个 <code>count</code> 变量，类型为 <code>AtomicInteger</code>。由于 <code>AtomicInteger</code> 类提供了原子性操作，因此我们可以保证对 <code>count</code> 变量的增加操作是原子性的，并且不会出现线程安全问题。</p><p>在 <code>increment()</code> 方法中，我们调用了 <code>count.incrementAndGet()</code> 方法，该方法能够原子性地将 <code>count</code> 变量的值增加 1，并返回增加后的值。</p><p>在 <code>getCount()</code> 方法中，我们调用了 <code>count.get()</code> 方法，该方法能够原子性地返回 <code>count</code> 变量的当前值，即使在多线程环境下，我们也可以保证返回的值是最新的。</p><p>需要注意的是，尽管使用了 <code>AtomicInteger</code> 类，仍然需要注意线程安全问题，例如如果需要对 <code>count</code> 变量进行复合操作，例如判断后再修改，仍然需要使用锁来保证线程安全。</p><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><p>Java 提供了许多并发工具类，可以帮助开发者更方便地实现多线程编程，这些工具类包括：</p><ol><li><code>java.util.concurrent.locks</code>：提供了一组锁和同步器的实现，例如 <code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等。 </li><li><code>java.util.concurrent.atomic</code>：提供了一组原子性操作的类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code> 等。 </li><li><code>java.util.concurrent</code>：提供了一些并发集合类，例如 <code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>、<code>CopyOnWriteArrayList</code> 等。 </li><li><code>java.util.concurrent.Executor</code>：提供了一组执行任务的框架，例如 <code>ExecutorService</code>、<code>ScheduledExecutorService</code> 等。 </li><li><code>java.util.concurrent.Future</code>：提供了一组表示异步计算结果的接口，例如 <code>Future</code>、<code>CompletableFuture</code> 等。 </li><li><code>java.util.concurrent.atomic</code>：提供了一组原子性操作的类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code> 等。</li></ol><p>使用这些并发工具类，可以方便地实现多线程编程，提高程序的并发性能和可靠性。但是在使用这些工具类时，需要注意线程安全问题，避免出现竞争条件、死锁等问题。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code> 是 Java 中的一个并发工具类，用来控制并发访问的数量。它可以用来限制同时访问某个资源的线程数量，或者限制同时执行某个操作的线程数量。<br><code>Semaphore</code> 可以被看做是一个<strong>计数器</strong>，初始值为给定的数量，每当一个线程访问这个资源，计数器就减 1，当计数器为 0 时，所有试图访问这个资源的线程都将被阻塞，直到计数器再次变为正数。<br><code>Semaphore</code> 主要有两个常用的方法：</p><ul><li><code>acquire()</code>：获取一个许可，如果当前没有许可可用，则阻塞。 </li><li><code>release()</code>：释放一个许可，增加计数器的值。</li></ul><p>下面是一个使用 <code>Semaphore</code> 的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintQueue</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">// 执行打印操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>PrintQueue</code> 类，其中包含一个 <code>semaphore</code> 变量，类型为 <code>Semaphore</code>。在 <code>PrintQueue</code> 类的构造函数中，我们传入一个整数值，表示可以同时打印的线程数量。<br>在 <code>print()</code> 方法中，我们首先调用了 <code>semaphore.acquire()</code> 方法获取一个许可，如果当前没有许可可用，则阻塞。然后执行打印操作，最后调用 <code>semaphore.release()</code> 方法释放一个许可，增加计数器的值。<br>这样，我们就可以通过 <code>Semaphore</code> 来控制同时打印的线程数量，避免线程过多导致系统资源的浪费，从而提高程序的并发性能和可靠性。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code> 是 Java 中的一个并发工具类，用于控制多个线程之间的同步。它的作用是<strong>让某一个线程等待其他线程执行完毕之后再执行</strong>。<br><code>CountDownLatch</code> 主要有两个常用的方法：</p><ul><li><code>await()</code>：等待计数器变为 0，如果计数器不为 0，则阻塞等待。 </li><li><code>countDown()</code>：计数器减 1，如果计数器减为 0，则释放所有等待的线程。</li></ul><p>当一个任务需要等待多个线程完成后才能执行，可以使用 <code>CountDownLatch</code> 实现线程之间的协作，例如下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(numThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(latch));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;All threads have finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟执行任务</span></span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; finished.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 计数器减 1</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了 5 个线程，并将它们的任务委托给 <code>Worker</code> 类。在 <code>Worker</code> 类的构造函数中，我们传入了一个 <code>CountDownLatch</code> 对象，它的计数器被初始化为 5。<br>在 <code>run()</code> 方法中，我们模拟了执行任务的过程，并在最后调用了 <code>latch.countDown()</code> 方法减少计数器的值。<br>在 <code>main</code> 函数中，我们创建了一个 <code>CountDownLatch</code> 对象，计数器被初始化为 5。然后创建了 5 个 <code>Worker</code> 线程，并启动这些线程。最后调用 <code>latch.await()</code> 方法等待所有线程执行完毕。<br>当所有线程的任务都完成后，<code>CountDownLatch</code> 对象的计数器会变为 0，<code>await()</code> 方法会返回，然后程序会输出 “All threads have finished.”。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code> 是 Java 中一个线程安全的哈希表实现，它可以在高并发环境下提供更好的性能和可伸缩性。</p><p>与 <code>Hashtable</code> 不同，<code>ConcurrentHashMap</code> 使用了<strong>分段锁机制</strong>，即将整个哈希表分成多个小的哈希表段，每个段都有一个独立的锁。这样，在多线程环境下，不同线程可以同时对不同的段进行读写操作，从而提高了并发性能。</p><p>此外，<code>ConcurrentHashMap</code> 也支持并发的读操作，即多个线程可以同时读取表中的元素而不需要互斥锁的保护。这是通过使用 <code>volatile</code> 关键字和一些特殊的算法实现的。</p><p>下面是一个使用 <code>ConcurrentHashMap</code> 的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 10 个线程，每个线程对表中一个键进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span> + num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> num;</span><br><span class="line">                map.put(key, value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put &quot;</span> + key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get &quot;</span> + key + <span class="string">&quot;: &quot;</span> + map.get(key));</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个 <code>ConcurrentHashMap</code> 对象，并创建了 10 个线程。每个线程对表中一个键进行操作，包括插入键值对和获取键对应的值。由于 <code>ConcurrentHashMap</code> 是线程安全的，因此可以保证在多线程环境下程序的正确性和较好的性能。</p><p>需要注意的是，虽然 <code>ConcurrentHashMap</code> 的并发性能很好，但是在某些情况下，它可能会比 <code>HashMap</code> 或者 <code>Hashtable</code> 略微慢一些，因为在并发操作时需要进行一些额外的逻辑处理。因此，在单线程环境下，使用 <code>ConcurrentHashMap</code> 可能不如 <code>HashMap</code> 或者 <code>Hashtable</code> 快速。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>在多线程环境下，如果多个线程同时对同一个数据结构进行修改，就可能会出现线程安全问题。Java 中的 <code>Hashtable</code> 是一种线程安全的哈希表，它可以在多线程环境下安全地进行读写操作。</p><p>具体来说，<code>Hashtable</code> 在实现上使用了同步锁，即每个方法都是同步的。当一个线程在使用 <code>Hashtable</code> 进行读写操作时，其他线程需要等待该线程完成操作并释放锁之后才能进行操作，从而保证了线程安全。</p><p>下面是一个使用 <code>Hashtable</code> 的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Hashtable&lt;String, Integer&gt; table = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 10 个线程，每个线程对表中一个键进行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;key&quot;</span> + num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> num;</span><br><span class="line">                table.put(key, value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put &quot;</span> + key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get &quot;</span> + key + <span class="string">&quot;: &quot;</span> + table.get(key));</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个 <code>Hashtable</code> 对象，并创建了 10 个线程。每个线程对表中一个键进行操作，包括插入键值对和获取键对应的值。由于 <code>Hashtable</code> 是线程安全的，因此可以保证在多线程环境下程序的正确性。</p><p>需要注意的是，由于 <code>Hashtable</code> 的每个方法都是同步的，因此在高并发环境下，使用 <code>Hashtable</code> 可能会导致性能问题。如果不需要强制要求线程安全，可以考虑使用 <code>HashMap</code> 或者 <code>ConcurrentHashMap</code> 等非线程安全的数据结构，它们在性能上更有优势。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
