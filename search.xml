<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM</title>
      <link href="/posts/43de.html"/>
      <url>/posts/43de.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>参考：<a href="https://javaguide.cn/java/jvm/memory-area.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">https://javaguide.cn/java/jvm/memory-area.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F</a></p></blockquote><p>Java程序的具体运行过程如下：</p><ol><li>Java源文件被编译器编译成字节码文件</li><li>JVM将字节码文件编译成对应操作系统的机器码</li><li>机器码调用相应操作系统的本地方法库执行相应的方法</li></ol><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。<br>JDK1.8和之前的版本略有不同，我们这里以JDK1.7和JDK1.8这两个版本为例介绍。<br>JDK1.7<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549410036-90c7236d-8a09-496b-8c48-d7a6adea79ab.png" alt="image.png"><br>JDK1.8<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549564819-26518ebd-f88c-4093-ba31-fea1211758e9.png" alt="image.png"><br><strong>线程私有的</strong>：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的</strong>：</p><ul><li>堆</li><li>方法区</li><li>直接内存（非运行时数据的一部分）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683550157412-b0e7c7e8-13df-4cf1-ae46-6393d80d39b8.png#averageHue=%23f8e6b1&clientId=ua79c1db5-d450-4&from=paste&height=653&id=u5c02a440&originHeight=882&originWidth=569&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=28977&status=done&style=none&taskId=u3ed5fb2e-32d7-4fd5-9172-26939920d5a&title=&width=421.4815112560068" alt="image.png"></p><h2 id="程序计数器：线程私有，无内存溢出问题"><a href="#程序计数器：线程私有，无内存溢出问题" class="headerlink" title="程序计数器：线程私有，无内存溢出问题"></a>程序计数器：线程私有，无内存溢出问题</h2><h2 id="虚拟机栈：线程私有，描述Java方法的执行过程"><a href="#虚拟机栈：线程私有，描述Java方法的执行过程" class="headerlink" title="虚拟机栈：线程私有，描述Java方法的执行过程"></a>虚拟机栈：线程私有，描述Java方法的执行过程</h2><h2 id="本地方法区：线程私有"><a href="#本地方法区：线程私有" class="headerlink" title="本地方法区：线程私有"></a>本地方法区：线程私有</h2><h2 id="堆：也叫做运行时数据区，线程共享"><a href="#堆：也叫做运行时数据区，线程共享" class="headerlink" title="堆：也叫做运行时数据区，线程共享"></a>堆：也叫做运行时数据区，线程共享</h2><p>在JVM运行过程中创建的对象和产生的数据都被存储在堆中，堆是被线程共享的内存区域，也是垃圾收集器进行垃圾回收的最主要的内存区域。由于现代JVM采用<strong>分代收集算法</strong>，因此Java堆从GC（Garbage Collection，垃圾回收）的角度还以细分为：<strong>新生代、老年代和永久代</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630793404-9b3b6bee-23d1-4cdb-a2f3-d8df84d58540.png#averageHue=%23fafaf9&clientId=u275002bd-b1a6-4&from=paste&height=401&id=uca692266&originHeight=541&originWidth=992&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=25692&status=done&style=none&taskId=u9e373ecb-226d-4e34-bde9-24ab7e825df&title=&width=734.8148667240049" alt="image.png"></p><h3 id="新生代📑"><a href="#新生代📑" class="headerlink" title="新生代📑"></a>新生代📑</h3><p>JVM的新生代是垃圾回收器的主要关注区域之一，也是Java程序中最常用的内存区域之一。新生代被分为三个不同的区域：Eden区、Survivor区和Old区。JVM创建的对象（除了大对象）会被放在新生代</p><ol><li>Eden区：是新生代中最大的一个区域，主要用于存放新创建的对象。当一个对象被创建时，它会被分配到Eden区中，经过一段时间后，如果该对象没有被任何其他引用指向，就会被移动到Survivor区中。 </li><li>Survivor From区：</li><li>Survivor To区：</li></ol><p>JVM的新生代采用复制算法进行垃圾回收，即将存活的对象复制到另一个空闲的区域中，以便减少垃圾回收器的扫描范围。这种算法的优点是可以减少扫描的范围，但缺点是需要更多的内存来存储复制后的对象。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代是Java虚拟机(JVM)中的一个重要的内存区域，用于存放生命周期较长、存活时间较长的对象。当一个对象被创建时，它会被分配到新生代中的Eden区或Survivor区中，如果经过多次垃圾回收后仍然存活，那么它就会被晋升到老年代中。</p><p>在老年代中，垃圾回收器不会进行复制算法，而是采用标记清除、标记整理、分代收集等方式进行垃圾回收。因为老年代中的对象生命周期较长，所以它们占用的内存也较大，如果使用复制算法，会浪费更多的内存空间。</p><p>老年代中的对象通常包含一些重要的信息，比如类元数据、常量池等，因此在进行垃圾回收时需要特别小心，以免误删重要对象导致程序出错。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>永久代是Java虚拟机(JVM)中的一个特殊的内存区域，主要用于存放类的信息、常量池、静态变量等。在JDK1.8及之前的版本中，永久代是JVM的一部分，而在JDK1.8中，永久代被移除并取代为元空间(Metaspace),但是一些老的应用程序仍然在使用永久代。</p><p>在永久代中，所有的类信息和常量池都被存储在一个叫做“类定义”的表格中，每个类都有一个唯一的标识符作为键值。当一个类被加载时，它的类定义会被复制到永久代中，并且在运行时可以通过类名来访问。</p><p>由于永久代的特殊作用，它在垃圾回收中具有重要的地位。在垃圾回收过程中，如果永久代中存在未被引用的对象，那么这些对象就会被认为已经死亡，并且可以被回收。但是由于永久代的特殊性质，垃圾回收器需要特别小心，以免误删重要对象导致程序出错。</p><h2 id="方法区：线程共享"><a href="#方法区：线程共享" class="headerlink" title="方法区：线程共享"></a>方法区：线程共享</h2><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629182248-e3c2609d-1dd2-491a-9304-cdc7f1a188aa.png#averageHue=%23f2fbf4&clientId=u275002bd-b1a6-4&from=paste&id=ua8435a7c&originHeight=177&originWidth=361&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=true&size=6293&status=done&style=none&taskId=ufe20066a-bf7a-45ad-9596-300804335f1&title=%E5%AF%B9%E8%B1%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8" alt="对象循环引用" title="对象循环引用"></p><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<br>下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629305757-0545fc81-98da-4b24-8a6e-ec79be5733b8.png#averageHue=%23f5fef7&clientId=u275002bd-b1a6-4&from=paste&id=u32975fbe&originHeight=541&originWidth=721&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=44067&status=done&style=none&taskId=uecf32805-1127-4af8-9030-e47f5405b0b&title=" alt="image.png"></p><h3 id="哪些对象可以作为GC-Roots"><a href="#哪些对象可以作为GC-Roots" class="headerlink" title="哪些对象可以作为GC Roots"></a>哪些对象可以作为GC Roots</h3><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="对象可以被回收，就代表一定会被回收吗？"><a href="#对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="对象可以被回收，就代表一定会被回收吗？"></a>对象可以被回收，就代表一定会被回收吗？</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 <code>finalize </code>方法，或 <code>finalize </code>方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h2 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。<br>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629511889-7f16b482-7a56-4001-9053-293de927737e.png#averageHue=%23a5d5d4&clientId=u275002bd-b1a6-4&from=paste&id=u02a3e29c&originHeight=451&originWidth=651&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=32144&status=done&style=none&taskId=u444eac74-6c75-4c59-8eb3-ff68efe92fb&title=" alt="image.png"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p> 为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629545584-086144bd-459b-486c-b312-bcf37e57c101.png#averageHue=%23f4fdf6&clientId=u275002bd-b1a6-4&from=paste&id=u55c6a486&originHeight=451&originWidth=741&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=37560&status=done&style=none&taskId=u6bd3b62e-c754-444e-b12b-8d2b2361c39&title=" alt="image.png"><br>改进了标记-清除算法，但依然存在下面的问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能就会变得很差</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p> 标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629673024-50bb9a34-5cc5-41dd-b5b9-039c7c94d94c.png#averageHue=%2391cbcc&clientId=u275002bd-b1a6-4&from=paste&id=ue0af7be4&originHeight=451&originWidth=661&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=31336&status=done&style=none&taskId=ub287cd0d-9b61-46a2-b4d8-dda4ccd9c25&title=" alt="image.png"><br>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，针对不同类型的对象类型，JVM采用了不同的垃圾回收算法。将 Java 堆分为新生代和老年代，新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，每次进行垃圾回收都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，可回收的对象相对较少<br>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“<strong>标记-清除</strong>”或“标记-整理”算法进行垃圾收集。<br>JVM将新生代进一步划分。JVM在运行过程中主要使用Eden区和Survivor From区，进行垃圾回收时会将Eden区和Survivor From区中存活的对象复制到Survivor To区，然后清理两个区的内存空间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630382838-fc023dfe-bf13-4a03-bd1e-11f81db51cf2.png#averageHue=%23f9f6ee&clientId=u275002bd-b1a6-4&from=paste&height=240&id=uf23644c4&originHeight=324&originWidth=845&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=12661&status=done&style=none&taskId=u76d2236b-2722-44e0-8d29-80a4b3cc947&title=&width=625.9259701429276" alt="image.png"><br><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？<br>根据上面的对分代收集算法的介绍回答。</p><h1 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h1><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。<br>Java中的四种引用类型包括：</p><ol><li>强引用(Strong Reference):是最常见的引用类型，如果一个对象被强引用指向，垃圾回收器就不会回收它。 </li><li>软引用(Soft Reference):用来描述一些还有用但并非必需的对象。只有当内存不足时，垃圾回收器才会回收被软引用指向的对象。 </li><li>弱引用(Weak Reference):用来描述非必需对象，但是比软引用更弱。如果一个对象只被弱引用所指向，那么垃圾回收器在下一次回收时就会回收它。 </li><li>虚引用(Phantom Reference):是最弱的引用类型，用来描述不可能存活的对象。如果一个对象只被虚引用所指向，那么垃圾回收器在任何时候都有可能回收它。</li></ol><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>Java堆内存分为新生代和老年代：新生代主要存储短期生命周期对象，适合使用复制算法进行垃圾回收；老年代主要存储长生命周期的对象，适合使用标记整理算法进行垃圾回收.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631816626-8133fe52-fd39-4b9f-ab52-26a570234e07.png#averageHue=%23fbf2eb&clientId=u275002bd-b1a6-4&from=paste&height=430&id=u13b342a1&originHeight=581&originWidth=1468&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=75257&status=done&style=none&taskId=ueefb1479-498d-44f4-afdb-80b29ef0b5b&title=&width=1087.4074842246362" alt="image.png"><br>JVM(Java虚拟机)垃圾收集器是用于自动管理堆内存的一组工具。它们的主要目标是尽可能地减少应用程序暂停时间，以提高应用程序的性能和响应能力。</p><p>以下是一些常见的JVM垃圾收集器：</p><ol><li>Serial收集器：这是默认的收集器，它使用单线程来标记和清除存活的对象。它适用于小型应用程序，因为它的缺点是垃圾回收时间较长，可能会导致应用程序暂停。 </li><li>Parallel收集器：这是一种多线程收集器，它可以利用多个CPU核心并行执行标记和清除操作，从而缩短垃圾回收时间。它适用于大型应用程序，但需要更多的系统资源。 </li><li>CMS收集器：这是一种低延迟收集器，它可以在应用程序运行时进行垃圾回收，而不会影响应用程序的性能。它适用于对响应时间要求较高的应用程序。 </li><li>G1收集器：这是一种基于区域的收集器，它将堆划分为多个大小相等的区域，并在这些区域内进行垃圾回收。它可以减少GC暂停时间并提高吞吐量。它适用于大型应用程序和高负载环境。</li></ol><p>JVM垃圾收集器的选择取决于应用程序的需求和环境。在选择垃圾收集器时，需要考虑应用程序的性质、硬件配置、可用内存等因素。</p><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><h3 id="Serial收集器：单线程，复制算法"><a href="#Serial收集器：单线程，复制算法" class="headerlink" title="Serial收集器：单线程，复制算法"></a>Serial收集器：单线程，复制算法</h3><p>Serial垃圾收集器基于复制算法实现，它是一个单线程收集器，在它正在进行垃圾收集时，必须暂停其它工作线程，直到垃圾收集完毕<br>特点：简单、高效<br>是Java虚拟机运行在Client模式下的新生代的默认垃圾处理器<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631968047-9ae37729-acbd-4099-8c4e-5766fa6c7bbf.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=ueda4f2cf&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=u43d8d21c-2fae-4754-b613-adde849c645&title=" alt="image.png"></p><h3 id="ParNew收集器：多线程，复制算法"><a href="#ParNew收集器：多线程，复制算法" class="headerlink" title="ParNew收集器：多线程，复制算法"></a>ParNew收集器：多线程，复制算法</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632203749-aa4e1baa-dc1f-40e9-8bcd-043597efb590.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u722ab4f7&originHeight=245&originWidth=853&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=23095&status=done&style=none&taskId=uedad3fd7-98d4-457a-9f86-55dad756f63&title=" alt="image.png"></p><h3 id="Parallel-Scavenge收集器：多线程，复制算法"><a href="#Parallel-Scavenge收集器：多线程，复制算法" class="headerlink" title="Parallel Scavenge收集器：多线程，复制算法"></a>Parallel Scavenge收集器：多线程，复制算法</h3><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632308217-b9c5b923-2fb8-401f-ba88-d9678cd79d5b.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=uceece797&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u978058f2-2415-4553-b2f3-b99efd0682c&title=" alt="image.png"><br><strong>这是 JDK1.8 默认收集器</strong></p><h2 id="老年代-1"><a href="#老年代-1" class="headerlink" title="老年代"></a>老年代</h2><h3 id="Serial-Old收集器：单线程，标记整理算法"><a href="#Serial-Old收集器：单线程，标记整理算法" class="headerlink" title="Serial Old收集器：单线程，标记整理算法"></a>Serial Old收集器：单线程，标记整理算法</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632429864-a623c075-fe2e-40c3-8ed4-f09c84941d19.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=u3fc3b7df&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=uda15cb43-7ea0-4939-b27b-79c006bbacc&title=" alt="image.png"></p><h3 id="Parallel-Old收集器：多线程，标记整理算法"><a href="#Parallel-Old收集器：多线程，标记整理算法" class="headerlink" title="Parallel Old收集器：多线程，标记整理算法"></a>Parallel Old收集器：多线程，标记整理算法</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632442127-02a1b005-0e75-48b1-97f8-696544f00177.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=u28ac7316&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u873b20f7-d26a-497c-9c7a-9669df7fb71&title=" alt="image.png"></p><h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong><br><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong><br>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632462911-869d143d-c390-4310-a541-ea3cdb9cebff.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=ubcf34b5e&originHeight=259&originWidth=1070&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27060&status=done&style=none&taskId=ucca971d1-af12-4c5d-8a6d-eebad040f40&title=" alt="image.png"><br>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong><br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632495542-8ffb84e3-2063-4feb-8814-4d10007c4fab.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u196f3523&originHeight=262&originWidth=999&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27690&status=done&style=none&taskId=u3fd59542-6ed5-48fa-8f17-62d4d92655b&title=" alt="image.png"><br><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
