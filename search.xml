<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/posts/dc87.html"/>
      <url>/posts/dc87.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是抽象工厂模式"><a href="#什么是抽象工厂模式" class="headerlink" title="什么是抽象工厂模式"></a>什么是抽象工厂模式</h1><h2 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h2><p>抽象工厂模式（Abstract Factory Pattern）是一种<strong>创建型设计模式</strong>，它提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</p><p>抽象工厂模式通过定义<strong>抽象工厂</strong>和<strong>抽象产品</strong>来实现，具体工厂和具体产品则根据抽象工厂和抽象产品来实现。抽象工厂定义了创建一系列产品的接口，每个具体工厂实现了该接口，以创建不同的产品族；抽象产品定义了产品的接口，每个具体产品实现了该接口，以提供不同的产品种类。<br>产品族：一个品牌下面的所有产品；例如华为下面的手机，路由器，电脑 称为华为的产品族；<br>产品等级：多个品牌下面的同种产品；例如华为和小米下面的手 称为一个产品等级；<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684584350390-df0c9b8d-1754-43a6-bdce-719d00366673.png#averageHue=%23f7f7f7&clientId=u74b4f415-608b-4&from=paste&id=u71f6936d&originHeight=345&originWidth=545&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=12291&status=done&style=none&taskId=u1e6058b0-bd04-4327-97eb-9b0545fac3d&title=" alt="image.png"></p><blockquote><p>拓展一个产品族</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684584688058-d3eb0af5-0bb5-4f56-b09d-779d5158c882.png#averageHue=%23fcf7f2&clientId=u74b4f415-608b-4&from=paste&id=ueda099b1&originHeight=873&originWidth=1663&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=399529&status=done&style=none&taskId=udb7e40fc-134b-4175-b81a-76c1e66940e&title=" alt="image.png"></p><blockquote><p>拓展一个产品等级</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684584658431-ae897668-6fd2-4cee-85ca-347e3e39b09e.png#averageHue=%23fcf9f5&clientId=u74b4f415-608b-4&from=paste&id=u28dfd4e6&originHeight=871&originWidth=1920&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=397740&status=done&style=none&taskId=u06e9f722-0138-4ccb-aa9a-fb773bdeea8&title=" alt="image.png"></p><ul><li>图片来源:<a href="https://blog.csdn.net/qq_33732195/article/details/110101808?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168458428216800182772849%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168458428216800182772849&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-110101808-null-null.142%5Ev87%5Econtrol,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187">抽象工厂模式（通俗易懂）</a></li></ul><p>抽象工厂模式的目的是提供一个接口，使得客户端可以使用这个接口创建一系列相关或相互依赖的对象，而不需要知道具体的实现细节。这样客户端就可以从具体产品的实现中解耦出来，从而更加灵活地对待不同的产品种类。</p><p>在抽象工厂模式中，每个具体工厂只能创建一种产品族，但是可以创建多个不同的产品种类。因此，抽象工厂模式适用于需要创建一系列相关或相互依赖的对象，且这些对象的种类是固定的，但是需要根据不同的产品族进行选择的场景。</p><h2 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h2><p>抽象工厂模式（Abstract Factory Pattern）具有以下优点：</p><ol><li><strong>分离接口和实现</strong>：抽象工厂模式将接口和实现分离开来，客户端只需要关注接口，而不需要知道具体的实现细节，从而实现解耦。 </li><li><strong>隐藏细节</strong>：抽象工厂模式隐藏了产品的创建细节，客户端只需要调用工厂方法就可以得到所需的产品，从而实现了更加简洁的代码。 </li><li><strong>提供多态性</strong>：抽象工厂模式提供了多态性，可以根据需要选择不同的具体工厂来创建不同的产品，从而实现了更加灵活的代码。 </li><li><strong>支持扩展性</strong>：抽象工厂模式支持扩展性，可以通过添加新的具体工厂和具体产品来扩展系统，而不需要修改现有的代码。 </li><li><strong>符合开闭原则</strong>：抽象工厂模式符合开闭原则，可以在不修改现有代码的情况下扩展系统功能，从而提高系统的可维护性、可扩展性和可重用性。 </li><li><strong>保证产品族内的一致性</strong>：抽象工厂模式可以保证产品族内的一致性，即同一个工厂生产的产品之间具有相关性，从而保证了系统的稳定性和可靠性。</li></ol><h2 id="抽象工厂模式的缺点"><a href="#抽象工厂模式的缺点" class="headerlink" title="抽象工厂模式的缺点"></a>抽象工厂模式的缺点</h2><p>抽象工厂模式（Abstract Factory Pattern）也存在一些缺点：</p><ol><li><strong>不易扩展产品等级结构</strong>：由于抽象工厂模式中每个具体工厂只能生产一族产品，且每个具体产品只能属于一个产品族，因此如果需要扩展产品等级结构，就需要修改抽象工厂接口和所有具体工厂的实现，从而影响系统的稳定性和维护性。 </li><li><strong>增加系统的复杂度</strong>：由于抽象工厂模式需要定义多个抽象类或接口，以及多个具体类或接口，因此会增加系统的复杂度和理解难度。 </li><li><strong>不够灵活</strong>：由于抽象工厂模式只能生产固定的产品族，因此不够灵活，无法在运行时动态切换产品族。 </li><li><strong>不适合单个产品的创建</strong>：由于抽象工厂模式主要用于生产产品族，因此不适合单个产品的创建，如果需要生产单个产品，可以使用工厂模式或创建者模式。</li></ol><h1 id="抽象工厂模式的实现方式"><a href="#抽象工厂模式的实现方式" class="headerlink" title="抽象工厂模式的实现方式"></a>抽象工厂模式的实现方式</h1><h2 id="抽象工厂模式的角色"><a href="#抽象工厂模式的角色" class="headerlink" title="抽象工厂模式的角色"></a>抽象工厂模式的角色</h2><p>抽象工厂模式（Abstract Factory Pattern）中包含以下角色：</p><ol><li>抽象工厂（Abstract Factory）：定义了创建一族产品的接口，包含多个创建产品的抽象方法。 </li><li>具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建一族具体产品。 </li><li>抽象产品（Abstract Product）：定义了产品的接口，包含多个抽象方法，不同的具体产品实现不同的抽象方法。 </li><li>具体产品（Concrete Product）：实现了抽象产品接口，由具体工厂负责创建。</li></ol><p>在抽象工厂模式中，抽象工厂定义了创建一族产品的接口，每个具体工厂实现了该接口，以创建不同的产品族；抽象产品定义了产品的接口，每个具体产品实现了该接口，以提供不同的产品种类。</p><h2 id="抽象工厂模式的实现"><a href="#抽象工厂模式的实现" class="headerlink" title="抽象工厂模式的实现"></a>抽象工厂模式的实现</h2><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂（Abstract Factory）是抽象工厂模式（Abstract Factory Pattern）中的一个关键角色，它定义了一个创建一族产品对象的接口，具体工厂类通过实现抽象工厂接口来创建不同的产品族。</p><p>抽象工厂中包含多个创建产品的抽象方法，每个抽象方法对应一种产品，具体工厂类通过实现这些抽象方法来创建不同的产品。抽象工厂类通常使用接口或抽象类来定义，具体工厂类则实现这些接口或抽象类。</p><p>抽象工厂模式中，每个具体工厂只能创建一族产品，但是可以创建多个不同的产品种类。抽象工厂模式适用于需要创建一系列相关或相互依赖的对象，且这些对象的种类是固定的，但是需要根据不同的产品族进行选择的场景。</p><p>总之，抽象工厂是抽象工厂模式中的一个重要角色，它定义了一个创建一族产品对象的接口，具体工厂类通过实现该接口来创建不同的产品族，从而实现了产品族的灵活选择。抽象工厂模式的优点在于提供了一种简单的方式来创建一系列相关或相互依赖的对象，同时也符合开闭原则，可以方便地添加新的产品族。</p><h3 id="具体工厂"><a href="#具体工厂" class="headerlink" title="具体工厂"></a>具体工厂</h3><p>具体工厂（Concrete Factory）是抽象工厂模式（Abstract Factory Pattern）中的一个角色，它实现了抽象工厂接口，负责创建一族具体产品。</p><p>具体工厂类通常使用工厂方法来创建具体产品对象，每个具体工厂只能创建一族产品，但是可以创建多个不同的产品种类。具体工厂类负责实现抽象工厂接口中定义的所有抽象方法，每个抽象方法对应一种产品，具体工厂类通过实现这些抽象方法来创建不同的产品。</p><p>具体工厂是抽象工厂的具体实现，它与具体产品紧密关联，每个具体工厂只能生产一族产品，但是可以在同一族产品中创建多个不同的产品种类。具体工厂类可以通过配置文件、反射等方式来实现动态创建，从而提高系统的灵活性和扩展性。</p><p>总之，具体工厂是抽象工厂模式中的一个重要角色，它实现了抽象工厂接口，负责创建一族具体产品。具体工厂类通过实现抽象工厂接口中定义的所有抽象方法来创建不同的产品，从而实现了产品族的灵活选择。具体工厂模式的优点在于提供了一种简单的方式来创建一系列相关或相互依赖的对象，同时也符合开闭原则，可以方便地添加新的产品族。</p><h3 id="抽象产品"><a href="#抽象产品" class="headerlink" title="抽象产品"></a>抽象产品</h3><p>抽象产品（Abstract Product）是抽象工厂模式（Abstract Factory Pattern）中的一个角色，它定义了产品的接口，包含多个抽象方法，不同的具体产品实现不同的抽象方法。</p><p>抽象产品是具体产品的基类，通过定义产品的公共接口，实现了产品的抽象化和标准化，使得客户端可以通过抽象接口来访问具体产品。抽象产品通常使用接口或抽象类来定义，具体产品则实现这些接口或抽象类。</p><p>抽象产品是抽象工厂模式中的一个重要角色，它定义了产品的接口和行为，具体工厂类通过实现抽象产品接口来创建不同的产品。抽象产品使得客户端可以使用抽象接口来访问具体产品，从而实现了产品的解耦和灵活性。</p><p>总之，抽象产品是抽象工厂模式中的一个重要角色，它定义了产品的接口和行为，具体产品则实现了该接口和行为，从而实现了产品的抽象化和标准化。抽象产品的优点在于提供了一种简单的方式来定义产品的接口和行为，使得客户端可以通过抽象接口来访问具体产品，从而实现了产品的解耦和灵活性。</p><h3 id="具体产品"><a href="#具体产品" class="headerlink" title="具体产品"></a>具体产品</h3><p>具体产品（Concrete Product）是抽象工厂模式（Abstract Factory Pattern）中的一个角色，它实现了抽象产品接口，并由具体工厂负责创建。</p><p>具体产品是具体工厂所创建的对象，它与具体工厂紧密关联，每个具体工厂只能生产一族产品，但是可以在同一族产品中创建多个不同的产品种类。具体产品通常包含产品的具体实现，实现产品的具体行为和功能。</p><p>具体产品是抽象产品的具体实现，通过实现抽象产品接口中定义的抽象方法来实现产品的具体行为和功能。具体产品的种类和实现方式可以根据具体业务需求来确定，在具体工厂中进行创建和初始化。</p><p>总之，具体产品是抽象工厂模式中的一个重要角色，它实现了抽象产品接口，并由具体工厂负责创建。具体产品的优点在于可以根据具体业务需求来确定产品的种类和实现方式，实现了产品的具体化和个性化。同时，具体产品也具有可扩展性，可以通过继承或实现抽象产品接口来添加新的产品种类和实现方式。</p><h1 id="抽象工厂模式的应用场景"><a href="#抽象工厂模式的应用场景" class="headerlink" title="抽象工厂模式的应用场景"></a>抽象工厂模式的应用场景</h1><h2 id="GUI工具包"><a href="#GUI工具包" class="headerlink" title="GUI工具包"></a>GUI工具包</h2><p>在GUI应用程序中，需要创建一系列相关的控件，例如文本框、按钮、标签等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些控件的抽象方法，具体工厂类实现这些抽象方法来创建不同的控件。这样可以在运行时选择不同的具体工厂来创建不同的GUI工具包，从而实现了GUI工具包的灵活选择。</p><h2 id="数据库访问层"><a href="#数据库访问层" class="headerlink" title="数据库访问层"></a>数据库访问层</h2><p>在数据库访问层中，需要创建一系列相关的对象，例如数据库连接、命令对象、数据适配器等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的数据库访问对象。这样可以在运行时选择不同的具体工厂来创建不同的数据库访问对象，从而实现了数据库访问层的灵活选择。</p><h2 id="加密算法库"><a href="#加密算法库" class="headerlink" title="加密算法库"></a>加密算法库</h2><p>在数据库访问层中，需要创建一系列相关的对象，例如数据库连接、命令对象、数据适配器等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的数据库访问对象。这样可以在运行时选择不同的具体工厂来创建不同的数据库访问对象，从而实现了数据库访问层的灵活选择。</p><h2 id="日志记录器"><a href="#日志记录器" class="headerlink" title="日志记录器"></a>日志记录器</h2><p>在数据库访问层中，需要创建一系列相关的对象，例如数据库连接、命令对象、数据适配器等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的数据库访问对象。这样可以在运行时选择不同的具体工厂来创建不同的数据库访问对象，从而实现了数据库访问层的灵活选择。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在缓存中，需要创建一系列相关的缓存对象，例如内存缓存、磁盘缓存、分布式缓存等。抽象工厂模式可以提供一个抽象工厂接口，定义创建这些缓存对象的抽象方法，具体工厂类实现这些抽象方法来创建不同的缓存对象。这样可以在运行时选择不同的具体工厂来创建不同的缓存对象，从而实现了缓存的灵活选择。</p><h1 id="抽象工厂模式的实际应用举例"><a href="#抽象工厂模式的实际应用举例" class="headerlink" title="抽象工厂模式的实际应用举例"></a>抽象工厂模式的实际应用举例</h1><h2 id="Java中的抽象工厂模式实现"><a href="#Java中的抽象工厂模式实现" class="headerlink" title="Java中的抽象工厂模式实现"></a>Java中的抽象工厂模式实现</h2><p>在Java中，抽象工厂模式可以通过定义抽象工厂接口和具体工厂类来实现。同时，每个具体工厂类负责创建一组相关的产品对象，这些产品对象通常也会定义为抽象类或接口，并由具体产品类实现。</p><p>下面是一个简单的Java代码示例，用于演示如何使用抽象工厂模式：</p><p>首先，定义一个抽象工厂接口，用于声明创建产品对象的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，定义具体工厂类，实现抽象工厂接口，并负责创建一组相关的产品对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ConcreteFactory1和ConcreteFactory2分别实现了AbstractFactory接口，并分别负责创建一组相关的产品对象，即ConcreteProductA1和ConcreteProductB1，以及ConcreteProductA2和ConcreteProductB2。</p><p>接下来，定义抽象产品类或接口，用于声明具体产品对象的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，定义具体产品类，实现抽象产品类或接口，以提供具体的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductA1.operationA()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductB1.operationB()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> <span class="keyword">implements</span> <span class="title class_">ProductA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductA2.operationA()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> <span class="keyword">implements</span> <span class="title class_">ProductB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteProductB2.operationB()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，可以创建一个客户端代码，用于使用抽象工厂模式创建产品对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> staticvoid <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA1</span> <span class="operator">=</span> factory1.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB1</span> <span class="operator">=</span> factory1.createProductB();</span><br><span class="line">        <span class="type">ProductA</span> <span class="variable">productA2</span> <span class="operator">=</span> factory2.createProductA();</span><br><span class="line">        <span class="type">ProductB</span> <span class="variable">productB2</span> <span class="operator">=</span> factory2.createProductB();</span><br><span class="line"></span><br><span class="line">        productA1.operationA();</span><br><span class="line">        productB1.operationB();</span><br><span class="line">        productA2.operationA();</span><br><span class="line">        productB2.operationB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，首先创建了两个具体工厂对象，分别是ConcreteFactory1和ConcreteFactory2。然后，使用这些工厂对象创建一组相关的产品对象，即ProductA和ProductB。最后，调用每个产品对象的操作方法，以演示它们的具体实现。</p><p>总的来说，通过定义抽象工厂接口和具体工厂类，以及抽象产品类或接口和具体产品类，Java程序可以使用抽象工厂模式轻松创建一组相关的产品对象，并在需要时轻松替换具体工厂和产品对象的实现。</p><h2 id="Spring框架中的抽象工厂模式应用"><a href="#Spring框架中的抽象工厂模式应用" class="headerlink" title="Spring框架中的抽象工厂模式应用"></a>Spring框架中的抽象工厂模式应用</h2><p>在Spring框架中，抽象工厂模式被广泛地应用于创建和管理对象。具体来说，Spring框架中的BeanFactory就是一个抽象工厂接口，它声明了一组用于创建和管理对象的方法。而XmlBeanFactory、DefaultListableBeanFactory和ApplicationContext等具体工厂类则实现了BeanFactory接口，并负责创建和管理一组相关的对象。</p><p>在Spring框架中，BeanFactory接口定义了一组用于获取和管理对象的方法，包括：</p><ul><li>getBean(String name): 根据给定的Bean名称获取一个对象实例。</li><li>getBean(Class requiredType): 根据指定的对象类型获取一个对象实例。</li><li>containsBean(String name): 判断指定名称的Bean是否存在。</li><li>isSingleton(String name): 判断指定名称的Bean是否为单例。</li><li>isPrototype(String name): 判断指定名称的Bean是否为原型。</li><li>getAliases(String name): 获取指定名称的Bean的所有别名。</li></ul><p>其中，getBean()方法是最常用的方法，它根据给定的Bean名称或对象类型获取一个对象实例。具体工厂类则实现了BeanFactory接口，并负责创建和管理一组相关的对象。</p><p>例如，XmlBeanFactory是一个具体工厂类，它实现了BeanFactory接口，并使用XML配置文件来创建和管理对象。XmlBeanFactory可以读取XML配置文件，并根据文件中定义的Bean定义来创建和管理对象。它还可以自动解析Bean之间的依赖关系，以确保正确地创建和管理对象。</p><p>类似地，DefaultListableBeanFactory也是一个具体工厂类，它实现了BeanFactory接口，并使用Java代码来创建和管理对象。DefaultListableBeanFactory可以通过Java代码定义Bean定义，并使用依赖注入来管理Bean之间的依赖关系。</p><p>另外，ApplicationContext也是一个具体工厂类，它是Spring框架中最常用的工厂类之一。与XmlBeanFactory和DefaultListableBeanFactory不同，ApplicationContext不仅可以读取XML配置文件或Java代码，还可以读取其他类型的配置文件，如注解等。此外，ApplicationContext还提供了其他功能，如Bean生命周期管理、事件处理、AOP、事务管理等。</p><p>总之，在Spring框架中，抽象工厂模式被广泛地应用于创建和管理对象。BeanFactory接口作为抽象工厂接口，定义了一组用于获取和管理对象的方法，具体工厂类则实现了BeanFactory接口，并负责创建和管理一组相关的对象。XmlBeanFactory、DefaultListableBeanFactory和ApplicationContext等具体工厂类则是Spring框架中最常用的工厂类之一，它们使用不同的方式来创建和管理对象，如XML配置文件、Java代码、注解等，并提供了其他功能，如Bean生命周期管理、事件处理、AOP、事务管理等。</p><h1 id="抽象工厂模式与其他设计模式的关系"><a href="#抽象工厂模式与其他设计模式的关系" class="headerlink" title="抽象工厂模式与其他设计模式的关系"></a>抽象工厂模式与其他设计模式的关系</h1><h2 id="抽象工厂模式与工厂模式的区别"><a href="#抽象工厂模式与工厂模式的区别" class="headerlink" title="抽象工厂模式与工厂模式的区别"></a>抽象工厂模式与工厂模式的区别</h2><p>抽象工厂模式和工厂模式都是常见的对象创建型模式，它们都通过一个工厂来创建对象，但是它们之间还是存在一定的区别。</p><p>工厂模式是一种简单工厂模式，它定义了一个工厂接口或类，用于创建一个具体的产品对象。工厂模式只关心如何创建对象，而不关心对象所属的具体类别。具体的产品对象通常都实现了共同的接口或基类，以便于在客户端代码中使用。工厂模式最大的优点是可以将客户端代码与具体产品类的实现分离开来，从而实现了更好的解耦。</p><p>抽象工厂模式是一种更加高级的工厂模式，它定义了一个工厂接口或类，用于创建一组相关或者相互依赖的产品对象。抽象工厂模式与工厂模式的最大区别在于，抽象工厂模式可以创建多个不同类型的产品对象，而工厂模式只能创建一种类型的产品对象。在抽象工厂模式中，每个具体工厂类负责创建一整个产品族的产品对象，而不是单个产品对象。因此，抽象工厂模式通常用于创建一组相关的产品对象，例如UI控件的颜色和样式等。</p><p>总的来说，工厂模式和抽象工厂模式都是用于创建对象的模式，二者的区别在于工厂模式只能创建单个类型的产品对象，而抽象工厂模式可以创建多个不同类型的产品对象，且每个具体工厂类负责创建一整个产品族的产品对象。因此，在使用这两种模式时，需要根据具体的需求来选择适合的模式。</p><h2 id="抽象工厂模式与建造者模式的关系"><a href="#抽象工厂模式与建造者模式的关系" class="headerlink" title="抽象工厂模式与建造者模式的关系"></a>抽象工厂模式与建造者模式的关系</h2><p>抽象工厂模式和建造者模式都是对象创建型模式，它们都关注如何创建复杂的对象。虽然它们的目的相同，但是它们的实现方式和应用场景有所不同。</p><p>抽象工厂模式是一种创建型模式，它提供了一个接口来创建一系列相关的产品对象，而无需指定它们的具体类。抽象工厂模式通常用于创建一组相关或相互依赖的对象，例如UI控件的颜色和样式等。</p><p>建造者模式是一种创建型模式，它将一个复杂对象的构建过程分解成多个简单的步骤，并将这些步骤封装到一个Builder接口中。建造者模式可以按照不同的顺序创建不同的对象，以满足不同的需求。建造者模式通常用于创建复杂的对象，例如汽车、电脑等。</p><p>虽然抽象工厂模式和建造者模式都是用于创建对象的模式，但是它们之间还是存在一定的区别。主要区别如下：</p><ol><li>目的不同：抽象工厂模式的目的是创建一系列相关的产品对象，而建造者模式的目的是创建一个复杂对象。 </li><li>实现方式不同：抽象工厂模式通过定义一个工厂接口来创建产品对象，而建造者模式通过将构建过程分解成多个简单的步骤，并将这些步骤封装到一个Builder接口中来创建复杂对象。 </li><li>应用场景不同：抽象工厂模式通常用于创建一组相关或相互依赖的对象，例如UI控件的颜色和样式等。而建造者模式通常用于创建复杂的对象，例如汽车、电脑等。</li></ol><p>总的来说，抽象工厂模式和建造者模式都是用于创建对象的模式，它们的实现方式和应用场景有所不同。在选择使用哪种模式时，需要根据具体的需求来选择适合的模式。如果需要创建一组相关或相互依赖的对象，可以考虑使用抽象工厂模式；如果需要创建复杂的对象，并且需要按照不同的顺序创建不同的对象，可以考虑使用建造者模式。</p><h2 id="抽象工厂模式与单例模式的关系"><a href="#抽象工厂模式与单例模式的关系" class="headerlink" title="抽象工厂模式与单例模式的关系"></a>抽象工厂模式与单例模式的关系</h2><p>抽象工厂模式和单例模式都是常见的设计模式，它们都可以用于创建对象，但是它们的主要目的和应用场景有所不同。</p><p>抽象工厂模式是一种对象创建型模式，它提供了一个接口用于创建一组相关的产品对象，而无需指定它们的具体类。抽象工厂模式通常用于创建一组相关或相互依赖的对象，例如UI控件的颜色和样式等。抽象工厂模式的主要目的是将对象的创建与使用分离，从而实现了更好的解耦。</p><p>单例模式是一种对象创建型模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。单例模式通常用于需要共享资源或状态的对象，例如数据库连接池、线程池等。单例模式的主要目的是确保一个类只有一个实例，以避免资源浪费和状态不一致的问题。</p><p>虽然抽象工厂模式和单例模式都是用于创建对象的模式，但是它们的主要目的和应用场景有所不同，因此它们之间并没有直接的关系。抽象工厂模式主要用于创建一组相关的产品对象，而单例模式主要用于确保一个类只有一个实例。在实际应用中，抽象工厂模式和单例模式可以同时使用，例如在一个应用程序中，可以使用抽象工厂模式来创建一组相关的对象，并使用单例模式确保每个对象只有一个实例。这样可以充分利用抽象工厂模式和单例模式的优点，提高应用程序的性能和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/posts/bb83.html"/>
      <url>/posts/bb83.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p><a href="https://juejin.cn/post/6844904098580398088">https://juejin.cn/post/6844904098580398088</a><br><a href="https://juejin.cn/post/6844903517648322574">https://juejin.cn/post/6844903517648322574</a><br><a href="https://juejin.cn/post/6844903978342301709">https://juejin.cn/post/6844903978342301709</a><br><a href="https://juejin.cn/post/7066031623296253966">https://juejin.cn/post/7066031623296253966</a><br><a href="https://juejin.cn/post/6865807207229816845">https://juejin.cn/post/6865807207229816845</a></p></blockquote><p>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。<br><strong>代理模式</strong> （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。<br>通过代理模式，我们可以做到两点：</p><ol><li>隐藏委托类的具体实现</li><li>实现客户与委托类的解耦，在不改变类代码的情况下添加一些额外的功能（日志、权限等）</li></ol><h1 id="代理模式角色定义"><a href="#代理模式角色定义" class="headerlink" title="代理模式角色定义"></a>代理模式角色定义</h1><p>在编程的过程中我们可以定义为三类对象：</p><ul><li>Subject（抽象主题角色）：一般为接口（也可以是抽象类），定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法。比如：出售商品等。</li><li>RealSubject（真实主题角色）：真正实现业务逻辑的类。该类可以被称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了Subject接口，而Client端通过代理类间接的调用的真实主题类中的方法，由其执行真正的业务逻辑。。比如实现了广告、出售等方法的厂家（Factoryer）。</li><li>ProxySubject（代理主题角色）：该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了Subject接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。用来代理和封装真实主题。比如，同样实现了广告、出售等方法的超时（Shop）。 </li><li>Client 客户端的，使用代理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/32620241/1667383829047-83b898fc-be35-493c-916d-d2ee2264b131.png#averageHue=%23f5f5f5&clientId=uc3d53cf3-3fab-4&from=paste&height=321&id=u4ac9b2c7&originHeight=482&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65035&status=done&style=none&taskId=u5603d1cc-5e19-4a14-90f1-443faad46ed&title=&width=518.6666666666666" alt="image.png"><br>Subject &#x3D; 公共接口；<br>ProxySubject &#x3D; 代理对象 &#x3D; 代理类 &#x3D; 委托类 &#x3D; 代理人；<br>RealSubject &#x3D; 真实对象 &#x3D; 被代理类 &#x3D; 被委托类 &#x3D; 被代理人；</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1、定义代理对象和真实对象的公共接口；<br>2、真实对象实现公共接口中的方法；<br>3、代理对象实现公共接口中的方法，并把方法的逻辑转发给真实对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123; <span class="comment">// 代理对象和目标对象的公共接口。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改订单信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看订单详情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123; <span class="comment">// 目标对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123; <span class="comment">// 目标方法</span></span><br><span class="line">        <span class="comment">// 模拟生成订单的耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1234</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已生成.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123; <span class="comment">// 目标方法</span></span><br><span class="line">        <span class="comment">// 模拟修改订单的耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">456</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已修改.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span> &#123; <span class="comment">// 目标方法</span></span><br><span class="line">        <span class="comment">// 模拟查询订单的耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">111</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请看订单详情.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理对象（代理对象和目标对象要具有相同的行为，就要实现同一个或同一些接口。）</span></span><br><span class="line"><span class="comment">// 客户端在使用代理对象的时候就像在使用目标对象一样。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将目标对象作为代理对象的一个属性。这种关系叫做关联关系。比继承关系的耦合度低。</span></span><br><span class="line">    <span class="comment">// 代理对象中含有目标对象的引用。关联关系。has a</span></span><br><span class="line">    <span class="comment">// 注意：这里要写一个公共接口类型。因为公共接口耦合度低。</span></span><br><span class="line">    <span class="keyword">private</span> OrderService target; <span class="comment">// 这就是目标对象。目标对象一定是实现了OrderService接口的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象的时候，传一个目标对象给代理对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderServiceProxy</span><span class="params">(OrderService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123; <span class="comment">// 代理方法</span></span><br><span class="line">        <span class="comment">// 增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        target.generate();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123; <span class="comment">// 代理方法</span></span><br><span class="line">        <span class="comment">// 增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        target.modify();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span> &#123; <span class="comment">// 代理方法</span></span><br><span class="line">        <span class="comment">// 增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        target.detail();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建目标对象</span></span><br><span class="line"><span class="type">OrderService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceImpl</span>();</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="type">OrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceProxy</span>(target);</span><br><span class="line"><span class="comment">// 调用代理对象的代理方法</span></span><br><span class="line">proxy.generate();</span><br><span class="line">proxy.modify();</span><br><span class="line">proxy.detail();</span><br></pre></td></tr></table></figure><h1 id="动态代理📌"><a href="#动态代理📌" class="headerlink" title="动态代理📌"></a>动态代理📌</h1><p>在程序运行阶段，在内存中动态生成代理类，被称为动态代理，目的是为了减少代理类的数量。解决代码复用的问题。<br>在内存当中动态生成类的技术常见的包括：</p><ul><li>JDK动态代理技术：只能代理接口。</li><li>CGLIB动态代理技术：CGLIB(Code Generation Library)是一个开源项目。是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它既可以代理接口，又可以代理类，<strong>底层是通过继承的方式实现的</strong>。性能比JDK动态代理要好。<strong>（底层有一个小而快的字节码处理框架ASM。）</strong></li><li>Javassist动态代理技术：Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态”AOP”框架。</li></ul><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看订单详情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1234</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已生成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2541</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单信息如下：******&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1010</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单已修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">orderServiceProxy</span> <span class="operator">=</span> (OrderService) Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                                                                                target.getClass().getInterfaces(),</span><br><span class="line">                                                                                <span class="keyword">new</span> <span class="title class_">TimerInvocationHandler</span>(target));</span><br><span class="line">        <span class="comment">// 调用代理对象的代理方法</span></span><br><span class="line">        orderServiceProxy.detail();</span><br><span class="line">        orderServiceProxy.modify();</span><br><span class="line">        orderServiceProxy.generate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上第二步创建代理对象是需要大家理解的：</p><p>OrderService orderServiceProxy &#x3D; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), 调用处理器对象);<br>这行代码做了两件事：</p><ul><li>第一件事：在内存中生成了代理类的字节码</li><li>第二件事：创建代理对象</li></ul><p>Proxy类全名：java.lang.reflect.Proxy。这是JDK提供的一个类（所以称为JDK动态代理）。主要是通过这个类在内存中生成代理类的字节码。<br>其中newProxyInstance()方法有三个参数：</p><ul><li>第一个参数：类加载器。在内存中生成了字节码，要想执行这个字节码，也是需要先把这个字节码加载到内存当中的。所以要指定使用哪个类加载器加载。</li><li>第二个参数：接口类型。代理类和目标类实现相同的接口，所以要通过这个参数告诉JDK动态代理生成的类要实现哪些接口。</li><li>第三个参数：调用处理器。这是一个JDK动态代理规定的接口，接口全名：java.lang.reflect.InvocationHandler。显然这是一个回调接口，也就是说调用这个接口中方法的程序已经写好了，就差这个接口的实现类了。</li></ul><p>所以接下来我们要写一下java.lang.reflect.InvocationHandler接口的实现类，并且实现接口中的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InvocationHandler接口中有一个方法invoke，这个invoke方法上有三个参数：</p><ul><li>第一个参数：Object proxy。代理对象。设计这个参数只是为了后期的方便，如果想在invoke方法中使用代理对象的话，尽管通过这个参数来使用。</li><li>第二个参数：Method method。目标方法。</li><li>第三个参数：Object[] args。目标方法调用时要传的参数。</li></ul><p>我们将来肯定是要调用“目标方法”的，但要调用目标方法的话，需要“目标对象”的存在，“目标对象”从哪儿来呢？我们可以给TimerInvocationHandler提供一个构造方法，可以通过这个构造方法传过来“目标对象”，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造方法来传目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了目标对象我们就可以在invoke()方法中调用目标方法了。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造方法来传目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 目标执行之前增强。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标对象的目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">retValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 目标执行之后增强。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span>+(end - begin)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 一定要记得返回哦。</span></span><br><span class="line">        <span class="keyword">return</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                target.getClass().getInterfaces(), </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TimerInvocationHandler</span>(target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">orderServiceProxy</span> <span class="operator">=</span> (OrderService) ProxyUtil.newProxyInstance(target);</span><br><span class="line">        <span class="comment">// 调用代理对象的代理方法</span></span><br><span class="line">        orderServiceProxy.detail();</span><br><span class="line">        orderServiceProxy.modify();</span><br><span class="line">        orderServiceProxy.generate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>CGLIB既可以代理接口，又可以代理类。底层采用继承的方式实现。所以被代理的目标类不能使用final修饰。<br>使用CGLIB，需要引入它的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户正在登录系统....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户正在退出系统....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CGLIB在内存中为UserService类生成代理类，并创建对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字节码增强器</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 告诉cglib要继承哪个类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">// 设置回调接口</span></span><br><span class="line">        enhancer.setCallback(方法拦截器对象);</span><br><span class="line">        <span class="comment">// 生成源码，编译class，加载到JVM，并创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line"></span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">        userServiceProxy.logout();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和JDK动态代理原理差不多，在CGLIB中需要提供的不是InvocationHandler，而是：net.sf.cglib.proxy.MethodInterceptor<br>编写MethodInterceptor接口实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object target, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodInterceptor接口中有一个方法intercept()，该方法有4个参数：<br>第一个参数：目标对象<br>第二个参数：目标方法<br>第三个参数：目标方法调用时的实参<br>第四个参数：代理方法<br>在MethodInterceptor的intercept()方法中调用目标以及添加增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object target, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 前增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">retValue</span> <span class="operator">=</span> methodProxy.invokeSuper(target, objects);</span><br><span class="line">        <span class="comment">// 后增强</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时&quot;</span> + (end - begin) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 一定要返回</span></span><br><span class="line">        <span class="keyword">return</span> retValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调已经写完了，可以修改客户端程序了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字节码增强器</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 告诉cglib要继承哪个类</span></span><br><span class="line">        enhancer.setSuperclass(UserService.class);</span><br><span class="line">        <span class="comment">// 设置回调接口</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">TimerMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 生成源码，编译class，加载到JVM，并创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span> (UserService)enhancer.create();</span><br><span class="line"></span><br><span class="line">        userServiceProxy.login();</span><br><span class="line">        userServiceProxy.logout();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于高版本的JDK，如果使用CGLIB，需要在启动项中添加两个启动参数：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/32620241/1667388850691-93ef6826-514d-4de1-aa43-3581987a5191.png#averageHue=%23f3efef&clientId=uc3d53cf3-3fab-4&from=paste&height=435&id=uc7a2865a&originHeight=652&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137241&status=done&style=none&taskId=u4fa667b0-cad0-4bb6-821a-6e1b6155557&title=&width=639.3333333333334" alt="image.png"></p><ul><li>–add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li><li>–add-opens java.base&#x2F;sun.net.util&#x3D;ALL-UNNAMED</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/b434.html"/>
      <url>/posts/b434.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>单例模式（Singleton Pattern）是一种常见的创建型设计模式，用于确保一个类只有一个实例，并提供全局访问点。在实际应用中，单例模式经常被用来管理全局变量、配置信息等。</p><p>单例模式的核心思想是通过限制类的实例化次数来确保一个类只有一个实例。具体来说，单例模式通常通过以下方式来实现：</p><ol><li>私有化构造函数：将类的构造函数私有化，防止外部代码通过构造函数来创建类的实例。 </li><li>提供静态方法获取单例实例：提供一个静态方法来获取类的实例。该方法会判断类的实例是否已经存在，如果存在则直接返回该实例，否则创建一个新的实例并返回。 </li><li>保证线程安全性：在多线程环境下，需要保证单例实例的线程安全性。可以通过加锁、双重检查锁等方式来实现。</li></ol><p>单例模式的优点包括：</p><ol><li>确保一个类只有一个实例，避免了多次创建相同对象的开销，节省了系统资源。 </li><li>提供全局访问点，方便代码中的其他对象访问该实例，降低了代码的耦合性。 </li><li>可以控制实例化的过程，保证实例的唯一性和一致性。</li></ol><p>但是，单例模式也有一些缺点，包括：</p><ol><li>单例模式可能会导致代码的可测试性降低，因为它们创建了一个全局状态，可能会影响测试用例的正确性。 </li><li>单例模式可能会使代码的可维护性降低，因为它们隐藏了依赖关系，使得代码更难以理解和修改。 </li><li>单例模式可能会使代码的扩展性降低，因为它们往往是硬编码的，并且难以在运行时动态地添加或删除实例。</li></ol><p>总之，单例模式是一种常见的创建型设计模式，用于确保一个类只有一个实例，并提供全局访问点。它可以提高代码的性能和可维护性，但同时也需要注意其缺点，如可能降低代码的可测试性、可维护性和扩展性等问题。在实际应用中，需要根据具体场景来判断是否使用单例模式，并在实现时注意线程安全性、防止反射、序列化等问题。</p><h2 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h2><p>单例模式（Singleton Pattern）的结构包括以下几个元素：</p><ol><li>Singleton类：这是一个单例类，负责管理唯一的实例，并提供全局访问点。通常，该类会将其构造函数私有化，以防止外部代码直接创建实例，同时提供一个静态方法来获取单例实例。 </li><li>Instance变量：这是Singleton类中的一个静态变量，用于存储唯一的实例对象。在第一次调用静态方法获取单例实例时，该变量会被初始化。 </li><li>getInstance()方法：这是Singleton类中的一个静态方法，用于获取单例实例。在该方法中，会先判断Instance变量是否已经被初始化，如果已经被初始化，则直接返回实例对象。否则，会创建一个新的实例对象，并将其赋给Instance变量。 </li><li>Private Constructor：Singleton类的构造函数是私有化的，防止外部代码直接创建实例。通常，构造函数是空的或者仅用于完成一些初始化工作。</li></ol><p>下面是一个简单的单例模式的结构示意图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------------+</span><br><span class="line">|        Singleton Class          |</span><br><span class="line">+---------------------------------+</span><br><span class="line">| - instance: Singleton           |</span><br><span class="line">|---------------------------------|</span><br><span class="line">| + getInstance(): Singleton      |</span><br><span class="line">| - Singleton()                   |</span><br><span class="line">+---------------------------------+</span><br></pre></td></tr></table></figure><p>在上面的示意图中，Singleton类表示单例类，它包含一个私有的instance变量和一个公共的getInstance()方法。在getInstance()方法中，会先判断instance变量是否已经被初始化，如果已经被初始化，则直接返回instance变量；否则，会创建一个新的Singleton实例，并将其赋给instance变量。注意，Singleton类的构造函数是私有的，以防止外部代码直接创建实例。</p><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式（Eager Initialization）是一种常见的单例模式实现方式，它在<strong>类加载时就创建单例对象</strong>，保证了<strong>线程安全性</strong>。在实际应用中，饿汉式适用于单例对象的创建和<strong>初始化时间较短的场景</strong>。<br>饿汉式的核心思想是在类加载时就创建单例对象，具体实现方式是在类的定义中直接创建单例对象，并将其声明为静态变量。在使用单例对象时，直接通过类名来访问静态变量即可。<br>以下是一个简单的饿汉式单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的instance静态变量和一个公共的getInstance()方法。在Singleton类被加载时，instance静态变量就会被初始化为Singleton的唯一实例。在getInstance()方法中，直接返回instance变量即可。<br>饿汉式的优点是<strong>线程安全性高</strong>，因为单例对象在类加载时就被创建，避免了多线程环境下的实例化多次的问题。同时，饿汉式<strong>实现简单，使用方便</strong>，可以直接通过类名来访问单例对象。<br>饿汉式的缺点是<strong>可能会浪费系统资源</strong>，因为即使不需要使用单例对象也会被创建。此外，饿汉式也不支持延迟加载，因为单例对象在类加载时就被创建，无法根据需要动态地创建单例对象。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式（Lazy Initialization）是一种常见的单例模式实现方式，它在<strong>第一次使用时才创建单例对象</strong>，避免了不必要的资源浪费。在实际应用中，懒汉式适用于单例对象的创建和<strong>初始化时间较长的场景</strong>。<br>懒汉式的核心思想是在第一次使用时才创建单例对象，具体实现方式是在getInstance()方法中判断单例对象是否已经被创建，如果已经被创建则直接返回单例对象，否则创建一个新的单例对象并返回。由于懒汉式可能会出现多线程竞争导致的线程安全问题，因此需要考虑线程安全性。<br>以下是一个简单的线程不安全的懒汉式单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的instance变量和一个公共的getInstance()方法。在getInstance()方法中，如果instance变量为null，则创建一个新的Singleton实例并赋值给instance变量，否则直接返回instance变量。由于这种实现方式没有考虑线程安全性，可能会出现多线程环境下的实例化多次的问题。<br>为了避免多线程环境下的线程安全问题，可以使用<strong>synchronized</strong>关键字来加锁，保证getInstance()方法的同步性。以下是一个简单的线程安全的懒汉式单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，getInstance()方法被加上了synchronized关键字，保证了线程安全性。虽然这种实现方式解决了线程安全问题，但是每次调用getInstance()方法都需要获取锁，可能会影响性能。</p><h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><p>双重检查锁（Double-Checked Locking）是一种常见的单例模式实现方式，它<strong>在懒汉式的基础上，使用synchronized关键字来保证线程安全性，同时使用双重检查来避免多线程竞争导致的实例化多次的问题</strong>。在实际应用中，双重检查锁适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性和性能问题。</p><p>双重检查锁的核心思想是在getInstance()方法中，首先检查单例对象是否已经被创建，如果已经被创建，则直接返回单例对象。否则，加锁创建单例对象并赋值给静态变量，然后再次检查静态变量是否为空，如果为空，则创建一个新的单例对象并赋值给静态变量。由于双重检查锁需要考虑线程安全性和可见性，实现比较复杂。</p><p>以下是一个简单的双重检查锁单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicclass Singleton &#123;</span><br><span class="line">    private static volatile Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的instance变量和一个公共的getInstance()方法。在getInstance()方法中，首先检查instance变量是否已经被创建，如果instance变量为null，则加锁并再次检查instance变量是否为null，如果为null，则创建一个新的Singleton实例并赋值给instance变量。在加锁时，可以使用synchronized关键字或者Lock接口等方式来实现锁的同步性。</p><p>需要注意的是，为了避免由于指令重排带来的可见性问题，需要将instance变量声明为volatile类型。volatile关键字可以保证多线程环境下变量的可见性，避免出现线程安全问题。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类（Static Inner Class）是一种常见的单例模式实现方式，它利用Java的类加载机制，当外部类被加载时，静态内部类不会被加载，只有在第一次使用时才会被加载。静态内部类可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。在实际应用中，静态内部类适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性和性能问题。</p><p>静态内部类的核心思想是定义一个静态内部类，该内部类包含一个静态的单例对象，在getInstance()方法中，直接返回静态内部类中的单例对象即可。由于静态内部类只在第一次使用时才被加载，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。</p><p>以下是一个简单的静态内部类单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton类表示单例类，它包含一个私有的构造方法和一个公共的getInstance()方法。在Singleton类中定义了一个静态内部类SingletonHolder，该内部类包含一个静态的Singleton实例。在getInstance()方法中，直接返回SingletonHolder中的INSTANCE变量即可。</p><p>需要注意的是，静态内部类SingletonHolder是一个单例类，它只在第一次使用时才会被加载，且只会被加载一次。由于静态内部类中的INSTANCE变量是静态的，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类（Enum Class）是一种常见的单例模式实现方式，它利用Java中的枚举类型，在定义枚举类型时，可以直接指定枚举值，枚举值本身就是单例对象。枚举类可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。在实际应用中，枚举类适用于单例对象的创建和初始化时间较短的场景，且需要考虑线程安全性和性能问题。</p><p>枚举类的核心思想是定义一个枚举类型，枚举类型中的枚举值就是单例对象。在枚举类型中定义一个公共的访问方法，直接返回枚举值即可。由于枚举类型中的枚举值是静态的，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。</p><p>以下是一个简单的枚举类单例模式的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，Singleton是一个枚举类型，它只有一个枚举值INSTANCE。在INSTANCE枚举值中定义了一个公共的doSomething()方法，表示单例对象的行为。在使用单例对象时，直接通过Singleton.INSTANCE来访问单例对象即可。</p><p>需要注意的是，枚举类中的枚举值是静态的，因此可以保证线程安全性和实例化的唯一性。同时，枚举类型中的枚举值是在类加载时就被创建的，因此可以避免延迟加载带来的性能问题。此外，枚举类型还提供了序列化和反序列化的支持，可以避免反序列化时创建新的实例。</p><h2 id="如何选择❓"><a href="#如何选择❓" class="headerlink" title="如何选择❓"></a>如何选择❓</h2><p>不同的单例模式实现方式适用于不同的应用场景，下面是每种方式的应用场景：</p><ol><li>饿汉式（Eager Initialization）：适用于单例对象的创建和初始化时间较短的场景。由于在类加载时就创建了单例对象，因此可以避免多线程竞争导致的线程安全问题。 </li><li>懒汉式（Lazy Initialization）：适用于单例对象的创建和初始化时间较长的场景。由于只有在第一次使用时才创建单例对象，因此可以避免不必要的资源浪费。 </li><li>双重检查锁（Double-Checked Locking）：适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性。由于使用了双重检查来避免多线程竞争导致的实例化多次的问题，因此可以提高性能。 </li><li>静态内部类（Static Inner Class）：适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性。由于静态内部类只在第一次使用时才被加载，因此可以保证线程安全性和实例化的唯一性，同时避免了资源浪费和复杂的实现。这种方式是比较常用的单例模式实现方式之一。 </li><li>枚举类（Enum）：适用于单例对象的创建和初始化时间较长的场景，且需要考虑线程安全性和防止反射攻击。由于枚举类是单例的，因此可以保证实例化的唯一性和线程安全性，同时避免了序列化和反射攻击。这种方式是比较简单和安全的单例模式实现方式之一。</li></ol><p>在选择实现方式时，需要考虑单例对象的创建和初始化时间、线程安全性、资源浪费等因素，并根据具体情况来选择最合适的实现方式。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>单例模式虽然有很多优点，但是也存在一些问题，主要包括以下几点：</p><ol><li>破坏代码的可测试性：由于单例模式的实例化方式是固定的，因此在单元测试时，很难对单例对象进行模拟和替换，可能会导致测试的不稳定性和可靠性下降。</li></ol><p>解决方法：可以使用依赖注入（Dependency Injection）等技术来解决这个问题，将单例对象作为参数传递给依赖的对象，从而实现单例对象和依赖对象的解耦。另外，也可以使用模拟框架（Mock Framework）来模拟单例对象，从而方便进行单元测试。</p><ol start="2"><li>可能引起内存泄漏：由于单例对象的生命周期与整个应用程序的生命周期相同，在某些情况下，单例对象可能不会被及时回收，从而导致内存泄漏的问题。</li></ol><p>解决方法：可以使用弱引用（Weak Reference）等方式来避免内存泄漏的问题，当单例对象不再被引用时，及时将其回收。另外，也可以使用懒加载（Lazy Loading）等方式来延迟单例对象的实例化，从而减少不必要的内存占用。</p><ol start="3"><li>可能引起多线程竞争：在多线程环境下，单例对象的实例化可能会引起多线程竞争问题，需要考虑线程安全性和可见性的问题。</li></ol><p>解决方法：可以使用同步锁（Synchronized）等技术来保证线程安全性和可见性，从而避免多线程竞争的问题。另外，也可以使用双重检查锁（Double-Checked Locking）等方式来提高单例对象的实例化效率。</p><ol start="4"><li>可能引起单点故障：由于单例对象的唯一性，一旦单例对象出现问题，整个应用程序都会受到影响，可能引起单点故障的问题。</li></ol><p>解决方法：可以使用集群部署等方式来避免单点故障的问题，将单例对象分布在多个节点上，从而提高系统的可用性和稳定性。</p><ol start="5"><li>可能降低代码的可维护性：由于单例模式的实现方式较为复杂，可能会导致代码的可维护性和可读性下降。</li></ol><p>解决方法：可以使用注释、命名规范等方式来提高代码的可读性和可维护性，同时也可以使用设计模式等技术来简化单例模式的实现方式，从而降低代码的复杂度和难度。</p><ol start="6"><li>可能违反单一职责原则：由于单例对象的作用范围比较广泛，可能会违反单一职责原则，使得单例对象承担过多的职责，导致代码的复杂度增加。</li></ol><p>解决方法：可以使用分层架构、模块化设计等方式来分离单例对象的职责，从而避免单例对象承担过多的职责，提高代码的可读性和可维护性。同时也可以使用其他设计模式，如工厂模式、代理模式等来分离职责，避免单例对象承担过多的职责，从而提高代码的可读性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射机制</title>
      <link href="/posts/9dad.html"/>
      <url>/posts/9dad.html</url>
      
        <content type="html"><![CDATA[<h1 id="反射⭐️"><a href="#反射⭐️" class="headerlink" title="反射⭐️"></a>反射⭐️</h1><h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><p><strong>何为反射</strong></p><p>Java的 <strong>反射机制</strong> 是在运行状态中，对于任意一个类，都能够 <strong>知道这个类的所有属性和方法</strong> ；对于任意一个对象，都能够 <strong>调用它的任意一个方法和属性</strong> ；这种 <strong>动态获取的信息以及动态调用对象的方法的功能</strong> 称为 Java 语言的<code>反射机制</code>。</p><p>简而言之，只要你给我一个 <code>.class</code> ——类的名字，我就能通过反射获取到类的属性和方法。<br>反射是很多高级技术的基础，Java 中的注解、动态代理，各种框架注入 Spring 、 MyBatis 等都用到了反射技术。</p><ul><li>Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于 <code>Reflection API</code> 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</li><li>加载完类之后，在堆内存的方法区中就产生了一个 <code>Class</code> 类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li></ul><p>通常的方式：引入需要的“包类”名称—-&gt;通过 <code>new</code> 实例化—-&gt;获得实例化对象</p><p>反射的方式：实例化对象—-&gt; <code>getClass()</code> 方法—-&gt;得到完整的“包类”名称</p><p>框架 &#x3D; 注解 + 反射 + 设计模式</p><h2 id="反射机制⭐️"><a href="#反射机制⭐️" class="headerlink" title="反射机制⭐️"></a>反射机制⭐️</h2><p>Java 的反射机制是指在运行时动态地获取一个类的信息，包括类的方法、属性、构造函数等，并且可以在运行时调用这些方法、访问这些属性。Java 的反射机制提供了一种机制，可以在运行时查看和修改类的属性，调用类的方法，获取类的构造函数等。这种机制使得程序可以实现更高的动态性和灵活性。</p><p>在 Java 中，反射机制的核心类是 <code>Class</code>，它代表了一个类的类型。我们可以通过以下方式获取一个类的 <code>Class</code> 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;  <span class="comment">// 通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 通过对象获取</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>); <span class="comment">// 通过类的全限定名获取</span></span><br></pre></td></tr></table></figure><p>通过 <code>Class</code> 对象，我们可以获取类的各种信息，比如类的方法、属性、构造函数等。以下是一些常用的反射方法：</p><ul><li><code>getMethods()</code>：获取类的所有公共方法。</li><li><code>getDeclaredMethods()</code>：获取类的所有方法，包括私有方法。</li><li><code>getFields()</code>：获取类的所有公共属性。</li><li><code>getDeclaredFields()</code>：获取类的所有属性，包括私有属性。</li><li><code>getConstructors()</code>：获取类的所有公共构造函数。</li><li><code>getDeclaredConstructors()</code>：获取类的所有构造函数，包括私有构造函数。</li><li><code>newInstance()</code>：创建类的一个新实例。</li></ul><p>除了上述方法外，还有许多其他的反射方法可以使用，这些方法提供了对类的各种信息的访问和操作。</p><p>需要注意的是，虽然反射机制可以提供更高的灵活性和动态性，但是在性能方面可能会有些损失。因此，在实际应用中，应该谨慎使用反射机制，避免过度使用导致性能问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366322167-db8450a5-1c34-4063-a983-f6631f60b48d.png#averageHue=%23bbc3b7&clientId=u20550a6b-f5bb-4&from=paste&height=472&id=u954badaf&originHeight=637&originWidth=1412&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=469492&status=done&style=none&taskId=u9b01cd10-e1a8-42b2-b418-88a71dc4f27&title=&width=1045.9259998127973" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366332763-8461ecb9-f2ce-46d8-b750-bd7c30ee73d2.png#averageHue=%238d8f8d&clientId=u20550a6b-f5bb-4&from=paste&height=244&id=u79296ad3&originHeight=330&originWidth=966&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=383622&status=done&style=none&taskId=uf6a7d6d7-9e03-4f76-8b46-eee7daf0581&title=&width=715.5556061042225" alt="image.png"></p><p>Class:代表一个类，Class对象表示某个类加载后在堆中的对象</p><p>Method：代表类的方法</p><p>Field：代表类的成员变量</p><p>Constructor：代表类的构造方法<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366342981-ca08276e-f53a-48bb-85d1-dd5d11083baf.png#averageHue=%23eddfc7&clientId=u20550a6b-f5bb-4&from=paste&height=316&id=u573aa184&originHeight=427&originWidth=801&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=72199&status=done&style=none&taskId=ue18f66ca-269a-4043-b647-21739ef7046&title=&width=593.3333752479111" alt="image.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//根据配置文件指定信息。创建Cat对象并调用</span></span><br><span class="line">        <span class="comment">// 传统方法</span></span><br><span class="line"><span class="comment">//        Cat cat = new Cat();</span></span><br><span class="line"><span class="comment">//        cat.hi();</span></span><br><span class="line">        <span class="comment">//使用Properties类,</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">proerties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        proerties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> proerties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> proerties.get(<span class="string">&quot;method&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//使用反射类</span></span><br><span class="line">        <span class="comment">//1加载类,返回Class类型的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//通过cls对象得到你加载的类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//通过getMethod</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(method);</span><br><span class="line">        <span class="comment">//通过方法对象来实现方法调用</span></span><br><span class="line">        method1.invoke(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="反射调用性能优化"><a href="#反射调用性能优化" class="headerlink" title="反射调用性能优化"></a>反射调用性能优化</h2><h3 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h3><p>优点：以实现运行时动态创建对象，增加程序的灵活性</p><p>缺点：反射操作的效率要比正常操作效率低很多</p><h3 id="反射调用优化-关闭访问检查"><a href="#反射调用优化-关闭访问检查" class="headerlink" title="反射调用优化-关闭访问检查"></a>反射调用优化-关闭访问检查</h3><ol><li>Method和Filed、Constructor对象都有setAccessible()方法</li><li>setAccessible作用是启动和禁用访问安全检查的开关</li><li>参数为true表示反射的对象在使用时取消访问检查，提高反射的效率。为false则表示反射的对象执行访问检查</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field</span></span><br><span class="line">        <span class="comment">//Method</span></span><br><span class="line">        <span class="comment">//Constructor</span></span><br><span class="line">        m1();</span><br><span class="line">        m2();</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法来调用hi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">90</span>; i++) &#123;</span><br><span class="line">            cat.hi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1() 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射机制调用方法hi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            hi.invoke(o);<span class="comment">//反射调用方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2() 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射调用优化 + 关闭访问检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        hi.setAccessible(<span class="literal">true</span>);<span class="comment">//在反射调用方法时，取消访问检查</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            hi.invoke(o);<span class="comment">//反射调用方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;m3() 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Class类⭐️"><a href="#Class类⭐️" class="headerlink" title="Class类⭐️"></a>Class类⭐️</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366360339-d404cce6-83a1-46b2-8865-e5bc2a0543fd.png#averageHue=%236f7168&clientId=u20550a6b-f5bb-4&from=paste&height=476&id=u5c74c831&originHeight=643&originWidth=1136&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=701662&status=done&style=none&taskId=ub5e4de68-9404-4d8a-9871-b42e649bbf8&title=&width=841.4815409258765" alt="image.png"></p><h3 id="获得Class对象的6种方式"><a href="#获得Class对象的6种方式" class="headerlink" title="获得Class对象的6种方式"></a>获得Class对象的6种方式</h3><ol><li>前提：已知一个类的全类名，且该类在类路径下，可以通过Class类的静态方法forName()获取</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName()</span><br></pre></td></tr></table></figure><ol><li>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类.class</span><br></pre></td></tr></table></figure><ol><li>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象.getClass();</span><br></pre></td></tr></table></figure><ol><li>其他方式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> 对象.getClass().getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">class4</span> <span class="operator">=</span> cl.loadClass(“类的全类名”);</span><br></pre></td></tr></table></figure><ol start="5"><li>基本数据类型(int char boolean float double byte long short)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> 基本数据类型.class</span><br></pre></td></tr></table></figure><ol start="6"><li>基本数据类型对应的包装类，可以通过.TYPE得到Class对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> 包装类.TYPE</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. Class.forName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.hspedu.Car&quot;</span>; <span class="comment">//通过读取配置文件获取</span></span><br><span class="line">        Class&lt;?&gt; cls1 = Class.forName(classAllPath);</span><br><span class="line">        System.out.println(cls1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 类名.class , 应用场景: 用于参数传递</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Car.class;</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 对象.getClass(), 应用场景，有对象实例</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> car.getClass();</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 通过类加载器【4种】来获取到类的Class对象</span></span><br><span class="line">        <span class="comment">//(1)先得到类加载器 car</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//(2)通过类加载器得到Class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls4</span> <span class="operator">=</span> classLoader.loadClass(classAllPath);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cls1 , cls2 , cls3 , cls4 其实是同一个对象</span></span><br><span class="line">        System.out.println(cls1.hashCode());</span><br><span class="line">        System.out.println(cls2.hashCode());</span><br><span class="line">        System.out.println(cls3.hashCode());</span><br><span class="line">        System.out.println(cls4.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class类对象</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">        Class&lt;Character&gt; characterClass = <span class="type">char</span>.class;</span><br><span class="line">        Class&lt;Boolean&gt; booleanClass = <span class="type">boolean</span>.class;</span><br><span class="line">        System.out.println(integerClass);<span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 基本数据类型对应的包装类，可以通过 .TYPE 得到Class类对象</span></span><br><span class="line">        Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">        Class&lt;Character&gt; type2 = Character.TYPE; <span class="comment">//其它包装类BOOLEAN, DOUBLE, LONG,BYTE等待</span></span><br><span class="line">        System.out.println(type1);</span><br><span class="line"></span><br><span class="line">        System.out.println(integerClass.hashCode());<span class="comment">//?</span></span><br><span class="line">        System.out.println(type1.hashCode());<span class="comment">//?</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="哪些类型有Class对象"><a href="#哪些类型有Class对象" class="headerlink" title="哪些类型有Class对象"></a>哪些类型有Class对象</h3><ol><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;String&gt; cls1 = String.class;<span class="comment">//外部类</span></span><br><span class="line">        Class&lt;Serializable&gt; cls2 = Serializable.class;<span class="comment">//接口</span></span><br><span class="line">        Class&lt;Integer[]&gt; cls3 = Integer[].class;<span class="comment">//数组</span></span><br><span class="line">        Class&lt;<span class="type">float</span>[][]&gt; cls4 = <span class="type">float</span>[][].class;<span class="comment">//二维数组</span></span><br><span class="line">        Class&lt;Deprecated&gt; cls5 = Deprecated.class;<span class="comment">//注解</span></span><br><span class="line">        <span class="comment">//枚举</span></span><br><span class="line">        Class&lt;Thread.State&gt; cls6 = Thread.State.class;</span><br><span class="line">        Class&lt;Long&gt; cls7 = <span class="type">long</span>.class;<span class="comment">//基本数据类型</span></span><br><span class="line">        Class&lt;Void&gt; cls8 = <span class="keyword">void</span>.class;<span class="comment">//void数据类型</span></span><br><span class="line">        Class&lt;Class&gt; cls9 = Class.class;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line">        System.out.println(cls5);</span><br><span class="line">        System.out.println(cls6);</span><br><span class="line">        System.out.println(cls7);</span><br><span class="line">        System.out.println(cls8);</span><br><span class="line">        System.out.println(cls9);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.hspedu.Car&quot;</span>;</span><br><span class="line">    <span class="comment">//1 . 获取到Car类 对应的 Class对象</span></span><br><span class="line">    <span class="comment">//&lt;?&gt; 表示不确定的Java类型</span></span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">    <span class="comment">//2. 输出cls</span></span><br><span class="line">    System.out.println(cls); <span class="comment">//显示cls对象, 是哪个类的Class对象 com.hspedu.Car</span></span><br><span class="line">    System.out.println(cls.getClass());<span class="comment">//输出cls运行类型 java.lang.Class</span></span><br><span class="line">    <span class="comment">//3. 得到包名</span></span><br><span class="line">    System.out.println(cls.getPackage().getName());<span class="comment">//包名</span></span><br><span class="line">    <span class="comment">//4. 得到全类名</span></span><br><span class="line">    System.out.println(cls.getName());</span><br><span class="line">    <span class="comment">//5. 通过cls创建对象实例</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) cls.newInstance();</span><br><span class="line">    System.out.println(car);<span class="comment">//car.toString()</span></span><br><span class="line">    <span class="comment">//6. 通过反射获取属性 brand</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">    System.out.println(brand.get(car));<span class="comment">//宝马</span></span><br><span class="line">    <span class="comment">//7. 通过反射给属性赋值</span></span><br><span class="line">    brand.set(car, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">    System.out.println(brand.get(car));<span class="comment">//奔驰</span></span><br><span class="line">    <span class="comment">//8 我希望大家可以得到所有的属性(字段)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;=======所有的字段属性====&quot;</span>);</span><br><span class="line">    Field[] fields = cls.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        System.out.println(f.getName());<span class="comment">//名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对Class类特点的梳理"><a href="#对Class类特点的梳理" class="headerlink" title="对Class类特点的梳理"></a>对Class类特点的梳理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="comment">//看看Class类图</span></span><br><span class="line">       <span class="comment">//1. Class也是类，因此也继承Object类</span></span><br><span class="line">       <span class="comment">//Class</span></span><br><span class="line">       <span class="comment">//2. Class类对象不是new出来的，而是系统创建的</span></span><br><span class="line">       <span class="comment">//(1) 传统new对象</span></span><br><span class="line">       <span class="comment">/*  ClassLoader类</span></span><br><span class="line"><span class="comment">           public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">               return loadClass(name, false);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//Cat cat = new Cat();</span></span><br><span class="line">       <span class="comment">//(2) 反射方式, 刚才老师没有debug到 ClassLoader类的 loadClass, 原因是，我没有注销Cat cat = new Cat();</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           ClassLoader类, 仍然是通过 ClassLoader类加载Cat类的 Class对象</span></span><br><span class="line"><span class="comment">           public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line"><span class="comment">               return loadClass(name, false);</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3. 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Cat&quot;</span>);</span><br><span class="line">       System.out.println(cls1.hashCode());</span><br><span class="line">       System.out.println(cls2.hashCode());</span><br><span class="line">       <span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.hspedu.Dog&quot;</span>);</span><br><span class="line">       System.out.println(cls3.hashCode());</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="类加载⭐️"><a href="#类加载⭐️" class="headerlink" title="类加载⭐️"></a>类加载⭐️</h2><h3 id="创建类的对象的方式"><a href="#创建类的对象的方式" class="headerlink" title="创建类的对象的方式"></a>创建类的对象的方式</h3><p>方式一：new + 构造器</p><p>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。</p><p>方式三：通过反射</p><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态类加载</p><ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不使用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><ul><li>类加载时机</li></ul><ol><li>当创建对象时（new）   静态加载</li><li>当子类被加载时，父类也加载   静态加载</li><li>调用类中的静态成员    静态加载</li><li>通过反射     动态加载</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366371294-99b52e60-372d-4e96-8692-2ff527f39e3d.png#averageHue=%232b2b25&clientId=u20550a6b-f5bb-4&from=paste&height=424&id=u1ba7e44b&originHeight=572&originWidth=1094&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=269677&status=done&style=none&taskId=u08f18424-0437-4c80-a749-f657c9fe766&title=&width=810.3704276169973" alt="image.png"></p><ul><li>类加载过程图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366383058-9af2d949-3f2f-4904-b6d4-873518b4478d.png#averageHue=%23a2b0ab&clientId=u20550a6b-f5bb-4&from=paste&height=654&id=u0219af9a&originHeight=883&originWidth=1700&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=771910&status=done&style=none&taskId=ud3351cbb-e8f8-46e4-b73c-4b9e230a45d&title=&width=1259.2593482165405" alt="image.png"></p><ul><li>类加载各阶段完成任务</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366399092-7a3648d2-6d95-4504-8e91-44544e1e1691.png#averageHue=%238f9494&clientId=u20550a6b-f5bb-4&from=paste&height=753&id=uab37c558&originHeight=1016&originWidth=1959&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=1520729&status=done&style=none&taskId=ue1d70466-0cdc-447d-9341-ebc2f517765&title=&width=1451.111213621296" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366407886-d62f9e50-0c23-4f75-9a98-7e7f753cc938.png#averageHue=%23e5e8b7&clientId=u20550a6b-f5bb-4&from=paste&height=254&id=uc6d52e51&originHeight=343&originWidth=1348&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=156451&status=done&style=none&taskId=u381126aa-d602-4593-a1df-d9b753b650c&title=&width=998.5185890564098" alt="image.png"></p><h3 id="加载阶段Loading"><a href="#加载阶段Loading" class="headerlink" title="加载阶段Loading"></a>加载阶段<strong>Loading</strong></h3><blockquote><p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p></blockquote><p><code>Loading</code> 就是把一个class文件装到内存中，它本来是class文件上一个个的二进制，一个个字节，通过Loading把它放到内存。<br>在加载阶段，Java 虚拟机需要完成以下工作：</p><p>通过类的全限定名获取类的二进制字节流。<br>将字节流转化为内部数据结构，并在内存中创建一个 java.lang.Class 对象来代表这个类。<br>在内存中为该类创建一个 java.lang.ClassLoader 对象，用于在后续的连接和初始化阶段使用。</p><h3 id="连接阶段—验证verification"><a href="#连接阶段—验证verification" class="headerlink" title="连接阶段—验证verification"></a>连接阶段—验证verification</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证（是否以魔数 oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</li><li>可以考虑使用 -Xverify：none 参数来关闭绝大部分的验证措施，缩短虚拟机类加载的时间</li></ol><h3 id="连接阶段—准备preparation"><a href="#连接阶段—准备preparation" class="headerlink" title="连接阶段—准备preparation"></a>连接阶段—准备preparation</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化(对应数据类型的默认初始化值如0 0L null false等)。这些变量所使用的内存都将在方法区中进行分配</p><p>把class文件静态变量赋默认值，不是赋初始值。比如 <code>static int i = 8</code> ，在该步骤只是把i赋了默认值0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//属性-成员变量-字段</span></span><br><span class="line">    <span class="comment">//老韩分析类加载的链接阶段-准备 属性是如何处理</span></span><br><span class="line">    <span class="comment">//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line">    <span class="comment">//2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是20</span></span><br><span class="line">    <span class="comment">//3. n3 是static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接阶段—解析resolution"><a href="#连接阶段—解析resolution" class="headerlink" title="连接阶段—解析resolution"></a>连接阶段—解析resolution</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>把class文件常量池里面用到的符号引用，把它转成直接内存地址，可以访问到的内容。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这一步就是将静态变量赋初始值，比如上面的 <code>static int i = 8</code> ，在这一步才赋初始值8。</p><ol><li>到初始化阶段，才真正开始执行类中定义的java程序代码，此阶段是执行()方法的过程</li><li>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值待做和静态代码块中的语句，并进行合并</li><li>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，知道活动线程执行()方法完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoad03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//老韩分析</span></span><br><span class="line">        <span class="comment">//1. 加载B类，并生成 B的class对象</span></span><br><span class="line">        <span class="comment">//2. 链接 num = 0</span></span><br><span class="line">        <span class="comment">//3. 初始化阶段</span></span><br><span class="line">        <span class="comment">//    依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句,并合并</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                clinit() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;B 静态代码块被执行&quot;);</span></span><br><span class="line"><span class="comment">                    //num = 300;</span></span><br><span class="line"><span class="comment">                    num = 100;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                合并: num = 100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new B();//类加载</span></span><br><span class="line">        <span class="comment">//System.out.println(B.num);//100, 如果直接使用类的静态属性，也会导致类的加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//看看加载类的时候，是有同步机制控制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span></span><br><span class="line"><span class="comment">        throws ClassNotFoundException</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //正因为有这个机制，才能保证某个类在内存中, 只有一份Class对象</span></span><br><span class="line"><span class="comment">            synchronized (getClassLoadingLock(name)) &#123;</span></span><br><span class="line"><span class="comment">            //....</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 静态代码块被执行&quot;</span>);</span><br><span class="line">        num = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B() 构造器被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，类的初始化是由 Java 虚拟机负责的，并且只会在以下情况下进行：</p><ul><li>创建类的实例。</li><li>访问类的静态变量。</li><li>调用类的静态方法。</li><li>使用反射方式对类进行操作。</li><li>初始化类的子类。</li><li>执行 Java 应用程序的 main 方法。</li></ul><h2 id="反射获取类的结构信息⭐️"><a href="#反射获取类的结构信息⭐️" class="headerlink" title="反射获取类的结构信息⭐️"></a>反射获取类的结构信息⭐️</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ol><li>getName:获取全类名</li><li>getSimpleName:获取简单类名</li><li>getFields:获取所有public修饰的属性，包含本类以及父类的(只能得到public)</li><li>getDeclaredFields:获取本类中所有属性</li><li>getMethods:获取所有public修饰的方法，包含本类以及父类的</li><li>getDeclaredMethods:获取本类中所有方法</li><li>getConstructors: 获取所有public修饰的构造器，包含本类</li><li>getDeclaredConstructors:获取本类中所有构造器</li><li>getPackage:以Package形式返回包信息</li><li>getSuperClass:以Class形式返回父类信息</li><li>getInterfaces:以Class[]形式返回接口信息</li><li>getAnnotations:以Annotation[] 形式返回注解信息</li></ol><h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Field[] getFields()</span><br></pre></td></tr></table></figure><p>返回此 <code>Class</code> 对象所表示的类或接口的 <code>public</code> 的 <code>Field</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Field[] getDeclaredFields()</span><br></pre></td></tr></table></figure><p>返回此 <code>Class</code> 对象所表示的类或接口的全部 <code>Field</code></p><ol><li>getModifiers：以int形式返回修饰符</li></ol><p>[说明：默认修饰符是0 public：1 private：2 protected：4 static：8 final：16</p><p>public + static &#x3D; 9</p><p>]</p><ol start="2"><li>getType：以Class形式返回类型</li><li>getName：返回属性名</li></ol><p><strong>[获取属性Field]</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiledTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//获取属性结构</span></span><br><span class="line">        <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             fields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限修饰符  数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifiers)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = f.getType();</span><br><span class="line">            System.out.print(type.getName()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">            System.out.print(fName);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ol><li>getModifiers：以int形式返回修饰符</li></ol><p>[说明：默认修饰符是0 public：1 private：2 protected：4 static：8 final：16</p><p>public + static &#x3D; 9</p><p>]</p><ol start="2"><li>geReturntType：以Class形式获取 返回类型</li><li>getName：返回方法名</li><li>getParameterTypes：以Class[]返回参数类型数组</li></ol><p><strong>获取方法 Method</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getMethods():获取当前运行时类及其所有父类中声明为public权限的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             methods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</span></span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Xxxx</span></span><br><span class="line"><span class="comment">    权限修饰符  返回值类型  方法名(参数类型1 形参名1,...) throws XxxException&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            <span class="comment">//1.获取方法声明的注解</span></span><br><span class="line">            Annotation[] annos = m.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation a :</span><br><span class="line">                 annos) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.权限修饰符</span></span><br><span class="line">            System.out.print(Modifier.toString(m.getModifiers())+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.返回值类型</span></span><br><span class="line">            System.out.print(m.getReturnType().getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.方法名</span></span><br><span class="line">            System.out.print(m.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.形参列表</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (!(parameterTypes == <span class="literal">null</span> &amp;&amp; parameterTypes.length == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == parameterTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(parameterTypes[i].getName() + <span class="string">&quot;args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.抛出的异常</span></span><br><span class="line">            Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span> (exceptionTypes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;throws &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exceptionTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==exceptionTypes.length -<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(exceptionTypes[i].getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><ol><li>getModifiers:以int形式返回修饰符</li><li>getName：返回方法名(全类名)</li><li>getParameterTypes：以Class[]返回参数类型数组</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//得到Class对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.hspedu.reflection.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        <span class="comment">//规定 说明: 默认修饰符 是0 ， public  是1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                    + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                    + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一组方法API</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到Class对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;com.hspedu.reflection.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//getName:获取全类名</span></span><br><span class="line">        System.out.println(personCls.getName());<span class="comment">//com.hspedu.reflection.Person</span></span><br><span class="line">        <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">        System.out.println(personCls.getSimpleName());<span class="comment">//Person</span></span><br><span class="line">        <span class="comment">//getFields:获取所有public修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = personCls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getMethods:获取所有public修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getConstructors: 获取所有public修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getPackage:以Package形式返回 包信息</span></span><br><span class="line">        System.out.println(personCls.getPackage());<span class="comment">//com.hspedu.reflection</span></span><br><span class="line">        <span class="comment">//getSuperClass:以Class形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的class对象=&quot;</span> + superclass);<span class="comment">//</span></span><br><span class="line">        <span class="comment">//getInterfaces:以Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getAnnotations:以Annotation[] 形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span>, IB &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">int</span> age; <span class="comment">// 4 + 8 = 12</span></span><br><span class="line">    String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> sal)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h3><ol><li>调用类中的public修饰的无参构造器</li><li>调用类中的指定构造器</li><li>Class类相关方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* newInstance：调用类中的无参构造器，获取对应类的对象</span><br><span class="line">* getConstructor(Class…clazz):根据参数列表，获取对应的<span class="keyword">public</span>构造器对象</span><br><span class="line">* getDecalaredConstructor(Class…clazz):根据参数列表，获取对应的所有构造器对象</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.javasm.practise.Student&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> aClass.newInstance();</span><br></pre></td></tr></table></figure><ol start="4"><li>Constructor类相关方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* setAccessible:爆破</span><br><span class="line">* newInstance(Object…obj):调用构造器</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步骤1 取得.class文件</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.java.practise.Student&quot;</span>);</span><br><span class="line"><span class="comment">//步骤2 取得当前文件的带参数的构造函数</span></span><br><span class="line">Constructor&lt;?&gt; declaredConstructor1 = aClass.getDeclaredConstructor(Car.class,String.class);</span><br><span class="line"><span class="comment">//步骤3 实例化 此处应注意用构造函数进行实例化而不是.class文件，因为.class文件进行实例只是利用无参构造。并且需要在此处进行初始化赋值，而不是在前一步初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">newInstance</span> <span class="operator">=</span> declaredConstructor1.newInstance(o1, <span class="string">&quot;小明&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h2><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>在反射机制中，可以直接通过 <code>Field</code> 类操作类中的属性，通过 <code>Field</code> 类提供的 <code>set()</code> 和<code>get()</code> 方法就可以完成设置和取得属性内容的操作。</p><ul><li><code>public Field getField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>public</code> 的 <code>Field</code>。 </li><li><code>public Field getDeclaredField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>Field</code>。<br>在 <code>Field</code> 中: </li><li><code>public Object get(object obj)</code> 取得指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容 </li><li><code>public void set(Object obj,Object value)</code> 设置指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容</li></ul><ol><li>根据属性名获取Field对相关</li></ol><p>Field f &#x3D; clazz对象.getDeclaredField(属性名);</p><ol start="2"><li>爆破：f.setAccessible(true); &#x2F;&#x2F;f是Field</li><li>访问</li></ol><p>f.set(o,值)；&#x2F;&#x2F;o是对象</p><p>syso(f.get(o));</p><ol start="4"><li>注意：如果是静态属性，则set和get中的参数o，可以写成null</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>通过反射，调用类中的方法，通过 <code>Method</code> 类完成。步骤:</p><ol><li>通过 <code>Class</code> 类的 <code>getMethod(String name,Class… parameterTypes)</code> 方法取得一个 <code>Method</code> 对象，并设置此方法操作时所需要的参数类型。 </li><li>之后使用 <code>Object invoke(Object obj， Object[] args)</code> 进行调用，并向方法中传递要设置的 <code>obj</code> 对象的参数信息。 </li><li>根据方法名和参数列表获取Method方法对象：Method m &#x3D; clazz.getDeclaredMethod(方法名,xx.class);&#x2F;&#x2F;得到本类的所有方法 </li><li>获取对象：Object o &#x3D; clazz.newInstance(); </li><li>爆破：m.setAccessible(true);</li></ol><blockquote><p><strong>关于 setAccessible 方法的使用：</strong></p><ul><li><code>Method</code> 和 <code>Field</code>、<code>Constructor</code> 对象都有 <code>setAccessible()</code> 方法。</li><li><code>setAccessible</code> 是启动和禁用访问安全检查的开关</li><li>参数值为 <code>true</code> 则指示反射的对象在使用时应该取消 Java 语言访问检査。</li><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true. 使得原本无法访问的私有成员也可以访问</li><li>参数值为 <code>false</code> 则指示反射的对象应该实施 Java 语言访问检査。</li></ul></blockquote><ol start="4"><li>访问：Object retutnValue &#x3D; m.invoke(o,实参列表)；</li></ol><blockquote><p><strong>Object invoke(object obj,Object… args)方法：</strong></p><ol><li><code>Object</code> 对应原方法的返回值，若原方法无返回值，此时返回 <code>null</code></li><li>若原方法若为静态方法，此时形参 <code>Object obj</code> 可为 <code>null</code></li><li>若原方法形参列表为空，则 <code>Object[] args</code> 为 <code>null</code></li><li>若原方法声明为 <code>private</code>，则需要在调用此 <code>invoke()</code> 方法前，显式调用方法对象的 <code>setAccessible(true)</code> 方法，将可访问 <code>private</code> 的方法。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(person, <span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的构造器</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式简介</title>
      <link href="/posts/c44e.html"/>
      <url>/posts/c44e.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="设计模式的产生背景"><a href="#设计模式的产生背景" class="headerlink" title="设计模式的产生背景"></a>设计模式的产生背景</h2><p>软件设计模式的产生背景可以追溯到20世纪60年代和70年代，当时计算机软件行业开始迅速发展。随着软件规模的不断扩大，软件开发人员发现传统的软件设计方法已经无法满足需求，因为它们缺乏可重用性、可维护性和可扩展性。<br>在这种情况下，一些软件开发专家开始研究如何通过规范化软件开发过程来解决这些问题。他们提出了一些通用的设计思想和解决方案，这些思想和方案被称为“设计模式”。<br>设计模式是指在软件开发中经常遇到的⼀些重复性问题，通过对这些问题的总结、抽象、归纳和提炼，得到的⼀些<br>解决问题的通⽤⽅案。<br>学习和使⽤设计模式可以帮助开发⼈员提⾼代码的可重⽤性、可维护性、可扩展性和可读性，从⽽提⾼开发效率和<br>代码质量。<br>设计模式分为三⼤类：</p><ul><li>创建型模式：共5种：⼯⼚⽅法模式、抽象⼯⼚模式、单例模式、建造者模式、原型模式</li><li>结构型模式：共7种：适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式</li><li>⾏为型模式：共11种：策略模式、模板⽅法模式、观察者模式、责任链模式、访问者模式、中介者模式、迭代器模式、命令模式、状态模式、备忘录模式、解释器模式</li></ul><h2 id="学习设计模式的必要性"><a href="#学习设计模式的必要性" class="headerlink" title="学习设计模式的必要性"></a>学习设计模式的必要性</h2><p>学习设计模式对于软件开发人员来说是非常必要的，因为：</p><ol><li>提高代码质量：设计模式可以提高代码的可重用性、可维护性和可扩展性，从而提高代码的质量。 </li><li>减少开发时间：通过使用设计模式，开发人员可以更快地开发出高质量的软件，因为他们不需要从头开始编写每个功能。 </li><li>降低错误率：设计模式可以帮助开发人员避免一些常见的编程错误，例如类的继承关系不清晰、代码重复等。 </li><li>提高团队协作效率：设计模式可以使团队成员更容易地理解和共享代码，从而提高团队的协作效率。 </li><li>增强软件的可读性和可维护性：设计模式可以使代码更易于阅读和维护，因为它们提供了一种通用的方法来解决特定的问题。</li></ol><p>总之，学习设计模式可以帮助开发人员更好地理解软件开发的本质和原理，提高他们的技能水平和工作效率，从而更好地应对日益复杂的软件开发挑战。</p><h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><p>设计模式有几个原则，其中比较著名的有 SOLID 原则、GRASP 原则、KISS 原则和 DRY 原则等。以下是这些原则的简要介绍：</p><ol><li>SOLID原则：SOLID 原则是一组面向对象设计的基本原则，包括单一职责原则、开放封闭原则、里氏替换原则、接口隔离原则和依赖倒置原则等。这些原则可以帮助开发人员编写更加灵活、可扩展和可维护的代码。 </li><li>GRASP原则：GRASP 原则是一组面向对象设计的准则，包括高内聚、低耦合、专注点、创造者、信息专家、纯粹制造者、多态性和保持简单等。这些原则可以帮助开发人员更好地理解和设计系统架构。 </li><li>KISS原则：KISS 原则是一种简单性原则，即“保持简单和直接”。这个原则的核心思想是，设计应该保持简单和直接，避免过度复杂化和过度设计。这样可以提高代码的可读性、可维护性和可重用性。 </li><li>DRY原则：DRY 原则是一种“不要重复自己”的原则，即相同的代码不应该重复出现在不同的地方。这个原则可以提高代码的可维护性和可重用性，避免重复的劳动和错误。</li></ol><p>这些原则都是在面向对象编程中非常重要的指导原则，可以帮助开发人员编写更加高质量、可维护和可重用的代码。它们不仅适用于设计模式的使用，也适用于其他编程范式和技术的开发过程中。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>单一职责原则</strong>（Single Responsibility Principle，SRP）是SOLID原则中的一条，指一个类或模块应该只有一个责任。具体来说，就是<strong>一个类或模块只负责一项功能或职责，不承担过多的职责</strong>，以提高其内聚性和可维护性。<br>单一职责原则的核心思想是将不同的职责分离开来，避免一个类或模块承担过多的职责，导致代码混乱、难以维护和扩展。如果一个类或模块承担了过多的职责，那么它就会变得臃肿、复杂、难以测试和修改。相反，如果每个类或模块只负责一项职责，那么它就会变得简单、清晰、易于理解和修改。<br>在实践中，如何判断一个类或模块是否遵循单一职责原则呢？可以通过以下几点来判断：</p><ol><li><strong>类或模块的职责是否明确</strong>：一个类或模块应该有一个明确的职责，而不是承担多个职责。如果一个类或模块有多个职责，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的方法数量是否合理</strong>：一个类或模块的方法数量应该与其职责相匹配。如果一个类或模块有大量的方法，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的复杂度是否合理</strong>：一个类或模块的复杂度应该与其职责相匹配。如果一个类或模块过于复杂，那么就需要考虑将其分解成多个类或模块。 </li><li><strong>类或模块的修改频率是否合理</strong>：一个类或模块的修改频率应该与其职责相匹配。如果一个类或模块经常需要修改，那么就需要考虑将其分解成多个类或模块。</li></ol><p>单一职责原则是面向对象编程中非常重要的原则之一，它可以提高代码的内聚性、可维护性和可扩展性。一个类或模块只负责一项职责，可以使它的职责更加明确、方法数量更加合理、复杂度更加合理、修改频率更加合理，从而使代码更加简单、清晰、易于理解和修改。在实践中，开发人员应该尽可能遵循单一职责原则，将不同的职责分离开来，避免一个类或模块承担过多的职责，导致代码难以维护和扩展。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>开闭原则</strong>(<strong>Open Closed Principle</strong>,<strong>OCP</strong>)是面向对象设计中的一项基本原则，它的核心思想是：对于一个软件实体(类、模块、函数等),应该<strong>对扩展开放，对修改关闭</strong>。<br>具体来说，开闭原则包括以下两点：</p><ol><li><strong>对扩展开放</strong>(Open for Extension):一个软件实体应该对新的功能或需求开放，也就是说，如果需要增加新的功能，应该通过添加新的方法、属性或者类来实现，而不是修改原有代码。这样可以保证代码的可扩展性和灵活性，同时也方便了维护和升级。 </li><li><strong>对修改封闭</strong>(Closed for Modification):一个软件实体不应该被修改，也就是说，如果需要修改已有的功能或需求，应该通过创建新的类、方法或者属性来实现，而不是修改原有代码。这样可以避免代码的不一致性和耦合性，提高了代码的可维护性和稳定性。</li></ol><p>开闭原则可以帮助开发人员编写出易于扩展和维护的高质量代码，同时也符合面向对象编程的基本原则之一——封装。通过遵循开闭原则，开发人员可以更好地管理软件实体的变化，使得系统更加健壮、可靠和可维护。</p><h2 id="里式替换原则📍"><a href="#里式替换原则📍" class="headerlink" title="里式替换原则📍"></a>里式替换原则📍</h2><p><strong>里式替换原则</strong>(Liskov Substitution Principle,LSP)是面向对象设计中的一项基本原则。<br><strong>通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</strong><br>由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h2 id="依赖倒装原则"><a href="#依赖倒装原则" class="headerlink" title="依赖倒装原则"></a>依赖倒装原则</h2><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节，细节应该依赖抽象；</li><li>依赖倒装的中心思想就是：面向接口编程；<blockquote><p><a href="https://blog.csdn.net/weixin_39327556/article/details/125250988?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%BE%9D%E8%B5%96%E5%80%92%E8%A3%85%E5%8E%9F%E5%88%99&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-125250988.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">引用例子原文</a></p></blockquote></li></ul><p>场景：人们之间的沟通方式（电话、微信）</p><ul><li>错误设计（新增要修改代码，不好维护）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684569254312-87c9fd29-c94c-431c-ba35-9ccf4b39adc7.png#averageHue=%23fcfcfc&clientId=u03d49c43-b92a-4&from=paste&height=293&id=ue8eb6ba7&originHeight=396&originWidth=617&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=25308&status=done&style=none&taskId=u390229fd-9f33-45ac-b535-2270251f042&title=&width=457.0370693232974" alt="image.png"></p><ul><li>正确设计</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684569296519-f7c9e6dc-77aa-42f8-b91c-9c15fcc58d2f.png#averageHue=%23fcfbf9&clientId=u03d49c43-b92a-4&from=paste&id=ue276833a&originHeight=633&originWidth=782&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=35508&status=done&style=none&taskId=uf459a998-33df-4aa9-9f4c-04e60d61b70&title=" alt="image.png"></p><ul><li>peison类属于高层模块，不应该依赖于低层模块，而是要依赖于抽象。</li><li>细节（Email、Weixin）依赖抽象（IReciver）。</li></ul><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。<br><strong>每一个接口应该承担一种相对独立的角色，不干不该干的事情，干该干的事请。</strong><br><strong>在使用接口隔离原则时我们要控制接口的颗粒度，颗粒度不能太大，也不能太小。如果太小就会造成接口泛滥，不利于维护；接口入如果太大就会违背接口隔离原则，灵活性较差，使用起来不方便</strong>。一般来说接口中仅包含某业务模块的方法即可，不应该有其他业务模块的方法。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote><p><a href="https://blog.csdn.net/qq_34222160/article/details/123539464?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168456952816782425178194%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168456952816782425178194&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123539464-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99&spm=1018.2226.3001.4187">原文</a></p></blockquote><p>迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少的与其他实体发生相互作用。<br>如果一个系统满足迪米特法则，那么当其中一个软件实体发生变化时，就会尽量少的影响其他软件实体，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可以降低系统的耦合度，使类与类之间保持松耦合状态</strong>。<br>迪米特法则还有几种定义形式，包括：不要和”陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><ul><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。</li><li>当前对象创建的对象</li></ul><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则（Composition Over Inheritance，COI）是面向对象编程中的一个原则，它强调使用组合（Composition）而不是继承（Inheritance）来实现代码的复用。<br><strong>合成&#x2F;聚合复用原则是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的</strong>。<br>简述为：<strong>要尽量使用合成&#x2F;聚合，尽量不要使用继承</strong>。</p><ul><li>聚合has-A</li><li>组合contains-A</li><li>继承is-A</li></ul><p>具体来说，合成复用原则可以通过以下几点来实现：</p><ol><li>将类的<strong>功能分解</strong>为较小的粒度：将类的功能分解为较小的粒度，每个类只负责一项职责，这样可以提高代码的内聚性和可维护性。 </li><li>使用<strong>组合</strong>来实现代码复用：根据需要，将现有类的实例组合起来创建新的功能。这样可以使代码更加灵活、可扩展和可维护，同时避免了继承带来的一些问题。 </li><li><strong>优先使用接口</strong>而不是实现类：在使用组合时，优先使用接口而不是实现类。这样可以使代码更加灵活、可扩展和可维护，同时避免了依赖具体实现类带来的一些问题（如紧耦合、难以替换等）。 </li><li><strong>避免过度设计</strong>：在使用组合时，避免过度设计。只有当需要复用的功能足够复杂时才使用组合，否则可以直接在当前类中实现。过度设计会增加代码的复杂性和维护成本。</li></ol><p>合成复用原则是面向对象编程中非常重要的原则之一，它可以提高代码的灵活性、可扩展性和可维护性。使用组合而不是继承来实现代码的复用，可以避免继承带来的一些问题，如紧耦合、派生类的脆弱性等。在实践中，开发人员应该尽可能遵循合成复用原则，将现有的类组合起来创建新的功能，同时避免过度设计和依赖具体实现类，从而使代码更加灵活、可扩展和可维护。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/43de.html"/>
      <url>/posts/43de.html</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。<br>JDK1.8和之前的版本略有不同，我们这里以JDK1.7和JDK1.8这两个版本为例介绍。<br>JDK1.7<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549410036-90c7236d-8a09-496b-8c48-d7a6adea79ab.png?x-oss-process=image/resize,w_1068,limit_0#averageHue=%23cfe7de&from=url&id=dVixk&originHeight=1121&originWidth=1068&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>JDK1.8<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683549564819-26518ebd-f88c-4093-ba31-fea1211758e9.png#averageHue=%23c4e3da&from=url&id=mgiKA&originHeight=905&originWidth=701&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>程私有的</strong>：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的</strong>：</p><ul><li>堆</li><li>方法区</li><li>直接内存（非运行时数据的一部分）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683550157412-b0e7c7e8-13df-4cf1-ae46-6393d80d39b8.png#averageHue=%23f8e6b1&from=url&id=JJ8cx&originHeight=882&originWidth=569&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。无内存溢出问题<br>作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -verbose  xx.class    打印堆栈大小，局部变量的数量和方法的参数。</span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685362513499-e524c1c6-8e59-4676-b91c-346cd9752be2.png#averageHue=%23faf9f9&clientId=ufdf2cef5-e05b-4&from=paste&height=558&id=u96396e65&originHeight=753&originWidth=1393&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=270328&status=done&style=none&taskId=ua9ab6d6a-a6c2-46b1-adba-b483d866982&title=&width=1031.8519247444947" alt="image.png"><br>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。<br>那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。<br>程序计数器是JVM规范中唯一一个没有规定出现OOM（<code>OutOfMemoryError</code>）的区域，所以这个空间也不会进行GC。</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>线程私有，描述Java方法的执行过程<br>Java Virtual machine Stacks (java 虚拟机栈)</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈，先进后出 </li><li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存 </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685363455154-0bfc17d8-1f56-487a-9982-56a8ad338bba.png#averageHue=%23f3fcf5&clientId=ucd8db9d2-4e00-4&from=paste&id=u174eb4db&originHeight=551&originWidth=451&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=31578&status=done&style=none&taskId=uc7a35740-62cf-4b91-b08a-5cd6f1061ec&title=" alt="image.png"><br><strong>局部变量表</strong>：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。<br><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。<br><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685363640509-2f4a82de-adae-4e5f-82ab-89ac3beaed6d.png#averageHue=%23d5d5d5&clientId=ucd8db9d2-4e00-4&from=paste&id=u7c60c1b5&originHeight=569&originWidth=699&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=52599&status=done&style=none&taskId=uf758cbec-6565-4f37-90e0-d0b8ae129b9&title=" alt="image.png"><br>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说，** 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束**。<br>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><code>StackOverFlowError</code>： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError </code>错误。</li><li><code>OutOfMemoryError</code>： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><ol><li>垃圾回收是否涉及栈内存？<br>垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放 </li><li>栈内存分配越大越好吗？<br>未必，默认的栈内存通常为1024k<br>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半 </li><li>方法内的局部变量是否线程安全？</li></ol><ul><li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的 </li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全 </li><li>比如以下代码：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685363914612-e32f0740-2ccd-4672-89c6-83640a6d28f1.png#averageHue=%23e9efdb&clientId=ucd8db9d2-4e00-4&from=paste&height=585&id=u8629f588&originHeight=790&originWidth=696&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=216489&status=done&style=none&taskId=u0cef7c22-2f5c-4aee-9dbb-ac8f184519b&title=&width=515.5555919757131" alt="image.png"></p><ol start="4"><li>堆栈的区别是什么？</li></ol><ul><li>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的。堆会GC垃圾回收，而栈不会 </li><li>栈内存是线程私有的，而堆内存是线程共有的 </li><li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常 <ul><li>栈空间不足：<code>java.lang.StackOverFlowError</code></li><li>堆空间不足：<code>java.lang.OutOfMemoryError</code></li></ul></li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。<br>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code>和 <code>OutOfMemoryError</code> 两种错误</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在JVM运行过程中创建的对象和产生的数据都被存储在堆中，堆是被线程共享的内存区域，也是垃圾收集器进行垃圾回收的最主要的内存区域。由于现代JVM采用<strong>分代收集算法</strong>，因此Java堆从GC（Garbage Collection，垃圾回收）的角度还以细分为：<strong>新生代、老年代和永久代</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630793404-9b3b6bee-23d1-4cdb-a2f3-d8df84d58540.png#averageHue=%23fafaf9&from=url&id=accKy&originHeight=541&originWidth=992&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>JVM的新生代是垃圾回收器的主要关注区域之一，也是Java程序中最常用的内存区域之一。新生代被分为三个不同的区域：Eden区、Survivor区和Old区。JVM创建的对象（除了大对象）会被放在新生代</p><ol><li>Eden区：是新生代中最大的一个区域，主要用于存放新创建的对象。当一个对象被创建时，它会被分配到Eden区中，经过一段时间后，如果该对象没有被任何其他引用指向，就会被移动到Survivor区中。 </li><li>Survivor From区：</li><li>Survivor To区：</li></ol><p>JVM的新生代采用复制算法进行垃圾回收，即将存活的对象复制到另一个空闲的区域中，以便减少垃圾回收器的扫描范围。这种算法的优点是可以减少扫描的范围，但缺点是需要更多的内存来存储复制后的对象。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代是Java虚拟机(JVM)中的一个重要的内存区域，用于存放生命周期较长、存活时间较长的对象。当一个对象被创建时，它会被分配到新生代中的Eden区或Survivor区中，如果经过多次垃圾回收后仍然存活，那么它就会被晋升到老年代中。</p><p>在老年代中，垃圾回收器不会进行复制算法，而是采用标记清除、标记整理、分代收集等方式进行垃圾回收。因为老年代中的对象生命周期较长，所以它们占用的内存也较大，如果使用复制算法，会浪费更多的内存空间。</p><p>老年代中的对象通常包含一些重要的信息，比如类元数据、常量池等，因此在进行垃圾回收时需要特别小心，以免误删重要对象导致程序出错。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>永久代是Java虚拟机(JVM)中的一个特殊的内存区域，主要用于存放类的信息、常量池、静态变量等。在JDK1.8及之前的版本中，永久代是JVM的一部分，而在JDK1.8中，永久代被移除并取代为元空间(Metaspace),但是一些老的应用程序仍然在使用永久代。</p><p>在永久代中，所有的类信息和常量池都被存储在一个叫做“类定义”的表格中，每个类都有一个唯一的标识符作为键值。当一个类被加载时，它的类定义会被复制到永久代中，并且在运行时可以通过类名来访问。</p><p>由于永久代的特殊作用，它在垃圾回收中具有重要的地位。在垃圾回收过程中，如果永久代中存在未被引用的对象，那么这些对象就会被认为已经死亡，并且可以被回收。但是由于永久代的特殊性质，垃圾回收器需要特别小心，以免误删重要对象导致程序出错。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul><li>方法区(Method Area)是各个线程共享的内存区域 </li><li>主要存储类的信息、运行时常量池 </li><li>虚拟机启动的时候创建，关闭虚拟机时释放 </li><li>如果方法区域中的内存无法满足分配请求，则会抛出<code>OutOfMemoryError: Metaspace </code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364137295-8b0a9048-bea8-49a2-8263-abd32b8aaf5b.png#averageHue=%23f8eae7&clientId=ucd8db9d2-4e00-4&from=paste&height=360&id=ucca0aca8&originHeight=486&originWidth=949&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=66948&status=done&style=none&taskId=u367f811b-cb68-4b64-9e2a-17f83fbee9d&title=&width=702.963012622057" alt="image.png"><br><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364212135-ae69c7ef-a96b-4e79-85bd-2d8e7ceed0e0.png#averageHue=%23f4fdf6&clientId=ucd8db9d2-4e00-4&from=paste&id=ufe0ece25&originHeight=241&originWidth=522&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22102&status=done&style=none&taskId=ub2917c9f-244a-439e-8b5f-4e3ca9c0f9a&title=" alt="image.png"></p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><blockquote><p>常量池：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息<br>查看字节码结构（类的基本信息、常量池、方法定义）<code>javap -v xx.class</code></p></blockquote><p><a href="https://blog.csdn.net/fengyuyeguirenenen/article/details/123150212">https://blog.csdn.net/fengyuyeguirenenen/article/details/123150212</a></p><blockquote><p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</p></blockquote><p>方法区的Class文件信息，Class常量池和运行时常量池的三者关系<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364415226-94df4d89-5068-4bc6-b7ef-c87ee298d058.png#averageHue=%23d2e6d0&clientId=ucd8db9d2-4e00-4&from=paste&id=u356e219b&originHeight=330&originWidth=486&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=20298&status=done&style=none&taskId=u76fbc400-889b-4685-8e93-546ae1c48b7&title=" alt="image.png"></p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><blockquote><p>字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool。 在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p></blockquote><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364475664-44b26899-99c6-46be-98b3-41681f02fb7a.png#averageHue=%23f3fcf5&clientId=ucd8db9d2-4e00-4&from=paste&id=u3ab2eb43&originHeight=491&originWidth=751&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=45629&status=done&style=none&taskId=u40bf6134-513c-49e5-854e-42f9844f66e&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364483113-3e883c2c-f02e-4efa-8d28-e4cb8bb5d6d1.png#averageHue=%23f2fcf4&clientId=ucd8db9d2-4e00-4&from=paste&id=u8c2eb0ed&originHeight=411&originWidth=751&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=43086&status=done&style=none&taskId=u501c3be6-7d8a-4339-b39d-19aab4ffbed&title=" alt="image.png"></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>类加载器</strong></p><p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是<code>java.lang.ClassLoader</code>的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源<br><strong>类加载器种类</strong><br>类加载器根据各自加载范围的不同，划分为四种类加载器：</p><ul><li><strong>启动类加载器(BootStrap ClassLoader)：</strong><br>该类并不继承<code>ClassLoader</code>类，其是由C++编写实现。用于加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib</strong>目录下的类库。 </li><li><strong>扩展类加载器(ExtClassLoader)：</strong><br>该类是<code>ClassLoader</code>的子类，主要加载<strong>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</strong>目录中的类库。 </li><li><strong>应用类加载器(AppClassLoader)：</strong><br>该类是<code>ClassLoader</code>的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。 </li><li><strong>自定义类加载器：</strong><br>开发者自定义类继承<code>ClassLoade</code>r，实现自定义类加载规则。</li></ul><p>上述三种类加载器的层次结构如下如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685364829032-bd33e79e-baa9-45e5-9143-a11358536e8f.png#averageHue=%23f1ddd4&clientId=ucd8db9d2-4e00-4&from=paste&height=629&id=u0de07e8b&originHeight=849&originWidth=957&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=163553&status=done&style=none&taskId=u60e6cd93-9745-48f2-b5ac-1a161cde2dd&title=&width=708.8889389666055" alt="image.png"></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 </p><p>为什么采用双亲委派机制</p><ol><li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</li><li>为了安全，保证类库API不会被修改。</li></ol><h2 id="类装载执行过程"><a href="#类装载执行过程" class="headerlink" title="类装载执行过程"></a>类装载执行过程</h2><ul><li>类加载过程图</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366046084-c9497261-65f8-4d0d-99cf-93be87698841.png#averageHue=%23a2b0ab&clientId=ucd8db9d2-4e00-4&from=paste&height=341&id=uf398b8ae&originHeight=461&originWidth=873&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=288440&status=done&style=none&taskId=ub3ff8247-7398-495e-831d-95e26d878d7&title=&width=646.666712348847" alt="image.png"></p><ul><li>类加载各阶段完成任务</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685366095080-cc9f6d28-01f4-4ddf-8cac-3dad382e1b4f.png#averageHue=%23767a79&clientId=ucd8db9d2-4e00-4&from=paste&height=410&id=ub84f2255&originHeight=553&originWidth=870&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=550625&status=done&style=none&taskId=u04595ae2-2811-4bb8-a01c-5edcbc400b4&title=&width=644.4444899696414" alt="image.png"><br><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/10854/image-20220924201722195.png#clientId=ucd8db9d2-4e00-4&id=lK8Qb&originHeight=250&originWidth=1009&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u42662092-4996-4feb-add3-2cd46903186&title="></p><h3 id="加载阶段Loading"><a href="#加载阶段Loading" class="headerlink" title="加载阶段Loading"></a>加载阶段<strong>Loading</strong></h3><blockquote><p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p></blockquote><p><code>Loading</code> 就是把一个class文件装到内存中，它本来是class文件上一个个的二进制，一个个字节，通过Loading把它放到内存。<br>在加载阶段，Java 虚拟机需要完成以下工作：</p><p>通过类的全限定名获取类的二进制字节流。<br>将字节流转化为内部数据结构，并在内存中创建一个 java.lang.Class 对象来代表这个类。<br>在内存中为该类创建一个 java.lang.ClassLoader 对象，用于在后续的连接和初始化阶段使用。</p><h3 id="连接阶段—验证verification"><a href="#连接阶段—验证verification" class="headerlink" title="连接阶段—验证verification"></a>连接阶段—验证verification</h3><ol><li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li><li>包括：文件格式验证（是否以魔数 oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</li><li>可以考虑使用 -Xverify：none 参数来关闭绝大部分的验证措施，缩短虚拟机类加载的时间</li></ol><h3 id="连接阶段—准备preparation"><a href="#连接阶段—准备preparation" class="headerlink" title="连接阶段—准备preparation"></a>连接阶段—准备preparation</h3><p>JVM会在该阶段对静态变量，分配内存并默认初始化(对应数据类型的默认初始化值如0 0L null false等)。这些变量所使用的内存都将在方法区中进行分配</p><p>把class文件静态变量赋默认值，不是赋初始值。比如 <code>static int i = 8</code> ，在该步骤只是把i赋了默认值0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//属性-成员变量-字段</span></span><br><span class="line">    <span class="comment">//老韩分析类加载的链接阶段-准备 属性是如何处理</span></span><br><span class="line">    <span class="comment">//1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line">    <span class="comment">//2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是20</span></span><br><span class="line">    <span class="comment">//3. n3 是static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接阶段—解析resolution"><a href="#连接阶段—解析resolution" class="headerlink" title="连接阶段—解析resolution"></a>连接阶段—解析resolution</h3><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>把class文件常量池里面用到的符号引用，把它转成直接内存地址，可以访问到的内容。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这一步就是将静态变量赋初始值，比如上面的 <code>static int i = 8</code> ，在这一步才赋初始值8。</p><ol><li>到初始化阶段，才真正开始执行类中定义的java程序代码，此阶段是执行()方法的过程</li><li>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值待做和静态代码块中的语句，并进行合并</li><li>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，知道活动线程执行()方法完毕</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoad03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//老韩分析</span></span><br><span class="line">        <span class="comment">//1. 加载B类，并生成 B的class对象</span></span><br><span class="line">        <span class="comment">//2. 链接 num = 0</span></span><br><span class="line">        <span class="comment">//3. 初始化阶段</span></span><br><span class="line">        <span class="comment">//    依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句,并合并</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                clinit() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;B 静态代码块被执行&quot;);</span></span><br><span class="line"><span class="comment">                    //num = 300;</span></span><br><span class="line"><span class="comment">                    num = 100;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                合并: num = 100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new B();//类加载</span></span><br><span class="line">        <span class="comment">//System.out.println(B.num);//100, 如果直接使用类的静态属性，也会导致类的加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//看看加载类的时候，是有同步机制控制</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span></span><br><span class="line"><span class="comment">        throws ClassNotFoundException</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //正因为有这个机制，才能保证某个类在内存中, 只有一份Class对象</span></span><br><span class="line"><span class="comment">            synchronized (getClassLoadingLock(name)) &#123;</span></span><br><span class="line"><span class="comment">            //....</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 静态代码块被执行&quot;</span>);</span><br><span class="line">        num = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B() 构造器被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，类的初始化是由 Java 虚拟机负责的，并且只会在以下情况下进行：</p><ul><li>创建类的实例。</li><li>访问类的静态变量。</li><li>调用类的静态方法。</li><li>使用反射方式对类进行操作。</li><li>初始化类的子类。</li><li>执行 Java 应用程序的 main 方法。</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。<br>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629182248-e3c2609d-1dd2-491a-9304-cdc7f1a188aa.png#averageHue=%23f2fbf4&from=url&id=nkKE7&originHeight=177&originWidth=361&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。<br>下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629305757-0545fc81-98da-4b24-8a6e-ec79be5733b8.png#averageHue=%23f5fef7&from=url&id=JQHl1&originHeight=541&originWidth=721&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="哪些对象可以作为GC-Roots"><a href="#哪些对象可以作为GC-Roots" class="headerlink" title="哪些对象可以作为GC Roots"></a>哪些对象可以作为GC Roots</h3><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="对象可以被回收，就代表一定会被回收吗？"><a href="#对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="对象可以被回收，就代表一定会被回收吗？"></a>对象可以被回收，就代表一定会被回收吗？</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 <code>finalize </code>方法，或 <code>finalize </code>方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h2 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。<br>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629511889-7f16b482-7a56-4001-9053-293de927737e.png#averageHue=%23a5d5d4&from=url&id=w2dXv&originHeight=451&originWidth=651&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p> 为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629545584-086144bd-459b-486c-b312-bcf37e57c101.png#averageHue=%23f4fdf6&from=url&id=iUB5C&originHeight=451&originWidth=741&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>改进了标记-清除算法，但依然存在下面的问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能就会变得很差</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p> 标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683629673024-50bb9a34-5cc5-41dd-b5b9-039c7c94d94c.png#averageHue=%2391cbcc&from=url&id=EAutu&originHeight=451&originWidth=661&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，针对不同类型的对象类型，JVM采用了不同的垃圾回收算法。将 Java 堆分为新生代和老年代，新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，每次进行垃圾回收都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，可回收的对象相对较少<br>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”<strong>标记-复制</strong>“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“<strong>标记-清除</strong>”或“标记-整理”算法进行垃圾收集。<br>JVM将新生代进一步划分。JVM在运行过程中主要使用Eden区和Survivor From区，进行垃圾回收时会将Eden区和Survivor From区中存活的对象复制到Survivor To区，然后清理两个区的内存空间<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683630382838-fc023dfe-bf13-4a03-bd1e-11f81db51cf2.png#averageHue=%23f9f6ee&from=url&id=kY734&originHeight=324&originWidth=845&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。<br>Java中的四种引用类型包括：</p><ol><li>强引用(Strong Reference):是最常见的引用类型，如果一个对象被强引用指向，垃圾回收器就不会回收它。 </li><li>软引用(Soft Reference):用来描述一些还有用但并非必需的对象。只有当内存不足时，垃圾回收器才会回收被软引用指向的对象。 </li><li>弱引用(Weak Reference):用来描述非必需对象，但是比软引用更弱。如果一个对象只被弱引用所指向，那么垃圾回收器在下一次回收时就会回收它。 </li><li>虚引用(Phantom Reference):是最弱的引用类型，用来描述不可能存活的对象。如果一个对象只被虚引用所指向，那么垃圾回收器在任何时候都有可能回收它。</li></ol><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>Java堆内存分为新生代和老年代：新生代主要存储短期生命周期对象，适合使用复制算法进行垃圾回收；老年代主要存储长生命周期的对象，适合使用标记整理算法进行垃圾回收.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631816626-8133fe52-fd39-4b9f-ab52-26a570234e07.png#averageHue=%23fbf2eb&from=url&id=yMAHS&originHeight=581&originWidth=1468&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br>JVM(Java虚拟机)垃圾收集器是用于自动管理堆内存的一组工具。它们的主要目标是尽可能地减少应用程序暂停时间，以提高应用程序的性能和响应能力。</p><p>以下是一些常见的JVM垃圾收集器：</p><ol><li>Serial收集器：这是默认的收集器，它使用单线程来标记和清除存活的对象。它适用于小型应用程序，因为它的缺点是垃圾回收时间较长，可能会导致应用程序暂停。 </li><li>Parallel收集器：这是一种多线程收集器，它可以利用多个CPU核心并行执行标记和清除操作，从而缩短垃圾回收时间。它适用于大型应用程序，但需要更多的系统资源。 </li><li>CMS收集器：这是一种低延迟收集器，它可以在应用程序运行时进行垃圾回收，而不会影响应用程序的性能。它适用于对响应时间要求较高的应用程序。 </li><li>G1收集器：这是一种基于区域的收集器，它将堆划分为多个大小相等的区域，并在这些区域内进行垃圾回收。它可以减少GC暂停时间并提高吞吐量。它适用于大型应用程序和高负载环境。</li></ol><p>JVM垃圾收集器的选择取决于应用程序的需求和环境。在选择垃圾收集器时，需要考虑应用程序的性质、硬件配置、可用内存等因素。</p><h2 id="新生代-1"><a href="#新生代-1" class="headerlink" title="新生代"></a>新生代</h2><h3 id="Serial收集器：单线程，复制算法"><a href="#Serial收集器：单线程，复制算法" class="headerlink" title="Serial收集器：单线程，复制算法"></a>Serial收集器：单线程，复制算法</h3><p>Serial垃圾收集器基于复制算法实现，它是一个单线程收集器，在它正在进行垃圾收集时，必须暂停其它工作线程，直到垃圾收集完毕<br>特点：简单、高效<br>是Java虚拟机运行在Client模式下的新生代的默认垃圾处理器<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683631968047-9ae37729-acbd-4099-8c4e-5766fa6c7bbf.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=ueda4f2cf&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=u43d8d21c-2fae-4754-b613-adde849c645&title=" alt="image.png"></p><h3 id="ParNew收集器：多线程，复制算法"><a href="#ParNew收集器：多线程，复制算法" class="headerlink" title="ParNew收集器：多线程，复制算法"></a>ParNew收集器：多线程，复制算法</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632203749-aa4e1baa-dc1f-40e9-8bcd-043597efb590.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u722ab4f7&originHeight=245&originWidth=853&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=23095&status=done&style=none&taskId=uedad3fd7-98d4-457a-9f86-55dad756f63&title=" alt="image.png"></p><h3 id="Parallel-Scavenge收集器：多线程，复制算法"><a href="#Parallel-Scavenge收集器：多线程，复制算法" class="headerlink" title="Parallel Scavenge收集器：多线程，复制算法"></a>Parallel Scavenge收集器：多线程，复制算法</h3><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632308217-b9c5b923-2fb8-401f-ba88-d9678cd79d5b.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=uceece797&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u978058f2-2415-4553-b2f3-b99efd0682c&title=" alt="image.png"><br><strong>这是 JDK1.8 默认收集器</strong></p><h2 id="老年代-1"><a href="#老年代-1" class="headerlink" title="老年代"></a>老年代</h2><h3 id="Serial-Old收集器：单线程，标记整理算法"><a href="#Serial-Old收集器：单线程，标记整理算法" class="headerlink" title="Serial Old收集器：单线程，标记整理算法"></a>Serial Old收集器：单线程，标记整理算法</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632429864-a623c075-fe2e-40c3-8ed4-f09c84941d19.png#averageHue=%23fafafa&clientId=u275002bd-b1a6-4&from=paste&id=u3fc3b7df&originHeight=251&originWidth=850&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=21307&status=done&style=none&taskId=uda15cb43-7ea0-4939-b27b-79c006bbacc&title=" alt="image.png"></p><h3 id="Parallel-Old收集器：多线程，标记整理算法"><a href="#Parallel-Old收集器：多线程，标记整理算法" class="headerlink" title="Parallel Old收集器：多线程，标记整理算法"></a>Parallel Old收集器：多线程，标记整理算法</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632442127-02a1b005-0e75-48b1-97f8-696544f00177.png#averageHue=%23f8f8f8&clientId=u275002bd-b1a6-4&from=paste&id=u28ac7316&originHeight=235&originWidth=845&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=22740&status=done&style=none&taskId=u873b20f7-d26a-497c-9c7a-9669df7fb71&title=" alt="image.png"></p><h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong><br><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong><br>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632462911-869d143d-c390-4310-a541-ea3cdb9cebff.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=ubcf34b5e&originHeight=259&originWidth=1070&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27060&status=done&style=none&taskId=ucca971d1-af12-4c5d-8a6d-eebad040f40&title=" alt="image.png"><br>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong><br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683632495542-8ffb84e3-2063-4feb-8814-4d10007c4fab.png#averageHue=%23f9f9f9&clientId=u275002bd-b1a6-4&from=paste&id=u196f3523&originHeight=262&originWidth=999&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=27690&status=done&style=none&taskId=u3fd59542-6ed5-48fa-8f17-62d4d92655b&title=" alt="image.png"><br><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h1 id="JVM实践"><a href="#JVM实践" class="headerlink" title="JVM实践"></a>JVM实践</h1><h2 id="JVM-调优的参数可以在哪里设置参数值？"><a href="#JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="JVM 调优的参数可以在哪里设置参数值？"></a>JVM 调优的参数可以在哪里设置参数值？</h2><h3 id="tomcat的设置vm参数"><a href="#tomcat的设置vm参数" class="headerlink" title="tomcat的设置vm参数"></a>tomcat的设置vm参数</h3><p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件，如下图</p><p><code>JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; </code><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685365312898-eb078aed-6d50-401c-bebd-239052d5ca6a.png#averageHue=%23fbfaf9&clientId=ucd8db9d2-4e00-4&from=paste&height=229&id=u5c273d4d&originHeight=309&originWidth=970&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=102855&status=done&style=none&taskId=u819bf20f-bbb6-4ede-8249-7f58f943609&title=&width=718.5185692764967" alt="image.png"></p><h3 id="jar文件启动"><a href="#jar文件启动" class="headerlink" title="jar文件启动"></a>jar文件启动</h3><p>通常在linux系统下直接加参数启动springboot项目</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod &amp;</span><br></pre></td></tr></table></figure><blockquote><p>nohup  :  用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行<br>参数 <strong>&amp;</strong>  ：让命令在后台执行，终端退出后命令仍旧执行。</p></blockquote><h2 id="用的JVM调优的参数"><a href="#用的JVM调优的参数" class="headerlink" title="用的JVM调优的参数"></a>用的JVM调优的参数</h2><pre><code>对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</code></pre><p><a href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p><p>1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms：设置堆的初始化大小</span><br><span class="line"></span><br><span class="line">-Xmx：设置堆的最大大小</span><br></pre></td></tr></table></figure><p>2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p><p>的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3</span><br></pre></td></tr></table></figure><p>3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:newSize   设置年轻代的初始大小</span><br><span class="line">-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同</span><br></pre></td></tr></table></figure><p>4）线程堆栈的设置：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xss   对每个线程stack大小的调整,-Xss128k</span><br></pre></td></tr></table></figure><p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小</p><p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p><p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold&#x3D;1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p><p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。</span><br><span class="line"></span><br><span class="line">（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。</span><br></pre></td></tr></table></figure><p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+LargePageSizeInBytes 设置内存页的大小</span><br></pre></td></tr></table></figure><p>10）使用非占用的垃圾收集器。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。</span><br></pre></td></tr></table></figure><h2 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h2><h3 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h3><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1685365432677-493fab04-7a4f-46fb-9309-6e0b18340e8e.png#averageHue=%23161412&clientId=ucd8db9d2-4e00-4&from=paste&height=141&id=u6252eaeb&originHeight=191&originWidth=411&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&size=40794&status=done&style=none&taskId=udc822087-02c3-4fab-863b-abb68e0ef3e&title=&width=304.4444659511754" alt="image.png"></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>查看java进程内<strong>线程的堆栈</strong>信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstack [option] &lt;pid&gt;  </span><br></pre></td></tr></table></figure><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>用于生成堆转存快照</p><blockquote><p>jmap [options] pid  内存映像信息<br>jmap -heap pid   显示Java堆的信息<br>jmap -dump:format&#x3D;b,file&#x3D;heap.hprof pid<br>        format&#x3D;b表示以hprof二进制格式转储Java堆的内存<br>        file&#x3D;用于指定快照dump文件的文件名。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\yuhon&gt;jmap -heap <span class="number">53280</span></span><br><span class="line">Attaching to process ID <span class="number">53280</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.321</span>-b07</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">8</span> thread(s)   <span class="comment">//并行的垃圾回收器</span></span><br><span class="line"></span><br><span class="line">Heap Configuration:  <span class="comment">//堆配置</span></span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span>   <span class="comment">//空闲堆空间的最小百分比</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span>  <span class="comment">//空闲堆空间的最大百分比</span></span><br><span class="line">   MaxHeapSize              = <span class="number">8524922880</span> (<span class="number">8130.</span>0MB) <span class="comment">//堆空间允许的最大值</span></span><br><span class="line">   NewSize                  = <span class="number">178257920</span> (<span class="number">170.</span>0MB) <span class="comment">//新生代堆空间的默认值</span></span><br><span class="line">   MaxNewSize               = <span class="number">2841640960</span> (<span class="number">2710.</span>0MB) <span class="comment">//新生代堆空间允许的最大值</span></span><br><span class="line">   OldSize                  = <span class="number">356515840</span> (<span class="number">340.</span>0MB) <span class="comment">//老年代堆空间的默认值</span></span><br><span class="line">   NewRatio                 = <span class="number">2</span> <span class="comment">//新生代与老年代的堆空间比值，表示新生代：老年代=1：2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span> <span class="comment">//两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.</span>796875MB) <span class="comment">//元空间的默认值</span></span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.</span>0MB) <span class="comment">//压缩类使用空间大小</span></span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB <span class="comment">//元空间允许的最大值</span></span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.</span>0MB)<span class="comment">//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</span></span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space: <span class="comment">//Eden使用情况</span></span><br><span class="line">   capacity = <span class="number">134217728</span> (<span class="number">128.</span>0MB)</span><br><span class="line">   used     = <span class="number">10737496</span> (<span class="number">10.</span>240074157714844MB)</span><br><span class="line">   free     = <span class="number">123480232</span> (<span class="number">117.</span>75992584228516MB)</span><br><span class="line">   <span class="number">8.000057935714722</span>% used</span><br><span class="line">From Space: <span class="comment">//Survivor-From 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space: <span class="comment">//Survivor-To 使用情况</span></span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation  <span class="comment">//老年代 使用情况</span></span><br><span class="line">   capacity = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.</span>0MB)</span><br><span class="line">   free     = <span class="number">356515840</span> (<span class="number">340.</span>0MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">3185</span> interned Strings occupying <span class="number">261264</span> bytes.</span><br></pre></td></tr></table></figure><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。<br><strong>常见参数</strong>：<br>①总结垃圾回收统计</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstat -gcutil pid</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>S0</td><td>幸存1区当前使用比例</td></tr><tr><td>S1</td><td>幸存2区当前使用比例</td></tr><tr><td>E</td><td>伊甸园区使用比例</td></tr><tr><td>O</td><td>老年代使用比例</td></tr><tr><td>M</td><td>元数据区使用比例</td></tr><tr><td>CCS</td><td>压缩使用比例</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table><p>②垃圾回收统计</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstat -gc pid</span><br></pre></td></tr></table></figure><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p><p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p><h5 id="VisualVM：故障处理工具"><a href="#VisualVM：故障处理工具" class="headerlink" title="VisualVM：故障处理工具"></a>VisualVM：故障处理工具</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p><p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(上)</title>
      <link href="/posts/5ea3.html"/>
      <url>/posts/5ea3.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li><code>并行</code>：指两个以上事件在<code>同一时刻</code>发生，需要多个CPU或多核处理器来实现。</li><li><code>并发</code>：指两个以上事件在<code>同一个时间段内</code>发生；这些任务可以在同一CPU上交替执行，也可以在多个CPU上并行执行。</li></ul><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程：线程是一个比进程更小的执行单。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位<br>在Java中，当我们启动main函数时其实就是启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684756911891-b25a2aa7-a141-420f-8c27-b56984530f8d.png#averageHue=%23c4e3da&clientId=ua714dc0b-a2fb-4&from=paste&id=u21534992&originHeight=905&originWidth=701&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=81138&status=done&style=none&taskId=uc4e71480-00af-45b0-92b9-2abc4c47825&title=" alt="image.png"><br>引用：<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B</a></p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>线程：线程是一种轻量级的执行单元，它是进程中的一部分，用于执行程序中的代码。一个进程可以包含多个线程，这些线程共享进程的资源，如内存、文件句柄等。</p><h1 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>继承<code>Thread</code>类并重写<code>run()</code>方法：创建一个类继承<code>Thread</code>类，并重写<code>run()</code>方法。然后创建该类的实例并调用<code>start()</code>方法即可启动线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口⭐"><a href="#实现Runnable接口⭐" class="headerlink" title="实现Runnable接口⭐"></a>实现Runnable接口⭐</h2><p>将<code>线程</code>和<code>任务</code>分开</p><ul><li>Thread代表线程</li><li>Runnabl代表可运行的任务（线程要执行的代码） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>java8以后可以使用·lambda精简代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></li></ul><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><p>实现<code>Callable</code>接口：创建一个实现了<code>Callable</code>接口的类，并实现<code>call()</code>方法。然后创建该类的实例，并将其作为参数传递给<code>ExecutorService</code>的<code>submit()</code>方法中，最后调用<code>get()</code>方法可以获取线程执行的结果。 </p><p>Callable接口和Runnable接口类似，都是为了实现多线程编程而设计的，但是它们之间也有一些不同点。</p><ul><li>Callable接口可以<strong>返回线程执行的结果</strong>，而Runnable接口的run()方法没有返回值。</li><li>Callable接口的<code>call()</code>方法可以<strong>抛出异常</strong>，而Runnable接口的run()方法不能抛出异常。</li></ul><p>使用Callable接口创建线程的步骤如下：</p><ol><li>创建一个实现了Callable接口的类，并实现call()方法。 </li><li>创建一个ExecutorService对象，它是Java线程池的实现类。 </li><li>调用ExecutorService的submit(Callable)方法，将上一步创建的Callable对象作为参数传入。 </li><li>调用Future对象的get()方法可以获取线程执行的结果，该方法会阻塞当前线程，直到线程执行完成并返回结果。</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Callable对象</span></span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获取Future对象</span></span><br><span class="line">        Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程执行的结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Callable接口创建线程可以返回线程执行的结果，这在一些需要返回结果的场景下非常有用。但是需要注意的是，与Runnable接口不同，Callable接口不能直接用于创建Thread对象，需要通过<code>ExecutorService</code>来执行。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>使用线程池：通过<code>Executor</code>框架提供的线程池来创建线程，可以避免频繁创建和销毁线程的开销，提高程序的性能和稳定性。<br>常用的线程池有以下几种：</p><ol><li><code>FixedThreadPool</code>：创建一个<strong>固定大小</strong>的线程池，<strong>所有任务都将在同一时刻执行</strong>，如果线程池中的线程都在执行任务时，新的任务将等待有空闲的线程再执行。 </li><li><code>CachedThreadPool</code>：创建一个可以<strong>根据需要创建新线程</strong>的线程池，如果线程池中的线程都在执行任务时，新的任务将创建新的线程执行。 </li><li><code>SingleThreadExecutor</code>：创建一个<strong>只有一个线程</strong>的线程池，所有任务都将在同一时刻执行，如果该线程由于异常停止，将创建一个新的线程来代替它。 </li><li><code>ScheduledThreadPool</code>：创建一个<strong>固定大小</strong>的线程池，可以<strong>延迟</strong>或<strong>定时</strong>执行任务。</li></ol><p>使用线程池的好处在于，可以<strong>避免频繁创建和销毁线程的开销，提高程序的性能和稳定性</strong>。同时，线程池还提供了一些额外的功能，如<strong>定期执行任务</strong>、<strong>延迟执行任务</strong>、<strong>任务取消</strong>等。</p><p>下面是一个使用FixedThreadPool线程池的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含3个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们创建了一个包含3个线程的FixedThreadPool线程池，并通过submit()方法提交了10个任务。由于线程池大小为3，因此每次最多只有3个任务在同时执行，其他任务将等待有空闲的线程再执行。最后通过shutdown()方法关闭线程池。</p><p>使用线程池可以提高程序性能和稳定性，但是需要注意以下几点：</p><ol><li><strong>确定线程池大小</strong>：线程池大小需要根据实际应用场景来确定，如果线程池过小，可能会导致任务等待时间过长，如果线程池过大，可能会浪费系统资源。 </li><li><strong>避免死锁</strong>：在使用线程池时，需要注意避免死锁等并发问题，如尽量避免线程间的相互等待，使用锁时需要注意加锁顺序等。 </li><li><strong>处理异常情况</strong>：在任务执行过程中可能会出现异常，需要及时处理并记录异常信息，避免影响线程池的正常运行。 </li><li><strong>关闭线程池</strong>：在程序结束时需要及时关闭线程池，以释放系统资源。</li></ol><h1 id="线程池的工作原理📑"><a href="#线程池的工作原理📑" class="headerlink" title="线程池的工作原理📑"></a>线程池的工作原理📑</h1><p>线程池是一种<strong>管理和复用线程的机制</strong>，它可以减少线程创建和销毁的开销，提高程序的性能和稳定性。线程池的工作原理如下：</p><ol><li>线程池创建：当创建一个线程池时，它会创建一定数量的线程并保存在一个线程池中，线程池还会维护一个任务队列，用于存放需要执行的任务。 </li><li>任务提交：当有新的任务需要执行时，可以通过Executor框架提供的execute()方法将任务提交给线程池，线程池会从任务队列中获取一个任务并将其分配给一个线程执行。 </li><li>线程执行任务：线程从任务队列中取出一个任务并执行，执行完成后线程会返回线程池并等待下一个任务的分配。如果有多个线程空闲，则会同时执行多个任务。 </li><li>线程池管理：线程池会管理线程的状态、启动、停止、暂停、恢复等操作，并监控线程池的运行状态，如线程池的大小、任务队列的长度等，以便及时调整线程池的大小和优化线程池的运行效率。</li></ol><h2 id="线程池处理任务"><a href="#线程池处理任务" class="headerlink" title="线程池处理任务"></a>线程池处理任务</h2><blockquote><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B">https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B</a></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684758773397-368c63c1-0952-4d6b-93ce-13f5597334ce.png#averageHue=%23ffffff&clientId=ufb24d838-bc67-4&from=paste&id=u9a2b96da&originHeight=275&originWidth=639&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=16549&status=done&style=none&taskId=u571d3391-bd04-4384-8970-e0ed06b003b&title=" alt="image.png"></p><ol><li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法</li></ol><h2 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h2><p>线程复用是指在线程执行完任务后，不立即销毁线程，而是将其放回线程池中，以便后续可以再次使用该线程。线程复用可以避免频繁创建和销毁线程的开销，提高程序的性能和稳定性。</p><p>线程复用的实现原理是，线程池会在初始化时创建一定数量的线程，并将其保存在一个线程池中，当有新的任务需要执行时，线程池会从线程池中获取一个空闲的线程，并将任务分配给该线程执行。当线程执行完任务后，线程不会被销毁，而是继续保持在线程池中，以便后续可以再次使用。</p><p>线程复用的好处在于，可以避免频繁创建和销毁线程的开销，提高程序的性能和稳定性。同时，线程复用还可以防止线程数量过多导致系统资源的浪费和性能下降。</p><p>线程复用的缺点在于，如果线程执行的任务过于耗时或者阻塞，会导致线程池中的其他线程无法执行任务，从而影响程序的性能和响应速度。因此，在使用线程池时，需要根据实际情况来确定线程池的大小和任务的类型，以确保线程池的正常运行和任务的及时处理。</p><p>线程复用的实现方式有多种，其中最常用的是使用线程池来管理和复用线程。线程池可以自动管理线程的状态、启动、停止、暂停、恢复等操作，并监控线程池的运行状态，如线程池的大小、任务队列的长度等，以便及时调整线程池的大小和优化线程池的运行效率。</p><h2 id="线程池的核心组件和核心类"><a href="#线程池的核心组件和核心类" class="headerlink" title="线程池的核心组件和核心类"></a>线程池的核心组件和核心类</h2><p>线程池的核心组件主要由以下四个核心组件组成：</p><ul><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中执行具体任务的线程</li><li>任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程的任务才能够被线程调度</li><li>任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中删除</li></ul><p>Java中线程池的核心类包括以下几个：</p><ol><li>Executor：是线程池框架的顶层接口，它定义了线程池的基本执行方法，如execute()方法可以向线程池提交一个Runnable任务。 </li><li>ThreadPoolExecutor：是Java中线程池的核心实现类，它实现了Executor接口，并提供了丰富的线程池管理功能，如线程池大小、任务队列、线程池状态等。 </li><li>Executors：是一个工具类，提供了一些静态方法，用于创建常用的线程池实例，如newFixedThreadPool()、newCachedThreadPool()、newSingleThreadExecutor()等。 </li><li>ScheduledExecutorService：是一个继承自ExecutorService的接口，它提供了定期执行任务和延迟执行任务的功能，可以用于实现定时任务和周期性任务等。</li></ol><p>ThreadPoolExecutor是Java中线程池的核心实现类，它的构造函数如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池中的核心线程数，即在没有任务执行时线程池中的线程数</td></tr><tr><td>maximumPoolSize</td><td>线程池中允许的最大线程数，当线程池中的线程数已经达到corePoolSize并且任务队列已满时，线程池会创建新的线程执行任务，直到线程数达到maximumPoolSize</td></tr><tr><td>keepAliveTime</td><td>空闲线程的存活时间，当线程池中的线程数量超过corePoolSize时，多余的线程在空闲时间达到keepAliveTime时会被销毁，直到线程池中的线程数量不超过corePoolSize</td></tr><tr><td>unit</td><td>keepAliveTime参数的时间单位</td></tr><tr><td>workQueue</td><td>用于存储待执行任务的阻塞队列，可以是有界队列或无界队列</td></tr><tr><td>threadFactory</td><td>用于创建新线程的工厂类，可以自定义线程的名称、优先级、守护状态等属性</td></tr><tr><td>handler</td><td>当线程池中的线程已经达到最大值，且队列也已经满了，此时如果还有新的任务提交，如何处理的策略，例如抛出异常、阻塞、丢弃等</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1684758731784-096d6005-5cc2-401e-b677-3d9b76935a99.png#averageHue=%23b5b7b5&clientId=ufb24d838-bc67-4&from=paste&id=u1ae10f3e&originHeight=1042&originWidth=1666&originalType=url&ratio=1.3499999046325684&rotation=0&showTitle=false&size=329628&status=done&style=none&taskId=u332dd7c9-ad2b-467b-a136-16c09489725&title=" alt="image.png"><br>下面是一个使用ThreadPoolExecutor创建线程池的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个线程池，核心线程数为5，最大线程数为10，空闲线程存活时间为60秒，任务队列为LinkedBlockingQueue</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向线程池提交一个任务</span></span><br><span class="line">threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个ThreadPoolExecutor对象，并设置了核心线程数为5，最大线程数为10，空闲线程存活时间为60秒，并使用LinkedBlockingQueue作为任务队列。然后，我们向线程池提交一个Runnable任务，并最终关闭了线程池。</p><h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><p>线程池的工作流程可以分为以下几个步骤：</p><ol><li>当有新的任务需要执行时，线程池会首先判断当前线程池中的线程数量是否达到核心线程数(corePoolSize)。如果没有达到，则创建一个新的线程执行该任务，否则进入下一步。 </li><li>将任务添加到任务队列(BlockingQueue)中，等待线程池中的线程执行任务。任务队列可以是有界队列或无界队列，如果任务队列已满，则根据拒绝策略(RejectedExecutionHandler)来处理该任务，例如抛出异常、阻塞、丢弃等。 </li><li>当线程池中的线程已经全部占用时，新的任务会被放入任务队列中等待执行。此时，线程池会从任务队列中取出一个任务分配给一个空闲的线程执行。 </li><li>当线程执行完任务后，该线程会被返回到线程池中，等待下一次执行任务。如果线程池中的线程数量超过核心线程数(corePoolSize)，则空闲的线程会在一定时间内(keepAliveTime)被销毁，直到线程池中的线程数量不超过核心线程数。 </li><li>当线程池不再需要执行新的任务时，可以调用shutdown()方法关闭线程池。此时，线程池会拒绝接收新的任务，并等待所有已提交的任务执行完成。如果任务队列中还有未执行的任务，则这些任务也会被执行完毕。 </li><li>在线程池关闭后，可以调用awaitTermination()方法等待线程池中的任务执行完成。如果所有任务都已执行完毕，则awaitTermination()方法返回true，否则返回false。</li></ol><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>线程池的拒绝策略指的是当线程池中的线程已经达到最大值，且任务队列也已经满了，此时如果还有新的任务提交，线程池应该如何处理的策略。Java中提供了四种拒绝策略，分别是：</p><ol><li><code>AbortPolicy</code>：<strong>默认</strong>的拒绝策略，当线程池无法处理新的任务时，会抛出<code>RejectedExecutionException</code>异常。 </li><li><code>CallerRunsPolicy</code>：当线程池无法处理新的任务时，会将任务交给当前线程来执行。这种策略可以保证任务一定会被执行，但可能会影响当前线程的性能。 </li><li><code>DiscardOldestPolicy</code>：当线程池无法处理新的任务时，会丢弃队列中最早的任务，然后将新的任务添加到队列末尾。这种策略可以保证队列中的任务都是比较新的任务，但可能会丢失一些重要的任务。 </li><li><code>DiscardPolicy</code>：当线程池无法处理新的任务时，会直接丢弃新的任务，不做任何处理。这种策略可以避免因任务过多导致线程池崩溃，但可能会丢失大量的任务。</li></ol><p>可以通过ThreadPoolExecutor类的构造函数来设置拒绝策略，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workQueue, Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="查看可用处理器数目（最大并行数）"><a href="#查看可用处理器数目（最大并行数）" class="headerlink" title="查看可用处理器数目（最大并行数）"></a>查看可用处理器数目（最大并行数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure><h3 id="线程池多大合适"><a href="#线程池多大合适" class="headerlink" title="线程池多大合适"></a>线程池多大合适</h3><ul><li>CPU密集型运算：最大并行数+1</li><li>I&#x2F;O密集型运算（读取文件、数据库）：</li></ul><p><img src="https://cdn.nlark.com/yuque/__latex/fb7a79ef9aab2b48155784adc3494c51.svg#card=math&code=%E6%9C%80%E5%A4%A7%E5%B9%B6%E8%A1%8C%E6%95%B0%20%2A%20%E6%9C%9F%E6%9C%9BCPU%E5%88%A9%E7%94%A8%E7%8E%87%20%2A%20%5Cfrac%7B%E6%80%BB%E6%97%B6%E9%97%B4%28CPU%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%2B%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%29%7D%7BCPU%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%7D%0A%0A&id=Zypmk"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1681872353293-8cd9cd32-3765-4607-a1df-c571eab51c53.png#averageHue=%23fcf7f4&from=url&id=rrVjd&originHeight=367&originWidth=1836&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="4种常用的线程池"><a href="#4种常用的线程池" class="headerlink" title="4种常用的线程池"></a>4种常用的线程池</h1><p>以下是4种常用的线程池：</p><ol><li><code>FixedThreadPool</code>（固定大小线程池）：该线程池的核心线程数和最大线程数都是固定的，当线程池中的线程数量达到核心线程数时，新的任务就会被放入阻塞队列中等待执行。该线程池适用于执行长期的任务，可以避免线程的频繁创建和销毁，提高程序的性能和稳定性。 </li><li><code>CachedThreadPool</code>（缓存线程池）：该线程池的核心线程数为0，最大线程数为<code>Integer.MAX_VALUE</code>，即线程池中的线程数量可以随着任务的增加而自动增加。当线程池中的线程数量超过任务数量时，空闲线程会在一定时间内被回收。该线程池适用于执行短期的任务，可以动态地调整线程池的大小以适应负载变化。 </li><li><code>SingleThreadPool</code>（单线程池）：该线程池只有一个线程在工作，所有任务都在该线程中串行执行。当该线程执行完任务后，会等待新的任务到来。该线程池适用于需要顺序执行任务的场景，可以避免多线程下的竞态条件和死锁等问题。 </li><li><code>ScheduledThreadPool</code>（定时任务线程池）：该线程池用于执行定时任务和周期性任务，可以通过<code>schedule()</code>方法或<code>scheduleAtFixedRate()</code>方法来提交任务，并在指定的时间间隔内执行任务。该线程池可以避免手动创建线程和调度任务的繁琐工作，提高程序的可读性和可维护性。</li></ol><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线Java中的线程生命周期可以分为以下5个状态：</p><ol><li>新建状态（<code>New</code>）：当一个<code>Thread</code>类或者其子类的实例被创建时，该线程就处于新建状态。此时，线程并没有开始运行，只是给线程分配了必要的资源。 </li><li>就绪状态（<code>Runnable</code>）：当线程处于就绪状态时，表示线程已经准备好了运行，只是还没有得到CPU的执行权。此时，线程处于等待CPU的状态。 </li><li>运行状态（<code>Running</code>）：当线程获得CPU的执行权时，进入运行状态。此时，线程真正开始运行，执行自己的任务。 </li><li>阻塞状态（<code>Blocked</code>）：当线程被阻塞时，表示线程暂时停止了执行。线程进入阻塞状态有多种原因，如等待某个资源（比如输入输出、网络连接等），或者等待另一个线程的操作完成等。 阻塞状态分为以下三种</li><li>等待阻塞：在运行状态的线程调用<code>o.wait</code>方法时，<code>JVM</code>会把该线程放入等待队列（<code>Waitting Queue</code>）中，线程转为阻塞状态</li><li>同步阻塞：在运行的线程尝试获取正在被其它线程占用的对象同步锁时，JVM会把该线程放入锁池（<code>Lock Pool</code>）中，线程转为阻塞状态</li><li>其它阻塞：运行状态的线程在执行<code>sleep</code>、<code>join</code>或者发出I&#x2F;O请求时，线程变为阻塞状态。直到<code>sleep</code>状态超时、<code>join</code>等待线程终止或者超时，I&#x2F;O处理完毕，线程才重新转为可运行状态。</li><li>终止状态（<code>Terminated</code>）：当线程执行完自己的任务后，进入终止状态。此时，线程释放了占用的资源，线程对象也被销毁。</li></ol><p>需要注意的是，线程的状态不是线性的，线程可以在各个状态之间切换，当线程被唤醒时，它会从等待状态转换为就绪状态，等待CPU的调度再次执行。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1679706512475-c00a3ecc-ddf8-49b4-a254-2d05774d8df6.png?x-oss-process=image/resize,w_1125,limit_0#averageHue=%23f5e0de&from=url&id=M721h&originHeight=382&originWidth=1125&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32620241/1683633428068-3e129e6c-7d09-4cd4-a7b6-dcbed6eaf45c.png#averageHue=%23fafaf9&from=url&id=I9M2J&originHeight=550&originWidth=1375&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="线程的基本方法"><a href="#线程的基本方法" class="headerlink" title="线程的基本方法"></a>线程的基本方法</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>Java中的Thread类提供了许多方法来控制线程的行为和状态，常用的线程方法包括：</p><ol><li>start()方法：启动线程并使其进入就绪状态，等待系统调度执行。 </li><li>run()方法：线程的任务执行体，包含了线程需要执行的代码逻辑。 </li><li>sleep()方法：让线程进入阻塞状态，等待一定时间后再继续执行。该方法可以用于实现线程的延迟执行和等待操作。 </li><li>join()方法：让一个线程等待另一个线程执行完毕后再继续执行。该方法可以用于协调多个线程的执行顺序和数据同步。 </li><li>yield()方法：让线程放弃当前的CPU资源，让其他线程执行。该方法可以用于提高线程的公平性和并发度。 </li><li>interrupt()方法：中断线程的执行，使其进入结束状态。该方法可以用于停止长时间运行的线程或处理异常情况。 </li><li>isAlive()方法：判断线程是否处于运行状态。如果线程已经结束或还没有启动，该方法会返回false，否则返回true。 </li><li>setPriority()方法：设置线程的优先级，用于控制线程在竞争CPU资源时的优先级。线程的优先级可以设置为1~10之间的整数，数值越大表示优先级越高。 </li><li>getName()和setName()方法：获取和设置线程的名称，用于标识线程的身份和区分不同的线程。 </li><li>currentThread()方法：获取当前线程对象的引用，用于在多线程环境下确定当前线程的身份和状态。</li></ol><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的<strong>join</strong>()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。</p><p>代码举例：</p><p>为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();                          <span class="comment">// 加入线程t1,只有t1线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();                              <span class="comment">// 加入线程t2,只有t2线程执行完毕以后，再次执行该线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        &#125;) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sleep方法和wait方法的区别"><a href="#sleep方法和wait方法的区别" class="headerlink" title="sleep方法和wait方法的区别"></a>sleep方法和wait方法的区别</h2><p>sleep()方法和wait()方法都可以使线程进入阻塞状态，但是它们的作用和使用方式有所不同，主要区别如下：</p><ol><li>线程对象：sleep()方法是Thread类的<strong>静态方法</strong>，可以直接调用；wait()方法是Object类的<strong>实例方法</strong>，只能在同步代码块或同步方法中使用。 </li><li>使用方式：sleep()方法用于让当前线程休眠一段时间，<strong>不会释放锁</strong>，通常用于实现线程的延迟执行或等待操作；wait()方法用于使当前线程进入等待状态，<strong>会释放锁</strong>，等<strong>待其他线程调用notify()或notifyAll()方法唤醒自己</strong>。 </li><li>调用方式：<strong>sleep()方法可以在任何地方使用</strong>，不需要获取锁或同步监视器；<strong>wait()方法必须在同步代码块或同步方法中使用</strong>，需要获取锁或同步监视器。 </li><li>唤醒方式：sleep()方法会<strong>在指定时间后自动唤醒</strong>，或者<strong>被其他线程中断唤醒</strong>；wait()方法必须<strong>等待其他线程调用notify()或notifyAll()方法</strong>才能被唤醒。 </li><li>使用条件：sleep()方法可以在任何时候调用，不需要满足特定条件；wait()方法必须在满足特定条件下调用，例如在等待某个资源准备好或者等待某个条件满足时调用。</li></ol><h2 id="start方法和run方法的区别"><a href="#start方法和run方法的区别" class="headerlink" title="start方法和run方法的区别"></a>start方法和run方法的区别</h2><p>start()方法和run()方法是Thread类中最常用的两个方法，它们的作用和使用方式有所不同，主要区别如下：</p><ol><li>启动方式：start()方法用于启动一个新的线程，让该线程进入就绪状态，等待系统调度执行；run()方法是线程的任务执行体，用于定义线程需要执行的代码逻辑。 </li><li>线程对象：start()方法是Thread类的<strong>实例方法</strong>，必须在线程对象上调用；run()方法是<strong>普通的方法</strong>，可以在任何地方调用。 </li><li>多线程：start()方法启动的是一个新的线程，不会阻塞当前线程，可以实现多线程并发执行；run()方法是在当前线程中执行，会阻塞当前线程，不能实现多线程并发执行。 </li><li>执行顺序：start()方法启动线程后，线程会进入就绪状态，等待系统调度执行，线程的执行顺序是不确定的；run()方法是在当前线程中调用的，线程的执行顺序是顺序执行的，不会产生并发效果。</li></ol><h2 id="终止线程的4种方法"><a href="#终止线程的4种方法" class="headerlink" title="终止线程的4种方法"></a>终止线程的4种方法</h2><p>终止线程是多线程编程中的一个重要问题，线程的终止可以通过以下4种方式实现：</p><ol><li><strong>使用标志位</strong>：可以在执行线程的任务逻辑中设置一个标志位，当该标志位为false时，线程继续执行任务；当标志位为true时，线程退出循环，执行终止操作。这种方式需要保证标志位的可见性和正确性，通常需要使用volatile关键字来修饰标志位。 </li><li><strong>使用stop()方法</strong>：stop()方法可以强制终止线程的执行，但是不推荐使用，因为该方法可能会导致线程的资源泄漏、数据不一致和死锁等问题。 </li><li><strong>使用interrupt()方法</strong>：interrupt()方法可以中断线程的阻塞状态，抛出InterruptedException异常，线程可以在捕获异常后进行终止操作。这种方式需要在线程的任务逻辑中检测当前线程的中断状态，通常需要使用Thread.currentThread().isInterrupted()方法来实现。 </li><li><strong>使用Thread类的stop、resume、suspend方法</strong>：这三个方法都已经被标记为过时方法，不推荐使用，因为它们可能会产生死锁、数据异常和线程安全等问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
